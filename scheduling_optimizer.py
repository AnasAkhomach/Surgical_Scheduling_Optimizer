# This script contains the optimization logic for the surgery scheduling using Tabu Search

from models import Surgery, SurgeryRoomAssignment, Surgeon
from initialize_data import (initialize_patients, initialize_staff_members, initialize_surgeons,
                             initialize_operating_rooms, initialize_surgeries, initialize_surgery_equipments,
                             initialize_surgery_equipment_usages, initialize_surgery_room_assignments,
                             initialize_surgery_staff_assignments)

from scheduling_utils import (
    shift_time, find_surgeon, is_room_available,
    calculate_room_utilization, check_equipment_availability
)

import random
from datetime import datetime, timedelta
print("Imports successful.")


class TabuSearchScheduler:
    def __init__(self, surgeries, room_assignments, surgeons):
        self.surgeries = surgeries
        self.room_assignments = room_assignments
        self.surgeons = surgeons
        self.tabu_list = []
        self.best_solution = None
        self.best_cost = float('inf')



    def generate_neighbors(self, surgeries, room_assignments):
        """
        Generate a set of neighboring schedules by altering the given schedule.

        Neighbors are generated by:
        - Swapping two surgeries in the schedule.
        - Shifting surgery start times.
        - Changing operating rooms.

        Args:
        surgeries (list): The current schedule, represented as a list of Surgery objects.
        room_assignments (list): Current room assignments as a list of SurgeryRoomAssignment objects.

        Returns:
        list: A list of neighboring schedules.
        """
        neighbors = []
        num_surgeries = len(surgeries)
        num_rooms = len(set(assignment.room_id for assignment in room_assignments))

        # Swapping surgeries
        for i in range(num_surgeries):
            for j in range(i + 1, num_surgeries):
                neighbor_surgeries = surgeries[:]
                neighbor_surgeries[i], neighbor_surgeries[j] = neighbor_surgeries[j], neighbor_surgeries[i]
                
                neighbor_assignments = room_assignments[:]
                neighbor_assignments[i], neighbor_assignments[j] = neighbor_assignments[j], neighbor_assignments[i]
                
                if self.is_valid_schedule(neighbor_surgeries, neighbor_assignments):
                    neighbors.append((neighbor_surgeries, neighbor_assignments))

        # Shifting surgery times
        for i, assignment in enumerate(room_assignments):
            for delta in [-30, 30]:  # Example: shifting times by +/- 30 minutes
                neighbor_assignments = room_assignments[:]
                new_start_time = shift_time(assignment.start_time, delta)
                new_end_time = shift_time(assignment.end_time, delta)
                
                if new_start_time and new_end_time and is_room_available(neighbor_assignments, assignment.room_id, new_start_time, new_end_time):
                    neighbor_assignments[i].start_time = new_start_time
                    neighbor_assignments[i].end_time = new_end_time
                    if self.is_valid_schedule(surgeries, neighbor_assignments):
                        neighbors.append((surgeries, neighbor_assignments))

        # Changing operating rooms
        for i in range(num_surgeries):
            neighbor_assignments = room_assignments[:]
            new_room = random.randint(1, num_rooms)
            if is_room_available(neighbor_assignments, new_room, neighbor_assignments[i].start_time, neighbor_assignments[i].end_time):
                neighbor_assignments[i].room_id = new_room
                if self.is_valid_schedule(surgeries, neighbor_assignments):
                    neighbors.append((surgeries, neighbor_assignments))

        return neighbors

    def is_valid_schedule(self, surgeries, room_assignments):
        """
        Check if the given schedule is valid by ensuring all surgeries can be assigned to their
        surgeons and rooms without conflicts.

        Args:
        surgeries (list): List of Surgery objects.
        room_assignments (list): List of SurgeryRoomAssignment objects corresponding to the surgeries.

        Returns:
        bool: True if the schedule is valid, False otherwise.
        """
        # Check for surgeon availability and surgery time conflicts
        for surgery in surgeries:
            surgeon = next((s for s in self.surgeons if s.staff_id == surgery.surgeon_id), None)
            if surgeon is None or not surgeon.is_available(surgery.scheduled_date):
                return False
            
            # Ensuring no two surgeries overlap in the surgeon's schedule
            for other_surgery in surgeries:
                if other_surgery.surgeon_id == surgery.surgeon_id and other_surgery != surgery:
                    if not (surgery.end_time <= other_surgery.start_time or surgery.start_time >= other_surgery.end_time):
                        return False

        # Check for operating room availability and avoid overlapping surgeries in the same room
        for assignment in room_assignments:
            room = next((r for r in self.operating_rooms if r.room_id == assignment.room_id), None)
            if room is None:
                return False
            
            for other_assignment in room_assignments:
                if other_assignment.room_id == assignment.room_id and other_assignment != assignment:
                    if not (assignment.end_time <= other_assignment.start_time or assignment.start_time >= other_assignment.end_time):
                        return False

        return True

    def evaluate_solution(self, surgeries, room_assignments):
        """
        Evaluate the given solution based on multiple criteria including patient urgency,
        operating room utilization, and equipment availability.
        
        Args:
        surgeries (list): List of Surgery objects.
        room_assignments (list): List of SurgeryRoomAssignment objects.
        
        Returns:
        int: A score representing the quality of the solution. Higher scores indicate better solutions.
        """
        # Maximize the number of surgeries scheduled
        num_surgeries_scheduled = len(surgeries)
        
        # Prioritize surgeries by urgency level (higher urgency gets more points)
        urgency_score = sum([s.urgency_level * 10 for s in surgeries])  # Assuming urgency_level is an integer
        
        # Minimize total surgery duration to reduce idle time
        total_duration = sum([s.duration for s in surgeries])
        
        # Evaluate operating room utilization
        room_utilization_score = self.calculate_room_utilization(room_assignments)
        
        # Check equipment availability
        equipment_availability_score = self.check_equipment_availability(surgeries)
        
        # Combine criteria into a single score
        score = (num_surgeries_scheduled * 1000 + urgency_score + room_utilization_score + equipment_availability_score) - total_duration
        
        return score


    def run(self):
        # The main method to run the Tabu Search optimization ...
        # This should include the initialization of the first solution, the main optimization loop,
        # the logic to manage the tabu list, and the logic to update the best solution
        pass

    def find_initial_solution(self):
        # Logic to find a starting solution that meets the basic constraints
        pass

    # Additional methods as needed ...

# Entry point to run the optimization if this script is run directly
if __name__ == "__main__":
    # Initialize data using the functions from initialize_data.py
    surgeries = initialize_surgeries()
    operating_rooms = initialize_operating_rooms()
    surgeons = initialize_surgeons()
    patients = initialize_patients()
    staff_members = initialize_staff_members()
    surgery_equipments = initialize_surgery_equipments()
    surgery_equipment_usages = initialize_surgery_equipment_usages()
    surgery_room_assignments = initialize_surgery_room_assignments()
    surgery_staff_assignments = initialize_surgery_staff_assignments()

    # Equipment inventory for check_equipment_availability (example structure)
    equipment_inventory = {eq.equipment_id: eq.availability for eq in surgery_equipments}

    # Instantiate the scheduler with the initialized data
    scheduler = TabuSearchScheduler(surgeries, surgery_room_assignments, surgeons)

    # Example: Calculate room utilization and equipment availability scores (for demonstration)
    room_utilization_score = scheduler.calculate_room_utilization(surgery_room_assignments, operating_rooms)
    equipment_availability_score = scheduler.check_equipment_availability(surgeries, equipment_inventory)

    print(f"Room Utilization Score: {room_utilization_score}")
    print(f"Equipment Availability Score: {equipment_availability_score}")

    scheduler.run()
