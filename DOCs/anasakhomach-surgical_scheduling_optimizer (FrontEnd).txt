Directory structure:
└── anasakhomach-surgical_scheduling_optimizer/
    ├── README.md
    ├── babel.config.js
    ├── deepseek_fix.txt
    ├── gemini_fix.txt
    ├── guide.txt
    ├── implimentation.txt
    ├── index.html
    ├── jest.config.js
    ├── package.json
    ├── vite.config.js
    ├── vitest.config.js
    ├── __mocks__/
    │   └── svgMock.js
    ├── public/
    ├── src/
    │   ├── App.vue
    │   ├── main.js
    │   ├── style.css
    │   ├── assets/
    │   ├── components/
    │   │   ├── AddEditInitialSetupModal.vue
    │   │   ├── AddEditSurgeryTypeModal.vue
    │   │   ├── AddEquipmentForm.vue
    │   │   ├── AddOrForm.vue
    │   │   ├── AddStaffForm.vue
    │   │   ├── AdministrationScreen.vue
    │   │   ├── AnalyticsDashboard.vue
    │   │   ├── AppLayout.vue
    │   │   ├── BulkSDSTEditor.vue
    │   │   ├── ConfirmationModal.vue
    │   │   ├── CustomReportBuilder.vue
    │   │   ├── DashboardScreen.vue
    │   │   ├── GanttAccessibleTable.vue
    │   │   ├── GanttChart.vue
    │   │   ├── HelloWorld.vue
    │   │   ├── HelpDocumentationScreen.vue
    │   │   ├── KeyboardShortcutsHelp.vue
    │   │   ├── LoginScreen.vue
    │   │   ├── MasterScheduleScreen.vue
    │   │   ├── MyProfileSettingsScreen.vue
    │   │   ├── NotFound.vue
    │   │   ├── NotificationsScreen.vue
    │   │   ├── PatientManagementScreen.vue
    │   │   ├── PendingSurgeriesList.vue
    │   │   ├── ReportingAnalyticsScreen.vue
    │   │   ├── ResourceAvailabilityCalendar.vue
    │   │   ├── ResourceManagementScreen.vue
    │   │   ├── SchedulingEfficiencyReports.vue
    │   │   ├── SchedulingScreen.vue
    │   │   ├── SDSTDataManagementScreen.vue
    │   │   ├── SDSTManagement.vue
    │   │   ├── SDSTManagementScreen.vue
    │   │   ├── SurgeryDetailsPanel.vue
    │   │   ├── SurgeryFormScreen.vue
    │   │   ├── SurgerySchedulingScreen.vue
    │   │   ├── ToastNotification.vue
    │   │   ├── UtilizationReports.vue
    │   │   ├── __snapshots__/
    │   │   │   ├── AddEditInitialSetupModal.test.js.snap
    │   │   │   ├── AddEditSurgeryTypeModal.test.js.snap
    │   │   │   ├── AddEquipmentForm.test.js.snap
    │   │   │   ├── AddOrForm.test.js.snap
    │   │   │   └── ConfirmationModal.test.js.snap
    │   │   └── __tests__/
    │   │       ├── AddEditInitialSetupModal.test.js
    │   │       ├── AddEditSurgeryTypeModal.test.js
    │   │       ├── AddEquipmentForm.test.js
    │   │       ├── AddOrForm.test.js
    │   │       ├── AddStaffForm.test.js
    │   │       ├── AdministrationScreen.test.js
    │   │       ├── AnalyticsDashboard.test.js
    │   │       ├── AppLayout.test.js
    │   │       ├── BulkSDSTEditor.test.js
    │   │       ├── ConfirmationModal.test.js
    │   │       ├── CustomReportBuilder.test.js
    │   │       ├── DashboardScreen.test.js
    │   │       ├── GanttAccessibleTable.test.js
    │   │       ├── GanttChart.test.js
    │   │       ├── HelloWorld.test.js
    │   │       ├── HelpDocumentationScreen.test.js
    │   │       ├── KeyboardShortcutsHelp.test.js
    │   │       ├── LoginScreen.spec.js
    │   │       ├── ResourceManagementScreen.test.js
    │   │       ├── SchedulingScreen.spec.js
    │   │       ├── SchedulingScreen.test.js
    │   │       ├── SchedulingScreenBasic.test.js
    │   │       ├── ToastNotification.test.js
    │   │       └── __snapshots__/
    │   │           ├── AddEditInitialSetupModal.test.js.snap
    │   │           ├── AddEditSurgeryTypeModal.test.js.snap
    │   │           ├── AddEquipmentForm.test.js.snap
    │   │           ├── AddOrForm.test.js.snap
    │   │           ├── AddStaffForm.test.js.snap
    │   │           ├── AdministrationScreen.test.js.snap
    │   │           ├── AppLayout.test.js.snap
    │   │           └── ConfirmationModal.test.js.snap
    │   ├── router/
    │   │   └── index.js
    │   ├── services/
    │   │   └── keyboardShortcuts.js
    │   └── stores/
    │       ├── analyticsStore.js
    │       ├── authStore.js
    │       ├── notificationStore.js
    │       ├── resourceStore.js
    │       └── scheduleStore.js
    └── .idx/
        └── dev.nix

================================================
FILE: README.md
================================================
# Vue 3 + Vite




================================================
FILE: babel.config.js
================================================
module.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }],
    '@babel/preset-typescript',
  ],
};


================================================
FILE: deepseek_fix.txt
================================================
The test failures are primarily due to incorrect CSS selectors in the test code and insufficient waiting for DOM updates. Here's how to fix them:

**1. Incorrect Section Selectors:**
- **Problem:** Tests use `.resource-section:nth-of-type(2/3)` which doesn't exist since only one section is rendered at a time.
- **Fix:** Use `.resource-section:nth-of-type(1)` for all tabs when active.

**2. Staff/Equipment Tab Tests:**
```javascript
// Staff tab tests
describe('Staff tab', () => {
  beforeEach(async () => {
    await wrapper.findAll('.tabs button')[1].trigger('click');
    await wrapper.vm.$nextTick();
    await flushPromises();

    // Correct selector to nth-of-type(1)
    const rowCount = await waitForTableContent(
      wrapper,
      '.resource-section:nth-of-type(1)',
      resourceStore.staff.length
    );
    // ... rest unchanged
  });

  it('displays the Staff table with correct columns', () => {
    // Correct selector
    const staffSection = wrapper.find('.resource-section:nth-of-type(1)');
    // ... rest unchanged
  });
});

// Equipment tab tests
describe('Equipment tab', () => {
  beforeEach(async () => {
    await wrapper.findAll('.tabs button')[2].trigger('click');
    await wrapper.vm.$nextTick();
    await flushPromises();

    // Correct selector
    const rowCount = await waitForTableContent(
      wrapper,
      '.resource-section:nth-of-type(1)',
      resourceStore.equipment.length
    );
    // ... rest unchanged
  });

  it('displays the Equipment table with correct columns', () => {
    // Correct selector
    const equipmentSection = wrapper.find('.resource-section:nth-of-type(1)');
    // ... rest unchanged
  });
});
```

**3. Tab Switching Tests:**
```javascript
it('switches to Staff tab when clicked', async () => {
  await wrapper.findAll('.tabs button')[1].trigger('click');
  await wrapper.vm.$nextTick();
  await flushPromises();

  expect(wrapper.find('.tabs button.active').text()).toBe('Staff');
  // Correct selector
  const staffSection = wrapper.find('.resource-section:nth-of-type(1)');
  expect(staffSection.find('h2').text()).toBe('Staff List');
});

it('switches to Equipment tab when clicked', async () => {
  await wrapper.findAll('.tabs button')[2].trigger('click');
  await wrapper.vm.$nextTick();
  await flushPromises();

  expect(wrapper.find('.tabs button.active').text()).toBe('Equipment');
  // Correct selector
  const equipmentSection = wrapper.find('.resource-section:nth-of-type(1)');
  expect(equipmentSection.find('h2').text()).toBe('Equipment List');
});
```

**4. Deletion Confirmation Tests:**
Update selectors in deletion tests to use `.resource-section:nth-of-type(1)` when checking tables.

**5. Form Visibility Test:**
Ensure the correct section is checked after form toggle:
```javascript
it('hides the OR table when the form is shown', async () => {
  const orSection = wrapper.find('.resource-section:nth-of-type(1)');
  await orSection.find('button.button-primary').trigger('click');
  expect(orSection.find('table').exists()).toBe(false); // Should now work
});
```

**6. Increase Timeout for Slow Renders:**
In `waitForTableContent`, consider increasing the timeout for Staff/Equipment tabs if needed.

**Why These Fixes Work:**
- The component uses `v-if` for sections, rendering only one `.resource-section` at a time. Using `nth-of-type(1)` correctly targets the active section.
- Proper waiting ensures Vue updates the DOM and renders tables after state changes.

After applying these changes, the tests should correctly find the rendered tables and forms, resolving the majority of the failures.


================================================
FILE: gemini_fix.txt
================================================
Okay, this is a common scenario with testing complex components involving asynchronous operations, conditional rendering (v-if), and state management (Pinia). Let's break down the failures and how to address them.

**Key Observations from the Test Output:**

1.  **`Failed to render Staff table. Expected 8 rows, got 0` (and similar for Equipment):** This is a major clue. Your `waitForTableContent` helper is correctly identifying that the data isn't appearing in the DOM for the Staff and Equipment tabs, even though your `INITIAL_STATE` clearly provides this data.
2.  **`Cannot call find on an empty DOMWrapper`:** This typically means the element you're trying to `find` (e.g., `staffSection` or `equipmentSection`) doesn't exist at that moment in the test.
3.  **`expected false to be true // Object.is equality` (when checking `section.exists()`):** This is related to point 2. The test expects a section (like Staff or Equipment) to exist, but it doesn't.
4.  **`expected true to be false // Object.is equality` (e.g., "hides the OR table", "adds a new OR"):** These indicate that a state change (like hiding a table or a form) didn't happen as expected.
5.  **The `nth-of-type` Selector Issue:** Your component uses `v-if` to render *only one* resource section at a time:
    ```html
    <div v-if="activeTab === 'ors'" class="resource-section">...</div>
    <div v-if="activeTab === 'staff'" class="resource-section">...</div>
    <div v-if="activeTab === 'equipment'" class="resource-section">...</div>
    ```
    This means that whichever tab is active, its corresponding `div.resource-section` will be the *first and only* `div.resource-section` within its parent (`.tab-content`). Therefore, selectors like `.resource-section:nth-of-type(2)` or `:nth-of-type(3)` will **never** find anything. The active section will always be matched by `.resource-section:nth-of-type(1)` (or simply `.resource-section` if you're sure there's only one). This is the root cause of many of your failures.

**Let's Address the Failures Systematically:**

**Category 1: Failures due to incorrect `nth-of-type` selectors (Affects Staff & Equipment tabs primarily)**

* **Tests:**
    * `switches to Staff tab when clicked`
    * `switches to Equipment tab when clicked`
    * `Staff tab > displays the Staff table with correct columns`
    * `Staff tab > displays the initial staff data correctly`
    * `Staff tab > shows the Add Staff form when Add New Staff button is clicked`
    * `Equipment tab > displays the Equipment table with correct columns`
    * `Equipment tab > displays the initial equipment data correctly`
    * `Equipment tab > shows the Add Equipment form when Add New Equipment button is clicked`
    * `Deletion confirmation > Staff deletion confirmation > should show confirmation modal...` (the `waitForTableContent` in its `beforeEach` fails)
    * `Deletion confirmation > Equipment deletion confirmation > should show confirmation modal...` (the `waitForTableContent` in its `beforeEach` fails)

* **Reason:** When the Staff tab is active, `wrapper.find('.resource-section:nth-of-type(2)')` finds nothing because the Staff section is effectively the *first* `.resource-section` present in the DOM. Same for Equipment with `nth-of-type(3)`.

* **Solution:**
    1.  **Change Selectors:** For Staff and Equipment tests, when you try to find their respective sections, use a selector that correctly identifies them. Since only one section is rendered at a time, `.resource-section` (or `.resource-section:nth-of-type(1)`) would target the currently active section.
        To be more robust and clear, it's better to select based on content if possible or add `data-testid` attributes. For instance, after clicking the Staff tab:
        ```javascript
        // Option A: Generic (if only one .resource-section is ever visible)
        const staffSection = wrapper.find('.resource-section');
        // Option B: More specific (recommended)
        // Add data-testid="staff-section" to your staff div in the component template
        // const staffSection = wrapper.find('[data-testid="staff-section"]');
        // Option C: Based on unique content within the section
        const staffSection = wrapper.find('.resource-section:has(h2:contains("Staff List"))');
        ```
    2.  Apply this corrected selector logic to all tests and `beforeEach` blocks related to the Staff and Equipment tabs.

    **Example fix for `waitForTableContent` in Staff/Equipment `beforeEach` blocks:**
    ```javascript
    // In Staff tab's beforeEach
    const staffSectionSelector = '.resource-section:has(h2:contains("Staff List"))'; // Or simply '.resource-section'
    const rowCount = await waitForTableContent(
        wrapper,
        staffSectionSelector,
        resourceStore.staff.length
    );
    if (rowCount < resourceStore.staff.length) {
        console.error(`Failed to render Staff table. Expected ${resourceStore.staff.length} rows, got ${rowCount}. HTML of section: ${wrapper.find(staffSectionSelector).exists() ? wrapper.find(staffSectionSelector).html() : 'Section not found'}`);
    }

    // In Equipment tab's beforeEach
    const equipmentSectionSelector = '.resource-section:has(h2:contains("Equipment List"))'; // Or simply '.resource-section'
    const rowCountEq = await waitForTableContent(
        wrapper,
        equipmentSectionSelector,
        resourceStore.equipment.length
    );
    if (rowCountEq < resourceStore.equipment.length) {
        console.error(`Failed to render Equipment table. Expected ${resourceStore.equipment.length} rows, got ${rowCountEq}. HTML of section: ${wrapper.find(equipmentSectionSelector).exists() ? wrapper.find(equipmentSectionSelector).html() : 'Section not found'}`);
    }
    ```
    And in the tests themselves:
    ```javascript
    // Staff tab tests
    it('displays the Staff table with correct columns', async () => {
        // await ... (tab switch and waits from beforeEach)
        const staffSection = wrapper.find('.resource-section:has(h2:contains("Staff List"))'); // Corrected selector
        expect(staffSection.exists()).toBe(true);
        // ... rest of the assertions
    });
    ```

**Category 2: Logic Error in Component or Test Assertion**

* **Test:** `Operating Rooms tab > hides the OR table when the form is shown`
    * `AssertionError: expected true to be false // Object.is equality`
    * `expect(orSection.find('table').exists()).toBe(false);` (Line 201)

* **Reason:** Your component template for the OR section looks like this:
    ```html
    <AddOrForm v-if="showAddOrForm" ... />
    <div v-if="isLoading" class="loading-indicator"> ... </div>
    <table v-else> ... </table>
    ```
    When `showAddOrForm` is `true`, the `AddOrForm` is displayed. However, the table's visibility is controlled by `isLoading`. If `isLoading` is `false` (which it would be after initial load), the table will *always* be shown by the `v-else`, regardless of `showAddOrForm`'s value. The test expects the table to be hidden, but the component logic doesn't do that.

* **Solution (Component Change):** Modify the component to hide the table when the form is shown.
    ```html
    <div v-if="activeTab === 'ors'" class="resource-section">
      <h2>Operating Rooms List</h2>
      <button class="button-primary" @click="openOrFormForAdd" v-if="!showAddOrForm && !isLoading">Add New OR</button> <AddOrForm
        v-if="showAddOrForm"
        :or-to-edit="currentOrToEdit"
        @cancel="handleCancelOrForm"
        @save="handleSaveOr"
      />
      <div v-if="isLoading" class="loading-indicator">
        </div>
      <table v-else-if="!showAddOrForm">
        <thead>
          </thead>
        <tbody>
          </tbody>
      </table>
      <div v-else-if="showAddOrForm" class="form-is-active-placeholder">
        </div>
    </div>
    ```
    This change will make `orSection.find('table').exists()` be `false` when `showAddOrForm` is `true` and `isLoading` is `false`.

* **Test:** `Form submissions > adds a new OR when form is submitted`
    * `AssertionError: expected true to be false // Object.is equality`
    * `expect(fullWrapper.findComponent(AddOrForm).exists()).toBe(false);` (Line 348)

* **Reason:** The test expects the `AddOrForm` to disappear after saving. The component logic is `showAddOrForm.value = false;` inside `handleSaveOr`. This should work.
    Possible issues:
    1.  The `save` event from `AddOrForm` isn't being handled correctly, or `handleSaveOr` has an early exit/error.
    2.  The `addOperatingRoom` Pinia action might be failing or not resolving in a way that allows `showAddOrForm.value = false` to execute or be reactive in time. Since `stubActions: false` is used for `localPinia`, the actual store action is called.
    3.  Reactivity timing.

* **Solution:**
    1.  Ensure your `resourceStore.addOperatingRoom` action actually updates the `operatingRooms` array in the store state reactively and returns a success object as expected by `handleSaveOr`.
    2.  Add more debug logging inside `handleSaveOr` in your component to see if it reaches `showAddOrForm.value = false;`.
    3.  The sequence `await flushPromises(); await fullWrapper.vm.$nextTick();` after emitting save is generally correct.
    4.  This might also benefit from the selector fixes if any part of this test was inadvertently relying on `nth-of-type` for sections. However, this specific assertion is about the form component itself.

* **Test:** `Deletion confirmation > should show confirmation modal on deleting an OR`
    * `AssertionError: expected false to be true // Object.is equality`
    * `expect(orSection.find('table').exists()).toBe(true);` (Line 387)
    * This assertion fails *before* the delete button is clicked. It means the OR table isn't even found at the beginning of this specific test.

* **Reason:** This `describe` block for "Deletion confirmation" creates a new `orWrapper` and `localPiniaInstance`. The `beforeEach` for the top-level `ResourceManagementScreen` describe block (which has `waitForTableContent` for ORs) does *not* run for this isolated `orWrapper`. You need to ensure the OR table is rendered in this test's context too.
    The test code does `await flushPromises(); await orWrapper.vm.$nextTick();` which should allow `onMounted` and `loadResources` to run. The `INITIAL_STATE` provides OR data.

* **Solution:** Add a `waitForTableContent` call specific to this `orWrapper` instance before proceeding with the assertions, similar to how it's done in the main `beforeEach`.
    ```javascript
    describe('Deletion confirmation', () => {
      it('should show confirmation modal on deleting an OR', async () => {
        // ... (pinia and wrapper setup) ...

        await flushPromises();
        await orWrapper.vm.$nextTick();

        // ADD THIS: Wait for the OR table in this specific test context
        const orStore = useResourceStore(localPiniaInstance); // Get store for this instance
        const orRowCount = await waitForTableContent(
          orWrapper,
          '.resource-section:nth-of-type(1)', // OR section is indeed nth-of-type(1)
          orStore.operatingRooms.length,
          3000 // timeout
        );
        if (orRowCount < orStore.operatingRooms.length) {
            console.error(`OR Deletion Test: Failed to render OR table. Expected ${orStore.operatingRooms.length}, got ${orRowCount}`);
        }

        const orSection = orWrapper.find('.resource-section:nth-of-type(1)');
        expect(orSection.find('table').exists()).toBe(true); // Should pass now

        // ... rest of the test
      });
    // ...
    });
    ```

**General Advice for Asynchronous Tests in Vue Test Utils:**

1.  **`await flushPromises()`:** Use after any action that might trigger asynchronous updates that are promise-based (like Pinia actions if they are async).
2.  **`await wrapper.vm.$nextTick()`:** Use after an action that changes reactive data to ensure Vue has completed its DOM update cycle.
3.  **`waitForX` helpers:** Your `waitForTableContent` is good. Sometimes you might need to wait for an element to appear/disappear more generally. Vue Test Utils doesn't have a built-in `waitFor` like Testing Library, so custom helpers or repeated checks with timeouts (like your `waitForTableContent`) are necessary.
4.  **Debugging with `wrapper.html()`:** When a `find` fails or an element isn't as expected, log `wrapper.html()` or `section.html()` to see the actual DOM structure the test is working with. Your `console.error` lines in `waitForTableContent` are a good start.
5.  **Pinia Store State:** In failing tests, you can also log `resourceStore.$state` to check if the Pinia store has the data you expect at that point in the test.

**Summary of Key Actions:**

1.  **Critical Fix:** Change all `.resource-section:nth-of-type(2)` and `.resource-section:nth-of-type(3)` selectors. Use `.resource-section` (if you are sure only one is active) or a more specific selector like `.resource-section:has(h2:contains("Staff List"))` or `[data-testid="unique-section-id"]`. This will resolve the bulk of the Staff and Equipment tab failures.
2.  **Component Logic Fix:** Modify the OR section in `ResourceManagementScreen.vue` so the table is hidden when `showAddOrForm` is true (and not loading).
3.  **Test Setup for Deletion:** Ensure the OR table is explicitly waited for in the "Deletion confirmation" test for ORs, as it uses a separate wrapper instance.
4.  **Review Form Submission:** If the "adds a new OR" test still fails after other fixes, investigate the `addOperatingRoom` Pinia action and the reactivity chain that should hide the form.

Start with the selector changes (Point 1), as this is the most impactful and widespread issue. Then move to the component logic for hiding the OR table. Good luck!


================================================
FILE: guide.txt
================================================
Expert Analysis and Recommendations for Surgery Scheduling System App UI/UX Design Vision
This report provides a detailed analysis and actionable recommendations for the UI/UX Design Vision document for the Surgery Scheduling System App. The analysis focuses on technical feasibility, UI/UX enhancements, accessibility, EHR integration, and a phased development approach.

1. Technical Feasibility & Implementation Considerations
The UI/UX elements described in the Design Vision document are generally technically feasible, though some present significant challenges that require careful planning and execution.

Gantt Chart with Dynamic SDST Visualization:

Feasibility: Implementing a dynamic Gantt chart that visualizes Sequence-Dependent Setup Times (SDST) is feasible but complex. Real-time updates based on preceding surgeries and resource availability require robust front-end and back-end logic.




Potential Challenges:
Performance: Rendering and dynamically updating a large Gantt chart with many surgeries and SDST calculations can be resource-intensive, potentially leading to UI lag.
Complexity of SDST Calculation: Accurately calculating and visually representing SDST based on numerous variables (surgery types, OR specifics, initial setup times) in real-time is a significant engineering challenge.




User Interaction: Ensuring intuitive drag-and-drop functionality with real-time feedback on SDST and conflicts requires sophisticated event handling and state management.



Practical Solutions/Alternatives:
Virtualization/Windowing: For large datasets, implement virtualization in the Gantt chart to render only the visible portion, significantly improving performance.
Debouncing/Throttling: Optimize real-time calculations and UI updates by debouncing or throttling frequent events (e.g., during drag operations).
Server-Side Assistance: Offload complex SDST calculations to the server, especially for initial rendering or when major schedule changes occur, while handling more localized, simpler updates on the client.
Simplified Initial View: Offer a less granular initial view (e.g., daily instead of hourly) with options to drill down, reducing the initial rendering load.
Real-Time Conflict Detection:

Feasibility: Real-time conflict detection for resources (ORs, staff, equipment) and SDST violations is achievable. This relies on a well-structured database and efficient algorithms for checking availability and constraints.




Potential Challenges:
Data Consistency: Ensuring that all users see a consistent and up-to-date view of resource availability and conflicts, especially with concurrent users, is crucial.
Complexity of Rules: The conflict detection logic can become very complex when considering multiple resource types, staff specializations, availability windows, and SDST rules.
Performance: Frequent real-time checks across numerous potential conflicts can strain system resources if not optimized.
Practical Solutions/Alternatives:
Optimized Backend Logic: Design efficient database queries and algorithms on the server-side to handle conflict checking.
WebSockets/Real-time Communication: Utilize WebSockets or similar technologies for pushing real-time updates and conflict notifications from the server to connected clients.
Client-Side Pre-validation: Implement basic client-side validation to catch obvious conflicts early, reducing server load, but always rely on server-side validation as the source of truth.
EHR Integration Points:

Feasibility: Integrating with EHR systems for patient data retrieval (and potentially write-back) is feasible but highly dependent on the EHR's API capabilities and adherence to standards like HL7 FHIR. The document primarily focuses on read-only data retrieval which is a more common and less complex starting point.



Potential Challenges:
API Variability: EHR systems have varying API maturity, standards compliance, and data accessibility.
Data Mapping: Mapping data fields between the scheduling app and the EHR can be complex and require careful analysis.
Security and Privacy: Ensuring HIPAA compliance (or equivalent regulations) and secure data exchange is paramount.
Performance and Reliability: EHR API response times and uptime can impact the scheduling app's performance and user experience.
Practical Solutions/Alternatives:
Standardized APIs: Prioritize integration using modern, standardized APIs like HL7 FHIR.
Middleware/Integration Engine: Consider using a healthcare-focused integration engine to manage the complexities of EHR connectivity, data transformation, and message routing.
Asynchronous Operations: For non-critical EHR interactions, use asynchronous operations to prevent UI blocking.
Graceful Degradation: Design the system to function adequately even if the EHR connection is temporarily unavailable, clearly indicating the status to the user.
Recommended Front-End Technologies & UI Libraries:

Framework: React or Angular are well-suited due to their robust ecosystems, component-based architecture, and strong community support, which are beneficial for complex enterprise applications.
React: Offers flexibility and a vast selection of third-party libraries. Its virtual DOM is excellent for performance-critical dynamic UIs like the Gantt chart. State management libraries like Redux or Zustand would be essential.
Angular: Provides a more opinionated and comprehensive framework, which can lead to more consistent development practices in larger teams. Its built-in features for dependency injection, routing, and forms are advantageous.
UI Libraries:
Material UI (for React) or Angular Material: Offer a rich set of pre-built, accessible components that align with a modern and professional aesthetic. They handle many common UI patterns and can accelerate development.

Ant Design: Another excellent choice, providing a comprehensive suite of enterprise-grade UI components with a focus on data display and forms.
Specialized Gantt Chart Libraries: Instead of building from scratch, consider integrating a mature, feature-rich Gantt chart library. Examples include:
Bryntum Gantt: Highly performant and feature-rich, designed for complex scheduling applications.
DHTMLX Gantt: A widely used and robust library with extensive customization options.
Visavail.js, Frappe Gantt, or Google Charts (Gantt): Lighter-weight options if requirements are simpler, though the described dynamic SDST visualization likely points towards a more powerful library.
Justification: These choices offer a good balance of development efficiency, performance, maintainability, and access to a large talent pool. The component-based nature directly supports the modular design outlined in the document. The complexity of the Gantt chart and real-time updates makes a mature framework and potentially a specialized library a practical necessity.
Architectural Considerations for Real-Time Data:

Performance:
Efficient Backend Services: Design scalable backend services (e.g., microservices) to handle specific tasks like SDST calculation, conflict detection, and optimization.
Database Optimization: Use appropriate database indexing and optimized queries for fast data retrieval and updates. Consider read replicas for reporting if necessary.
Caching: Implement caching strategies at various levels (CDN, application server, database query cache) to reduce latency for frequently accessed data.
Scalability:
Horizontal Scaling: Design both front-end and back-end systems to be horizontally scalable to handle increasing numbers of users and data.
Load Balancing: Use load balancers to distribute traffic across multiple instances of application servers and databases.
Message Queues: For asynchronous tasks like triggering notifications or initiating background optimization runs, use message queues (e.g., RabbitMQ, Kafka) to decouple services and improve resilience.
Data Consistency:
Optimistic Locking/ETags: For concurrent data modifications, implement mechanisms like optimistic locking or ETags to prevent lost updates.
Transactional Integrity: Ensure that operations involving multiple data changes (e.g., scheduling a surgery and allocating resources) are handled transactionally to maintain data consistency.
Single Source of Truth: Clearly define the source of truth for all data elements, especially when integrating with EHRs.
Real-time Updates: Use WebSockets or Server-Sent Events (SSE) to push real-time updates from the server to all connected clients, ensuring everyone sees the latest schedule and conflict information. This is crucial for the dynamic Gantt chart and alert systems.



2. UI/UX Enhancement Suggestions
While the Design Vision document is comprehensive, several areas could be enhanced:

Improving Usability, Accessibility, and Overall User Experience:

Contextual Help & Guided Tours: For complex features like SDST management or the optimization engine, provide contextual help icons (tooltips, popovers) and optional guided tours for new users or infrequent tasks. This aligns with the "Clarity and Intuitiveness" principle.

Keyboard Navigation & Shortcuts: Beyond basic WCAG compliance, implement extensive keyboard shortcuts for power users (especially Schedulers) to accelerate common tasks on the Gantt chart and forms.
Undo/Redo Functionality: For the main scheduling screen, a robust multi-level undo/redo capability is crucial, as mentioned for "what-if" scenarios. This significantly reduces user anxiety when making complex changes.
Personalization/Customization: Allow users to customize aspects of their dashboard or default views (e.g., default date ranges, visible columns in tables) to better suit their individual workflows, while staying within role-based constraints.
Concrete Examples for Improvement:

Gantt Chart Interaction:
Directly Editing SDST (if permissible): If rules allow for manual overrides of SDST in exceptional cases (with audit trails), consider allowing this directly on the Gantt (e.g., right-click context menu on the SDST block), rather than only through the SDST Data Management screen. This would require strict permission controls.
Visualizing Resource Load: Beyond just availability, provide a visual indication of overall resource load (e.g., a staff member's total scheduled hours for the day/week) directly within the resource selection components to aid in balanced assignments.
Information Presentation:
Minimizing Modal Overuse: While modals are necessary for critical alerts, try to use inline expansion or side panels for editing or viewing details where possible to maintain context (e.g., for surgery details from the Gantt chart).
Clearer "No Data" States: For empty lists, reports, or dashboard widgets, provide informative "no data" messages with potential calls to action (e.g., "No pending surgeries. Would you like to schedule a new one?").
SDST Matrix Input: For the SDST matrix, consider a "bulk edit" or "copy row/column" feature if many transitions share similar setup times. Color-coding cells by duration is a good suggestion; ensure these colors meet contrast requirements and are supplemented by textual information for accessibility.




Usability Issues with SDST Management & Mitigation:

Cognitive Load of SDST Matrix: The matrix for defining SDST between all pairs of surgery types can become very large and difficult to manage. 



Mitigation:
Implement robust search and filtering within the matrix management screen.
Allow grouping of surgery types (e.g., by specialty) to simplify matrix views or apply default SDSTs for entire groups with exceptions.
The "Impact Analysis" or "Simulation" feature before committing changes to SDST rules is an excellent mitigation strategy.


Understanding SDST Impact: Users might struggle to intuitively grasp how changing one SDST value impacts the overall schedule feasibility and optimization outcomes. 

Mitigation:
The dedicated SDST information panel when scheduling is crucial. Make this information highly prominent and easy to understand.

The "ripple effect" visualization is a good advanced consideration.
Provide training materials and tooltips explaining the logic and importance of SDST.
Role-Based Dashboard Design Improvements:

The current design for role-based dashboards is a good starting point.




Scheduler/OR Manager Dashboard:
Actionable KPIs: Ensure KPIs are not just informational but link directly to relevant sections or actions. For example, clicking on "High SDST Conflict Rate" could navigate to a report detailing these conflicts.
Prioritized Task List: Beyond "Pending Surgeries," consider a more general "Tasks Requiring Attention" widget (e.g., unresolved resource conflicts, unconfirmed emergency placements).
Surgeon Dashboard:
Direct EHR Link per Patient: The link to the patient's EHR record from "My Upcoming Surgeries" is good. Ensure this is easily accessible.
Simplified Availability Management: Make managing availability/block-offs extremely intuitive, possibly with drag-and-select on a mini-calendar directly on the dashboard.
Nurse/Medical Staff Dashboard:
Clear Task Prioritization: If tasks are included, ensure they are clearly prioritized and status updates are straightforward.
Team Communication: The "Team Communication Snippet"  could be enhanced with acknowledgment features if critical messages are posted.
System Administrator Dashboard:
Actionable Alerts: System health indicators should link to more detailed logs or configuration pages for troubleshooting.
Proactive Alerts: Configure alerts for potential issues (e.g., low disk space, high error rate in EHR integration) before they become critical.
3. Accessibility Compliance (WCAG 2.1 AA)
The document shows a strong commitment to WCAG 2.1 AA, which is commendable.

Analysis of Accessibility Section & Potential Gaps/Strengthening Areas:

Comprehensive Coverage: The document correctly identifies key WCAG principles (Perceivable, Operable, Understandable, Robust) and many relevant success criteria. The inclusion of a table mapping UI components to WCAG criteria is excellent.




Gantt Chart and SDST Matrix: These are correctly identified as complex components requiring special attention. 
Strengthening Strategy:
Alternative Views: The suggestion of a "parallel, accessible tabular representation" for the Gantt chart is crucial and should be a firm requirement, not just a consideration. This view must contain all information and functionality available in the graphical view.

Keyboard Navigation for Complex Interactions: Define very specific keyboard interaction patterns for navigating and manipulating the Gantt chart (e.g., moving between ORs, time slots, surgeries; expanding/collapsing details; initiating drag-and-drop via keyboard). This needs to be more detailed than general "keyboard operable."
Live Regions for Dynamic Updates: For real-time conflict alerts and SDST updates on the Gantt chart, ensure ARIA live regions (aria-live, aria-atomic, aria-relevant) are used effectively to announce these changes to screen reader users without them losing focus.
SDST Matrix Accessibility:
Ensure that when editing a cell in the matrix, the context (preceding surgery type, succeeding surgery type) is clearly announced along with the current value. ARIA role="grid" with appropriate aria-labelledby for rows/columns would be essential.


Role-Specific Testing: The idea of user testing with individuals with disabilities representing different user roles is excellent and should be prioritized.
Specific ARIA Attributes and Techniques:

Gantt Chart:
role="application" might be appropriate for the main scheduling area if it behaves more like a desktop application than a document. Use with caution and ensure robust keyboard navigation.
role="treegrid" could be suitable if ORs can be expanded/collapsed to show surgeries.
Surgery blocks: role="gridcell" (if within a grid) or a custom widget role with appropriate ARIA properties. Each block should have aria-labelledby and aria-describedby referencing elements that provide full details (patient, type, time, SDST, conflicts). aria-grabbed and aria-dropeffect for drag-and-drop.
SDST segments: Ensure they are part of the surgery block's accessible description or are focusable elements themselves with a clear label (e.g., "Setup time for [Surgery X]: [Duration]").
SDST Matrix:
role="grid" for the table.
role="rowheader" and role="columnheader" for headers, with scope="row" and scope="col".
Editable cells: role="gridcell", aria-readonly="false". Ensure the input field within the cell is properly labeled or described by the row/column headers.
Dynamic Alerts/Feedback:
aria-live="assertive" for critical error messages and conflict alerts that need immediate attention.
aria-live="polite" for less critical updates (e.g., successful save confirmation toasts).
role="status" or role="alert" for specific message containers.
Resource Calendars: Similar to Gantt charts, ensure role="grid" or role="application" with focusable date cells that announce their status (available, booked, type of block-out) and any scheduled items.




Modal Dialogs: Use role="dialog", aria-modal="true", aria-labelledby (for the title), and aria-describedby (for content). Ensure focus is trapped within the modal and returned to the trigger element on close.

4. EHR Integration Best Practices
The document outlines a good approach to EHR integration, focusing on read-only initially.


Data Security, Privacy, and Consistency:

Principle of Least Privilege: Ensure the scheduling app only requests the minimum necessary data fields from the EHR for scheduling purposes (as described in 8.1.2 ). RBAC is crucial here.

Secure API Endpoints: Use HTTPS for all EHR communications. Implement robust authentication and authorization for API access (e.g., OAuth 2.0).
Data Encryption: Encrypt sensitive data both in transit and at rest (if any temporary caching is unavoidable, as mentioned in 8.3 ).
Audit Logging: Comprehensive audit trails for all EHR data access and exchange are essential (as stated in FR-AUDIT-001 and 8.3 ).


Data Minimization and No Persistent Duplication: Reiterate the strategy of not storing extensive clinical details locally. The EHR is the source of truth.


Data Consistency:
Timestamping: Clearly indicate the "freshness" of displayed EHR data (when it was last retrieved/updated), as suggested in 8.3.
Read-Only Display: Ensure EHR-retrieved data is clearly marked as read-only within the UI to prevent users from attempting to edit it within the scheduling app.

Patient Matching: Implement robust patient matching logic to ensure data is associated with the correct patient, especially when searching the EHR. Using unique identifiers like MRN is key.
Handling Integration Errors or Downtime:

Clear User Feedback: If the EHR connection is down or an API request fails, provide clear, non-alarming notifications to the user. Avoid technical jargon.
Example: "Unable to connect to the EHR system at this time. Patient details may not be up-to-date. Please try again later or proceed with manual data entry if urgent."
Graceful Degradation:
The system should remain functional for core scheduling tasks even if EHR integration is unavailable. This might mean allowing manual entry of essential patient details (with clear indication that this data is not EHR-verified). The Emergency Case Management screen already considers manual entry if EHR is slow/down.
Cache essential, non-sensitive identifiers if permissible by policy and technically feasible, to allow some level of patient identification during downtime.
Retry Mechanisms: Implement intelligent retry mechanisms for transient API errors, with exponential backoff.
Monitoring and Alerting: Proactively monitor the health of the EHR integration and alert administrators to issues.
Manual Fallbacks: Have defined manual workflows for situations where EHR data is critical but unavailable for an extended period.
Write-Back Error Handling (if implemented): For write-back scenarios, if an update to the EHR fails, clearly inform the user, log the error, and provide guidance on next steps (e.g., retry later, manually inform relevant parties). Do not leave the data in an inconsistent state between systems.
5. Prioritization and Iteration
A phased approach is essential for a project of this scope and complexity.

Phased Approach to Development (Prioritization):

Phase 1: Core Scheduling Functionality & SDST Foundation
User Roles: Scheduler/OR Manager, System Administrator (for initial setup).
Features:
User authentication and role management.

Basic Resource Management (ORs, core staff roles).


SDST Data Management: Defining Surgery Types, Initial Setup Times, and the core SDST Matrix.




Basic Surgery Creation/Editing/Cancellation (manual placement) without full optimization.


Gantt Chart MVP: Displaying scheduled surgeries with manual calculation and visualization of SDST (based on data from SDST Matrix). Basic conflict highlighting for double booking (no complex resource or SDST conflict engine yet).
Basic EHR Integration: Patient lookup and display of demographic data.

Rationale: Establish the foundational data structures and core scheduling interactions. Get early feedback on SDST data input and basic scheduling.
Phase 2: Dynamic SDST, Conflict Detection & Enhanced Scheduler Tools
Features:
Full dynamic SDST calculation and visualization on the Gantt chart during drag-and-drop and editing.




Real-time resource conflict detection (ORs, staff, equipment).


Real-time SDST violation alerts.


Pending Surgeries List and drag-and-drop to schedule.


Enhanced Resource Management: Staff specializations, availability calendars.


Scheduler Dashboard MVP.



Rationale: Deliver the core value proposition for schedulers by automating SDST calculations and conflict detection.
Phase 3: Optimization Engine & Other User Roles
User Roles: Surgeons, Nurses/Medical Staff.
Features:
Optimization Engine: Initial version for suggesting optimized schedules.

Surgeon Dashboard and availability management.


Nurse/Medical Staff Dashboard.

Notifications system.




Emergency Case Entry & Management.




Rationale: Introduce automation and expand functionality to other key user groups.
Phase 4: Reporting, Advanced Features & Refinements
Features:
Reporting & Analytics module.




Advanced SDST features (e.g., OR-specific SDST, SDST impact analysis simulation ).



Audit Trail Viewer.



Help/Documentation.
Full WCAG 2.1 AA compliance pass and refinement based on testing.
Potential EHR write-back capabilities (low priority).
Rationale: Provide insights, administrative tools, and round out the application with supporting features.
Strategies for Gathering User Feedback and Iterating:

Early and Frequent User Involvement:
Prototype Testing: Create interactive prototypes (e.g., using Figma, Adobe XD) based on the wireframes  and test them with representative users from each role (Schedulers, Surgeons, etc.) before writing significant code. Focus on core workflows like scheduling with SDST.
Usability Testing Sessions: Conduct formal usability testing sessions at the end of each phase (or major feature release) with realistic scenarios. Observe users, encourage think-aloud protocol, and collect qualitative feedback.
Targeted Role-Based Feedback: The suggestion to involve users with disabilities representing different roles is key for accessibility feedback.
Beta Programs:
Run a beta program with a select group of end-users in a controlled environment before full deployment. This helps identify real-world issues and gather practical feedback.
In-App Feedback Mechanisms:
Include a simple way for users to submit feedback, bug reports, or feature suggestions directly from within the application (e.g., a "Feedback" button).
Regular Stakeholder Reviews:
Conduct regular review meetings with key stakeholders (including user representatives) to demonstrate progress, gather feedback, and adjust priorities as needed.
Analytics and Monitoring:
Implement basic usage analytics (with user consent and anonymization where appropriate) to understand which features are being used, where users might be struggling, and to monitor system performance.
Agile Development Methodology:
Employ an agile development methodology (e.g., Scrum, Kanban) that inherently supports iteration, continuous feedback, and adaptation to changing requirements. Regular sprint reviews can be a key feedback point.
Dedicated Feedback Channels:
Establish clear channels for users to provide ongoing feedback post-launch (e.g., a dedicated email address, support forum, or regular user group meetings).
Iterate on SDST Management: Given the complexity of SDST, pay special attention to iterating on its visualization, interaction, and management tools based on user feedback. Schedulers are the primary users here, and their buy-in is critical.


By following these recommendations, the Surgery Scheduling System App has the potential to become a powerful, user-friendly, and indispensable tool for healthcare professionals.


================================================
FILE: implimentation.txt
================================================
UI/UX Design Vision: Surgery Scheduling System AppPreamble: This document outlines the UI/UX design vision for the Surgery Scheduling System App. It translates the Software Requirements Document (SRD, Version 1.0) into a tangible design strategy, focusing on creating an intuitive, efficient, and trustworthy application for managing complex surgical schedules, with a particular emphasis on Sequence-Dependent Setup Times (SDST).1. Overall Design PhilosophyThe design philosophy for the Surgery Scheduling System App is anchored in a set of core principles that will guide all UI/UX decisions. These principles are derived from the App's fundamental purpose of optimizing surgical scheduling (SRD 1.1), the diverse characteristics and needs of its users (SRD 2.3), and established best practices within healthcare user experience design.1 The overarching aim is to deliver a system that is not only powerful but also a pleasure to use, ultimately enhancing operational efficiency and supporting high-quality patient care.1.1. Guiding Principles

Efficiency-Driven: The primary objective of the App is to streamline the inherently complex task of surgery scheduling (SRD 1.1). Consequently, the UI must empower users to complete their tasks rapidly and with minimal cognitive and physical effort (NFR-USE-003). This principle will manifest in designs that minimize clicks, automate repetitive actions where sensible, provide intelligent defaults, and offer clear, unobstructed pathways to essential functionalities. For healthcare professionals, an effective user experience translates directly to "quick access to vital information, enabling them to make informed decisions swiftly".3 User-centered design approaches are known to culminate in "more efficient workflows".2


User-Centricity (Role-Optimized): The App will serve multiple user classes, each with distinct responsibilities and technical acumen: Schedulers/OR Managers, Surgeons, Nurses/Medical Staff, and System Administrators (SRD 2.3). The design will be meticulously tailored to the specific needs, typical workflows, and expertise levels of each role. This involves prioritizing the display of relevant information and making role-specific tools readily accessible. A core tenet of quality healthcare UX is that it "is user-oriented and helps to accomplish their purposes".1 The design process must maintain an early and continuous focus on these users and their tasks.4


Trust and Reliability: Within the critical domain of healthcare, user trust in the scheduling system is non-negotiable (SRD 1.1, NFR-REL-001). The UI must consistently project accuracy, robust security (NFR-SEC-001), and unwavering reliability. This will be achieved through predictable system behavior, transparent feedback mechanisms, clear communication of system status, and a professional, polished presentation. Well-designed medical software has the power to "inspire confidence, trust, and perceived intelligence".5 Users, particularly in healthcare, require "real-time reassurance," and even "small UX elements like loading indicators, instant feedback...can enhance user engagement, build trust".6


Clarity and Intuitiveness: The scheduling of surgeries, especially when factoring in complexities like SDST, can be demanding. Therefore, the interface must be exceptionally easy to learn, understand, and navigate (NFR-USE-001, EI-UI-002). This will be realized through unambiguous labeling, a logical and consistent information hierarchy, intuitive interaction patterns, and the avoidance of unnecessary jargon. A key principle is "Clear and Intuitive Design," where "the user should feel that using your app is no more complicated than brushing teeth".1 The aim is to "make complex tasks feel effortless".3


Safety and Error Prevention: The design must proactively mitigate the risk of errors, particularly those that could compromise patient safety or disrupt operational efficiency (SRD 1.1). This involves implementing comprehensive input validation, providing clear and timely alerts for potential conflicts (FR-SCHEDOP-002), offering confirmation steps for critical actions (e.g., cancelling a surgery), and designing workflows that guide users towards correct actions. "Intuitive, error-resistant interfaces reduce mistakes during high-risk tasks".5 A primary goal is "Errors' Prevention" by anticipating potential user missteps and designing to avert them.1


Modern and Professional Aesthetic: While functionality and usability are paramount, a contemporary and professional visual design (EI-UI-001) significantly contributes to user confidence, perceived system quality, and overall user satisfaction. The aesthetic will be clean, uncluttered, and aligned with the serious nature of the healthcare environment.

1.2. RationaleThe high-stakes, time-sensitive nature of surgery scheduling necessitates a system that users can depend upon without it becoming an additional source of stress or cognitive burden. The introduction of Sequence-Dependent Setup Times (SDST) as a critical scheduling constraint (FR-SCOPE-002.1) significantly amplifies this complexity. Therefore, the design philosophy must prioritize solutions that simplify, clarify, and guide the user, particularly in managing SDST.The diverse user roles, each with unique responsibilities and system interactions (SRD 2.3), demand a flexible yet consistent design approach. A Scheduler/OR Manager requires comprehensive control and visibility over all scheduling parameters, while a Surgeon primarily needs quick access to their personal schedule and the ability to manage their availability. The design philosophy must accommodate this spectrum of needs seamlessly.Ultimately, the App aims to achieve tangible improvements in operating room utilization, reductions in patient waiting times, and enhanced resource management (SRD 1.1). An efficient, intuitive, trustworthy, and role-optimized UI is not merely a superficial enhancement but a direct and critical enabler of these strategic objectives.The complexity of SDST presents a central design challenge that extends beyond mere data management. The SRD underscores SDST as a critical and intricate factor (FR-SCOPE-002.1, FR-SDSTDATA-*, FR-SCHEDOP-003, FR-OPTIM-003). Effective healthcare UX strives to minimize cognitive load 6 and make complex tasks feel effortless.3 Therefore, a core philosophical commitment is to mitigate the "cognitive cost" of SDST on users, especially Schedulers. The UI must do more than simply display SDST values; it must actively assist users in understanding SDST implications without necessitating complex mental calculations or cross-referencing. This will inform specific UI choices, such as highly visual and contextual representations of SDST, automated highlighting of SDST-related conflicts, and clear explanations of how SDST impacts schedule feasibility and efficiency.Furthermore, trust in the system, particularly concerning the outputs of the optimization engine (SRD 3.7), cannot be a passive outcome; it must be an active design goal. Healthcare professionals rely on this system for decisions that critically affect patient care and resource allocation (SRD 1.1). Research links positive UX directly to user trust.5 If the system, especially its optimization component, is perceived as a "black box" – opaque or unreliable – users may resort to manual methods or develop workarounds, thereby undermining the system's intended benefits. To counter this, the design will incorporate elements that actively cultivate trust: transparent (though potentially simplified) displays of the rationale behind optimization decisions, readily accessible and clear audit trails (FR-AUDIT-001), consistent and informative feedback mechanisms 6, and robust, graceful error handling (NFR-REL-002).2. Information Architecture (IA)The Information Architecture (IA) defines the high-level organization and navigational structure of the Surgery Scheduling System App. Its design will ensure that users can easily and efficiently locate information and access functionalities pertinent to their specific roles and tasks (SRD 2.3). The IA will be grounded in principles of clarity, efficiency, and scalability, promoting intuitive navigation and reducing cognitive load.72.1. High-Level Organization and StructureThe App will employ a role-based, task-oriented navigation structure.9 This means that while the overall set of available modules might be broad, the prominence and accessibility of these modules will be tailored to the user's role. Key modules will be consistently accessible via a persistent main navigation element, such as a sidebar or a top navigation bar.The IA will adhere to the "Principle of Objects" 7, treating core entities like Surgeries, Resources (ORs, Staff, Equipment), and SDST Rules as distinct, manageable objects. Each of these objects will have its own lifecycle, attributes, and dedicated sections within the App for their management.To prevent overwhelming users with excessive information or too many choices at once, the "Principle of Choices" and the "Principle of Disclosure" 7 will be fundamental. Relevant options and information will be presented progressively, revealing more detail as the user navigates deeper into a specific task or data set. This approach is crucial for managing the complexity inherent in a comprehensive scheduling system.The IA must support both "broad overview" workflows, necessary for Schedulers who need a comprehensive view of the entire schedule and all resources (SRD 2.3), and "deep dive" or filtered workflows for users like Surgeons, who may only need to see their personal schedule. This echoes concepts of multi-level information access seen in enterprise navigation systems, allowing users to adjust their "zoom level" on the information.10 While the main navigation structure will remain consistent for familiarity, the content, default filters, and views within sections such as "Scheduling" or the "Dashboard" will be highly adaptable or pre-filtered based on the logged-in user's role. For example, a Surgeon's default view of the "Scheduling" module might automatically display only their assigned cases.The accuracy and integrity of SDST data (FR-SDSTDATA-*) are paramount, as this data directly underpins the core functionality of scheduling (FR-SCHEDOP-003) and the optimization engine (FR-OPTIM-003). Errors or inconsistencies in SDST definitions can have significant downstream effects on schedule feasibility and efficiency (NFR-DATAINTEG-003). Consequently, the IA will position "SDST Data Management" as a critical administrative function, likely with restricted access to ensure data quality. However, the outputs of this module—the SDST values themselves—must be seamlessly and clearly integrated into the "Scheduling" module for operational use by Schedulers. The UI must make the connection between the definition of SDST rules and their application in daily scheduling transparent. Organizing medical data into logical and clearly accessible subcategories is vital for clarity and efficient use.82.2. Main Sections (Illustrative Sitemap)The following sitemap outlines the proposed hierarchical structure of the App:1. Login (Public)

2. Authenticated App
    2.1. Dashboard (Role-Specific Landing Page)
        2.1.1. Overview (Key Metrics, Critical Alerts, Today's Schedule Snippet)
        2.1.2. Quick Actions (Contextual, e.g., "Schedule New Elective Surgery," "View My Upcoming Cases," "Add Emergency Case")
    2.2. Scheduling
        2.2.1. Master Schedule View (Primary workspace for Schedulers)
            2.2.1.1. View Options (Gantt Chart per OR, Calendar per OR)
            2.2.1.2. Filter Controls (Date Range: Day, Week, Month; Filter by OR, Surgeon, Service, Status)
            2.2.1.3. Create New Surgery (Elective) (FR-SURGDATA-001)
            2.2.1.4. View/Edit/Cancel Existing Surgery (FR-SURGDATA-003, FR-SURGDATA-004)
            2.2.1.5. SDST Visualization & Conflict Indicators (FR-SCHEDOP-003)
        2.2.2. Pending Surgeries List (Awaiting Scheduling)
        2.2.3. Emergency Case Entry & Management (FR-EMER-001)
        2.2.4. Optimization Engine Control (Scheduler/Administrator only) (FR-OPTIM-001)
            2.2.4.1. Configure Optimization Parameters (FR-OPTIM-002, FR-OPTIM-009)
            2.2.4.2. Run Optimization
            2.2.4.3. Review Proposed Optimized Schedule (FR-OPTIM-010)
            2.2.4.4. Accept/Reject/Manually Adjust Optimized Schedule (FR-SCOPE-005)
    2.3. Resource Management (Primarily for Schedulers/Administrators)
        2.3.1. Operating Rooms (FR-RESDATA-001)
            2.3.1.1. View/Add/Edit OR List & Properties
            2.3.1.2. Manage OR Availability (Time Windows, Block-outs) (FR-SCOPE-013)
        2.3.2. Staff Management (FR-RESDATA-002)
            2.3.2.1. View/Add/Edit Staff List (Surgeons, Nurses, Anesthetists, etc.)
            2.3.2.2. Manage Staff Roles, Specializations
            2.3.2.3. Manage Staff Availability (Time Windows, Block-outs, On-Call) (FR-SCOPE-013)
        2.3.3. Equipment Management (FR-RESDATA-003)
            2.3.3.1. View/Add/Edit Critical Equipment List & Properties
            2.3.3.2. Manage Equipment Availability (Time Windows, Maintenance)
    2.4. SDST Data Management (Primarily for Schedulers/Administrators) (FR-SDSTDATA-*)
        2.4.1. Manage Surgery Types (Define distinct types for SDST calculation) (FR-SDSTDATA-001, FR-SCOPE-012)
        2.4.2. Manage SDST Matrix (Define setup time between pairs of Surgery Types) (FR-SDSTDATA-002, FR-SDSTDATA-005)
        2.4.3. Manage Initial Setup Times (For first surgery in an OR/day per Surgery Type) (FR-SDSTDATA-003)
        2.4.4. Manage OR-Specific SDST (Optional, if configured) (FR-SDSTDATA-004)
        2.4.5. Validate SDST Data Integrity (FR-SDSTDATA-006)
    2.5. Reporting & Analytics (SRD 3.8)
        2.5.1. Predefined Reports
            2.5.1.1. OR Utilization Reports (FR-REPORT-001)
            2.5.1.2. Surgeon Workload Reports (FR-REPORT-002)
            2.5.1.3. Patient Wait Time Reports (FR-REPORT-003)
            2.5.1.4. SDST Impact Analysis Reports (Total Setup Time, Sequence Impact) (FR-REPORT-004, FR-REPORT-005)
        2.5.2. Report Filters & Sorting (FR-REPORT-006)
        2.5.3. Export Reports (CSV, PDF) (FR-REPORT-007)
    2.6. Notifications (FR-NOTIF-004)
        2.6.1. Notification Inbox/List (Categorized, Unread Indicators)
        2.6.2. View Notification Details
    2.7. Administration (System Administrator Role Only)
        2.7.1. User Account Management (Create, Modify, Activate/Deactivate Users) (FR-AUTH-003)
        2.7.2. User Role Management (Assign/Manage Roles) (FR-AUTH-004)
        2.7.3. System Configuration (EHR Integration Settings EI-SW-EHR-004, Default Optimization Parameters, Session Timeout FR-AUTH-006)
        2.7.4. Audit Trail Viewer (Search, Filter Logs) (FR-AUDIT-003)
    2.8. My Profile / Settings (All Authenticated Users)
        2.8.1. View/Edit Personal Information (Non-critical fields)
        2.8.2. Change Password
        2.8.3. Manage Notification Preferences
    2.9. Help / Documentation (OR-TRAIN-001)
        2.9.1. User Manuals (Role-Specific)
        2.9.2. FAQ
        2.9.3. System Version/About Information
2.3. Navigation Flow Example (Scheduling a New Elective Surgery by Scheduler)
Access Point: The Scheduler logs in and lands on their Dashboard. They can initiate scheduling via:

Clicking a "Schedule New Elective Surgery" quick action button on the Dashboard.
Navigating to Scheduling > Create New Surgery from the main navigation menu.
Navigating to Scheduling > Master Schedule View and clicking an "Add Surgery" button or an available time slot.


Surgery Details Input: A form appears (potentially in a modal or a dedicated panel) requesting:

Patient Identifier (with an EHR lookup feature to pull basic demographics - FR-SURGDATA-001, EI-SW-EHR-002).
Surgery Type (dropdown list populated from FR-SDSTDATA-001).
Estimated Duration (input field).
Required Resources (dropdowns/multi-select for Surgeons, specific staff roles, critical equipment - FR-SURGDATA-001).
Priority Level.
Any specific notes or constraints.


Slot Selection & SDST Consideration:

Upon initial detail entry, the system might automatically suggest optimal slots based on availability and SDST minimization, or the Scheduler can manually browse the Master Schedule View (Gantt chart).
As the Scheduler considers an OR and a time slot (e.g., by hovering or attempting to drag-and-drop the pending surgery), the system dynamically calculates and visually displays the required SDST based on the surgery type of the preceding surgery in that OR (FR-SCHEDOP-003). If it's the first surgery of the day, the initial setup time is shown (FR-SDSTDATA-003).
Resource conflicts (OR, staff, equipment) and SDST violations are flagged in real-time (FR-SCHEDOP-002, FR-SCHEDOP-004).


Confirmation & Allocation:

The Scheduler selects a valid, conflict-free slot.
A confirmation step summarizes the surgery details, including the calculated SDST and total OR block time.
Upon confirmation, the surgery is added to the schedule, resources are allocated, and relevant notifications are triggered (FR-NOTIF-001). The surgery status is updated (FR-SURGDATA-005).


3. User Interface (UI) Wireframes (Low-Fidelity Descriptions)This section provides text-based low-fidelity wireframes for key screens of the Surgery Scheduling System App. These descriptions focus on the layout, core UI elements, and information hierarchy tailored to user roles and tasks, referencing SRD requirements and established UI patterns.11 The aim is to illustrate the functional structure of each screen before detailed visual design.3.1. Login Screen (FR-AUTH-001)
Layout: A clean, uncluttered page with content centered vertically and horizontally. Ample white space to promote focus.
Elements:

Header: Application Logo and Name prominently displayed at the top or above the login form.
Form Title: "Login" or "Sign In to Your Account."
Username Input Field: Clearly labeled "Username" or "Email Address." Standard text input.
Password Input Field: Clearly labeled "Password." Standard password input field (characters masked). An option to toggle password visibility (icon button) should be considered for usability.
Login Button: Primary action button, clearly labeled "Login" or "Sign In."
Forgot Password Link: A secondary link styled as "Forgot Password?" positioned below the login button (if FR-AUTH-005, password recovery, is implemented).
Footer (Optional): Brief security notice or link to privacy policy/terms of use.


Rationale: The design prioritizes simplicity, ease of use, and security, which are critical for an enterprise application handling sensitive data.11 Minimal visual distractions ensure users can quickly authenticate.
3.2. Dashboard (Role-Specific) (EI-UI-005)
General Layout (Authenticated State):

Top Navigation Bar (App Header): Persistently visible across the top. Contains:

Application Logo/Name (links to Dashboard home).
Global Search Bar (for quick finding of surgeries, patients, staff).
Notification Icon (with badge for unread notifications).
User Profile Dropdown (displaying user's name/role, with links to "My Profile/Settings" and "Logout").


Left Sidebar Navigation: Persistently visible on the left (can be collapsible to icons to maximize content area). Contains links to main modules as per the sitemap (Dashboard, Scheduling, Resource Management, etc.). Active module is highlighted.
Main Content Area: Occupies the largest portion of the screen, displaying role-specific widgets and information.


Rationale: A consistent global navigation structure aids learnability and efficiency. Role-specific dashboards ensure that the most relevant information and actions are immediately accessible to each user type upon login, reducing cognitive load and improving workflow efficiency.1
The following table outlines the key dashboard elements and functionalities tailored for each primary user role, based on their responsibilities as defined in SRD 2.3.Table 1: User Role vs. Key Dashboard Elements & FunctionalityUser RolePrimary Responsibilities (SRD 2.3)Key Information NeedsPrioritized Dashboard Widgets/ModulesKey Actions from DashboardScheduler / OR ManagerDaily OR scheduling, resource coordination, SDST management, conflict handling, optimization, reporting.Overall OR status, pending surgeries, resource availability/conflicts, SDST issues, key performance indicators (KPIs).- Today's OR Schedule Overview (all ORs) <br> - Pending Surgeries List <br> - Resource Conflict Alerts <br> - SDST Conflict/Warning Summary <br> - Key KPIs (OR Utilization, Avg. SDST) <br> - Optimization Status- Schedule New Surgery <br> - Add Emergency Case <br> - Go to Master Schedule <br> - Manage Resources <br> - Run Optimization <br> - View ReportsSurgeonView personal schedule, indicate availability, review patient details (via EHR link).Own upcoming surgeries, changes to their schedule, personal availability status.- My Upcoming Surgeries (List/Calendar) <br> - Personal Notifications (Schedule Changes) <br> - My Availability Overview- View Full Surgery Details <br> - Manage My Availability <br> - Acknowledge Schedule ChangesNurse / Medical StaffView assigned schedules, acknowledge assignments, access relevant patient info.Own assigned surgeries for the day/week, specific tasks or preparations needed.- My Assigned Surgeries (List/Calendar) <br> - Notifications (New/Changed Assignments) <br> - Task List (e.g., Pre-op checks)- View Surgery Details <br> - Acknowledge Assignments <br> - Update Task StatusSystem AdministratorUser account management, system monitoring, backups, configuration, troubleshooting.System health, user activity, security events, integration statuses.- System Status Overview (Servers, DB, EHR Link) <br> - User Activity Summary <br> - Recent Audit Log Snippet <br> - Key System KPIs (Uptime, Errors)- Manage User Accounts <br> - View Full Audit Logs <br> - Access System Configuration <br> - Monitor Performance

3.2.1. Scheduler/OR Manager Dashboard (SRD 2.3, EI-UI-005)

Key Widgets (in Main Content Area):

Today's OR Schedule Overview: A compact, scrollable Gantt-style or timeline view summarizing surgeries for all ORs for the current day. Color-coded by status (e.g., upcoming, in-progress, delayed, completed). Each surgery block shows key info (Patient, Type, Surgeon, Time). Clicking a surgery navigates to its full details in the Master Schedule. Provides an at-a-glance view of the day's operations.12
Pending Surgeries Queue: A sortable list of surgeries that are requested but not yet scheduled. Displays Patient Name/ID, Surgery Type, Requested Date (if any), Priority, Estimated Duration. Each item has a "Schedule Now" button.
Critical Resource Alerts: A prominent section highlighting immediate resource issues, e.g., "OR 3: A/C Maintenance Overdue," "Anesthesia Machine X: Unavailable," "Only 1 Cardiac Nurse available for afternoon shift."
SDST Conflict Summary: Lists any active SDST violations or unresolved warnings in the current or upcoming schedule, with links to the affected surgeries on the Master Schedule.
Key Performance Indicators (KPIs): Display of critical metrics such as:

Overall OR Utilization (Today/Week-to-Date) (FR-REPORT-001).
Average SDST per OR (Today/Week-to-Date) (FR-REPORT-004).
Number of Emergency Cases (Today/Week-to-Date).
Number of Cancelled/Rescheduled Surgeries. (Visualized with simple charts or numerical displays 15).


Quick Actions Bar/Buttons: "Schedule New Elective Surgery," "Add Emergency Case," "Go to Master Schedule," "Manage Resources," "Run Optimization."





3.2.2. Surgeon Dashboard (SRD 2.3, EI-UI-005)

Key Widgets:

My Upcoming Surgeries: A personalized list or calendar view showing only the surgeon's scheduled surgeries for today and the next few days (e.g., 7 days). Displays: Date, Start Time, Patient Name/ID, Surgery Type, OR Number, Estimated Duration. Clicking a surgery provides more details and potentially a link to the patient's EHR record (FR-SCOPE-006). (Inspired by doctor-specific views 16).
My Notifications: A feed of notifications relevant to the surgeon, e.g., "Your 10:00 AM surgery in OR 2 has been delayed by 30 mins," "New surgery assigned for at."
My Availability Quick View: A mini-calendar or summary showing their currently defined availability, with a clear link to "Manage My Availability/Block-offs."
Pending Tasks/Confirmations (If applicable): E.g., "Confirm details for [Patient X]'s surgery."





3.2.3. Nurse/Medical Staff Dashboard (SRD 2.3, EI-UI-005)

Key Widgets:

My Assigned Surgeries & Tasks: Similar to the Surgeon's view, a list or calendar of surgeries they are assigned to for today/upcoming shift. Displays: Time, OR, Patient, Surgeon, Their Specific Role (e.g., Scrub Nurse, Anesthetist). May include specific pre-operative tasks linked to these surgeries.
Notifications: Alerts for new assignments, changes to their scheduled cases, or urgent communications.
Team Communication Snippet (Optional): A small section for important team announcements or messages, if applicable.





3.2.4. System Administrator Dashboard (SRD 2.3, EI-UI-005)

Key Widgets:

System Health Overview: Status indicators for critical components: Application Server (Node.js), Database (PostgreSQL), Optimization Engine (Python environment), EHR Integration Link. (Green/Yellow/Red status lights). (Inspired by admin dashboards 18).
User Activity Snapshot: Number of currently active users, total users, new user registrations (if applicable), recent failed login attempts.
Recent Critical Audit Events: A brief, filterable list of the latest significant system events from the audit trail (FR-AUDIT-003), e.g., "Admin Login," "SDST Rule Changed," "EHR Connection Failed."
Resource Utilization (System Level): Basic server CPU, memory, disk space usage if the App has access to this info.
Quick Actions: "Manage User Accounts," "View Full Audit Log," "Access System Configuration," "Backup Status/Trigger."




3.3. Surgery Scheduling Screen (FR-SCHEDOP-, FR-SURGDATA-)This screen is the "cognitive cockpit" for Schedulers, where most of their critical work occurs. It must be highly dynamic and provide rich, contextual information, especially regarding SDST.
Layout: A multi-panel, interactive interface designed for efficient workflow.

Main Panel: Master Schedule View (Gantt Chart): Dominates the screen. Rows represent Operating Rooms. Columns represent time (e.g., hourly blocks for a day view; daily blocks for a week/month view). Surgeries are displayed as colored blocks within their assigned OR and time slot (FR-SCHEDOP-005).

Each surgery block will visually incorporate its SDST. The SDST period will be a distinct segment at the beginning of the surgery block, perhaps with a different color saturation, pattern, or a clear demarcation line, its length proportional to the SDST duration (FR-SCHEDOP-003). For example, a blue surgery block might have a light-blue SDST segment preceding it.
Hovering over a surgery block reveals a tooltip with core details (Patient, Full Surgery Type, Surgeon, Exact Times, Duration, SDST duration and reason).
Controls for Day/Week/Month views, date navigation, and OR filtering.
Zoom functionality for the timeline.
This Gantt chart is not static; it's a dynamic tool for decision-making and conflict resolution.13


Left Panel (or Collapsible Sidebar): Pending Surgeries & Filters:

A list of unscheduled surgeries, filterable by priority, specialty, requested date.
Drag-and-drop functionality from this list to the Gantt chart.
Filters for the Gantt chart (e.g., show only specific services, surgeons, or surgery statuses).


Right Panel (Contextual): Surgery Details / Creation Form & SDST/Conflict Information: This panel changes content based on user action.

When Creating/Editing a Surgery (FR-SURGDATA-001, FR-SURGDATA-003):

Form fields: Patient ID (with EHR lookup button FR-SCOPE-006), Surgery Type (dropdown linked to FR-SDSTDATA-001), Estimated Duration, Priority, Required Surgeon(s) (dropdown with availability indicators), Required Staff Roles (multi-select checklist, e.g., Anesthetist, Scrub Nurse), Required Equipment (multi-select checklist).
Buttons: "Save," "Schedule," "Cancel."


When a Surgery is Selected on Gantt or Being Dragged:

Displays full details of the selected/dragged surgery.
SDST Information Section: Clearly shows the calculated SDST for the current placement (based on preceding surgery in that OR, or initial setup if first FR-SDSTDATA-003). States: "Preceding: -> Current: = SDST: [XX] minutes."
Resource Availability Check: Lists required resources and their availability status for the selected/hovered time slot.
Conflict Alerts Area: Prominently displays any conflicts (FR-SCHEDOP-002, FR-SCHEDOP-004) like "Surgeon [Name] unavailable," "OR [X] closed," "SDST Violation: Overlaps with preceding surgery clean-up by [Y] mins."






Interaction:

Drag-and-drop a pending surgery onto an OR timeline. As it's dragged, the SDST segment visually appears and adjusts based on the potential preceding surgery. Conflicts are highlighted in real-time on the Gantt and in the right panel.
Clicking an empty slot in an OR allows creating a new surgery for that slot.
Clicking an existing surgery selects it, populates the right panel with its details, and allows editing or cancellation.


3.4. Resource Management Screen (FR-RESDATA-*)
Layout: A main section with tabs for "Operating Rooms," "Staff," and "Equipment." Each tab presents a list view of the resources and allows access to a detail/edit view for individual resources.
Operating Rooms Tab (FR-RESDATA-001):

List View: Table displaying OR Name/Identifier, Location (if applicable), Status (e.g., Active, Under Maintenance), primary associated service. Sortable columns. "Add New OR" button.
Detail/Edit View (on selecting an OR or adding new):

Fields for OR Name/Identifier, properties (e.g., size, fixed equipment).
Availability Calendar: A full-page calendar view (Month/Week/Day) 21 to define and visualize recurring availability (e.g., Mon-Fri 07:00-18:00) and specific block-out periods (e.g., "Deep Clean - 14:00-16:00"). Users can click and drag to create/modify blocks. (FR-SCOPE-013).




Staff Tab (FR-RESDATA-002):

List View: Table displaying Staff Name, Role (Surgeon, Nurse, Anesthetist, etc.), Specialization(s), Contact Info, Status (Active/Inactive). Sortable and filterable. "Add New Staff" button.
Detail/Edit View:

Fields for personal details, role, specializations (link to defined list), credentials (optional).
Availability Calendar: Similar to ORs, for managing individual staff schedules, shifts, on-call duties, approved leave, and ad-hoc unavailability. (FR-SCOPE-013).




Equipment Tab (FR-RESDATA-003):

List View: Table displaying Equipment Name/ID, Type (e.g., C-Arm, Microscope Model X), Current Status (Available, In Use, Maintenance), Location (if mobile). "Add New Equipment" button.
Detail/Edit View:

Fields for equipment details, serial number, maintenance schedule.
Availability Calendar: To block out time for scheduled maintenance or denote periods when the equipment is assigned to a specific long-term case/OR.




3.5. Emergency Case Management Screen (FR-EMER-*)This screen must prioritize speed and clarity for rapid entry and decision-making under pressure.6 The workflow should be streamlined to find a feasible slot as quickly as possible, rather than achieving perfect optimization initially.
Layout: A single, focused form, possibly launched as a high-priority modal overlay or a dedicated urgent-access page. Minimal distractions.
Elements:

Prominent Title: "ADD EMERGENCY SURGERY" in a distinct color (e.g., red banner).
Input Fields (Minimal Critical Information First - FR-EMER-001):

Patient Identifier (EHR lookup if possible, but allow manual entry if EHR is slow/down).
Urgency Level (Dropdown: e.g., STAT, Urgent-within-X-hours).
Primary Surgeon (if known, or specialty required).
Surgery Type (brief description or selection from a limited "common emergency types" list).
Estimated Duration.
Critical Resource Needs (e.g., specific vital equipment).


Button: "Find Earliest Available Slot & Alert Team."


Post-Submission Interaction/View (FR-EMER-002, FR-EMER-003):

The system rapidly searches for the soonest feasible slots using a heuristic (not full optimization run).
Results Display: Presents a short list of the top 1-3 options, showing: OR, Start Time, End Time (including calculated SDST).
Conflict/Displacement Information: Clearly indicates if scheduling this emergency case will require postponing/bumping any existing elective surgeries. E.g., "Option 1: OR 2 at 14:00. Requires postponing [Patient Y]'s elective knee replacement."
Confirmation: Buttons to "Confirm Slot & Notify Team" for the selected option. This action then updates the schedule and triggers high-priority notifications.
The system may then suggest running a re-optimization for the remainder of the day's schedule in the background or as a follow-up action by the Scheduler (FR-EMER-005). (Workflow orchestration for urgent cases is key 23).


3.6. Reporting & Analytics Screen (FR-REPORT-*)
Layout: A dashboard-like interface. A sidebar or top tabs allow selection of different report categories. The main area displays the selected report's filters, data visualization, and data table.
Elements:

Report Navigator: List of available reports (e.g., "OR Utilization," "Surgeon Workload," "Patient Wait Times," "SDST Impact Analysis").
Filter Controls (Contextual to Report):

Date Range Picker (common to most reports).
Dropdowns/Multi-select for: OR(s), Surgeon(s), Surgery Type(s), Staff Role(s), etc. (FR-REPORT-006).


Data Visualization Area: Displays charts and graphs relevant to the selected report and filters (e.g., bar chart for OR utilization percentages, line chart for wait time trends, pie chart for surgery type distribution). (Healthcare KPIs and dashboard examples can be found in 15).
Data Table Area: Below or alongside the visualization, a table showing the detailed data used for the chart, with sortable columns.
Export Options: Buttons to export the current report data/view (e.g., "Export to CSV," "Export to PDF") (FR-REPORT-007).
Report Summary/Key Insights (Optional): A small text area highlighting key takeaways from the current report view.


3.7. SDST Data Management Screen (FR-SDSTDATA-*)This screen allows authorized users (Schedulers, Administrators) to define and manage the critical data that drives SDST calculations. Accuracy and clarity are paramount here, and the UI should provide "guardrails" to prevent erroneous entries.
Layout: Tabbed or sectioned interface for different aspects of SDST data.

Tab 1: Manage Surgery Types (FR-SDSTDATA-001, FR-SCOPE-012):

A simple list/table of all defined surgery types (e.g., "Cardiac - CABG," "Orthopedic - Knee Replacement," "General - Appendectomy").
Columns: Surgery Type Name, Code/Abbreviation (optional), Description (optional).
Actions: Add New Surgery Type, Edit Existing, Delete (with warnings if type is used in SDST matrix or scheduled surgeries).


Tab 2: Manage SDST Matrix (FR-SDSTDATA-002, FR-SDSTDATA-005):

Interface: A grid or matrix table where rows represent "Preceding Surgery Type" and columns represent "Succeeding Surgery Type." The intersection cell contains an editable input field for the setup time (in minutes) required when transitioning from the row-type to the column-type surgery. (Matrix data input ideas 26).
Dropdowns or searchable lists to select surgery types for rows/columns if the matrix is very large.
Clear visual indication of which cell is being edited.
Input validation for non-negative integer values for setup times (FR-SDSTDATA-006). Warnings for unusually high values.
"Save Changes" button for the matrix.
Consider a "View Impact" or "Simulate Change" feature (advanced) to show how altering an SDST value might affect typical schedules.


Tab 3: Manage Initial Setup Times (FR-SDSTDATA-003):

A table listing all defined Surgery Types in one column.
An adjacent column with an editable input field for "Initial Setup Time (minutes)" for each surgery type (i.e., setup time if it's the first case in an OR for the day or after a long idle period).
Input validation for non-negative values.


Tab 4 (Optional): OR-Specific SDST (FR-SDSTDATA-004):

If this feature is enabled, a more complex interface allowing users to define SDST exceptions or overrides based on Operating Room, Preceding Surgery Type, and Succeeding Surgery Type. This might involve selecting an OR first, then managing a specific SDST matrix for that OR.




General Elements: Clear instructions, tooltips explaining each SDST component. Audit trail for changes made to SDST data is critical (FR-AUDIT-001).
4. Interaction DesignInteraction design focuses on how users engage with the Surgery Scheduling System App to perform their tasks. The patterns chosen will prioritize efficiency, intuitiveness, and the reduction of errors, creating a seamless and supportive user experience.14.1. Navigation Patterns
Primary Navigation: A persistent, collapsible left-hand sidebar menu will serve as the primary navigation hub. This vertical navigation is scalable and can accommodate a comprehensive list of modules (Dashboard, Scheduling, Resource Management, SDST Data, Reporting, Administration, etc.).9 Icons will be used when collapsed, with full text labels when expanded. The currently active module will be visually highlighted.
Secondary Navigation: Within complex modules, secondary navigation will be implemented using tabs (e.g., in Resource Management: "ORs," "Staff," "Equipment" tabs) or sub-menus that appear contextually. This keeps related functionalities grouped and easily discoverable.
Breadcrumbs: To aid orientation within the App's hierarchy, especially in deeper sections like Administration or multi-level reports, breadcrumbs will be displayed consistently below the top navigation bar (e.g., Home > Reporting > OR Utilization > OR 1 Details). Each element in the breadcrumb trail will be a link, allowing users to easily navigate back to previous levels.9
Global Search: A prominent search bar will be located in the top navigation bar. This will allow users to quickly find key entities such as surgeries (by patient ID, patient name, surgery type), staff members (by name, role), or operating rooms (by name/number). Search results will be presented in a categorized and easy-to-scan format, with direct links to the relevant entity's detail page or location in the schedule.
4.2. Form Design (EI-UI-007, WCAG 3.3)Forms are critical for data input (e.g., creating surgeries, defining resources, managing SDST). Their design will adhere to best practices for usability and accessibility:
Clear Labeling: All input fields (text boxes, dropdowns, checkboxes, radio buttons) will have clear, concise, and permanently visible labels. Labels will be programmatically associated with their respective controls (e.g., using <label for>) and typically positioned above or to the left of the input field for optimal scannability (WCAG 3.3.2 29).
Input Validation: Validation will occur both in real-time (as-you-type, for simple format checks like numeric input) and upon form submission for more complex business rules. Error messages will be specific, user-friendly, and clearly indicate which field is problematic and suggest corrective actions (EI-UI-007). Errors will be visually highlighted (e.g., red border, error icon) next to the field, and a summary of errors may appear at the top of the form for longer forms.
Required Fields: All mandatory fields will be clearly indicated, typically with an asterisk (*) and a legend explaining the indicator. The system will prevent submission if required fields are empty.
Sensible Defaults: Where appropriate, fields will be pre-filled with common or contextually relevant values to save user time (e.g., defaulting the surgery date to today for a new request, pre-selecting the most common surgery type if context allows).
Grouping Related Information: Related form elements will be grouped visually and semantically using <fieldset> and <legend> elements (e.g., "Patient Demographics," "Surgical Requirements," "Resource Allocation"). This improves the form's structure and makes it easier to comprehend.
Progressive Disclosure: For particularly long or complex forms (e.g., detailed configuration screens), information may be broken down into logical steps (wizard-style) or collapsible sections (accordions). This reduces initial cognitive load by presenting only relevant information at each stage.6
Efficient Controls: Dropdown menus for predefined lists (e.g., surgery types, staff names), checkboxes for multiple selections, and radio buttons for mutually exclusive choices will be used appropriately. Autocomplete suggestions will be provided for fields like patient search or surgeon selection.
4.3. Data Visualization (FR-SCHEDOP-005, FR-REPORT-*)Effective visualization of complex data is crucial for this App.30
Gantt Charts (Scheduling): The primary tool for visualizing schedules (as detailed in Wireframe 3.3).

Interactions: Hovering over a surgery block will display a tooltip with key details. Clicking a block will select it for editing or viewing more information in a side panel. Drag-and-drop will be enabled for rescheduling (with real-time conflict and SDST feedback). Zoom controls will allow users to adjust the time scale (hourly, daily, weekly). SDST will be visually distinct yet clearly linked to its surgery.13


Calendars (Resource Availability): Standard calendar interfaces (Month, Week, Day views) will be used for managing availability of ORs, staff, and equipment.21

Visuals: Color-coding will indicate booked slots, available slots, non-working hours, and special block-out periods (e.g., maintenance, leave).
Interactions: Clicking on a date or time slot will allow users to define or modify availability (e.g., create a block-out, define a recurring shift).


Charts and Graphs (Reporting & Analytics): A variety of chart types will be used to present analytical data effectively.15

Bar Charts: For comparing discrete categories (e.g., OR utilization percentages across different ORs, number of surgeries per surgeon).
Line Charts: For showing trends over time (e.g., patient wait times over months, total SDST incurred per week).
Pie Charts (Used Sparingly): For showing proportions of a whole (e.g., breakdown of surgery types performed in a period), if the number of categories is small.
Data Tables: For presenting detailed numerical data alongside charts, with sortable columns and filtering capabilities.
Interactivity: Charts will be interactive. Hovering over chart segments will reveal tooltips with precise values. Clicking on legend items can toggle the visibility of data series. Drill-down capabilities may be provided where appropriate.


SDST Matrix (SDST Data Management): The grid layout will clearly present the from/to surgery type relationship. Cells containing setup times could be subtly color-coded based on duration (e.g., shades from green for short to red for long) to provide quick visual cues about time-intensive transitions.
4.4. Feedback Mechanisms (EI-UI-004)Clear and timely feedback is essential for user confidence and error prevention.6
Alerts:

Modal Dialogs: Used for critical information requiring immediate user attention or confirmation before proceeding (e.g., "Are you sure you want to cancel this surgery? This action cannot be undone."). They will temporarily halt interaction with the rest of the page.
Toast Notifications: Small, non-modal pop-up messages (often in a corner of the screen) that automatically disappear after a few seconds. Used for confirming successful actions (e.g., "Surgery scheduled successfully," "Resource availability updated," "Settings saved").
Inline Alerts/Messages: Displayed directly within the context of the relevant UI element. Used for validation errors next to form fields, or conflict warnings next to a surgery block on the Gantt chart. These will use distinct colors (e.g., red for errors, yellow for warnings, green for success, blue for informational).


Confirmations: Explicit confirmation steps will be required for potentially destructive actions (e.g., deleting a resource, cancelling a scheduled surgery) or significant system-wide changes (e.g., applying an optimized schedule generated by the engine).
Progress Indicators: For operations that may take noticeable time to complete, such as running the optimization engine (FR-OPTIM-001), generating complex reports, or saving large amounts of data.

Spinners/Loaders: For short, indeterminate waits.
Progress Bars: For longer, determinate operations, ideally showing percentage completion or status text (e.g., "Optimizing schedule: 75% complete..."). This reassures users that the system is working.6


Visual Cues: Subtle visual changes will provide immediate feedback for user interactions:

Button states: Different appearances for default, hover, active/pressed, and disabled states.
Highlighting: Clearly indicating selected items in lists, tables, or on the Gantt chart.
Drag-and-Drop: Visual representation of the item being dragged, and clear visual cues on valid/invalid drop targets.


4.5. Interactive Elements for Scheduling
Drag-and-Drop: Schedulers will be able to drag unscheduled surgeries from a pending list onto the Gantt chart or move already scheduled surgeries to different times or ORs. During the drag operation, the system will provide real-time visual feedback:

The SDST segment will appear and adjust dynamically based on the potential preceding surgery in the hovered-over slot.
Potential drop slots will be highlighted (e.g., green for valid, red for conflict).
A tooltip or a small overlay might show key implications (e.g., "SDST: 45 min," "Conflict: Surgeon Busy").


Resizable Blocks (Gantt Chart): Authorized users may be able to adjust the duration of a surgery directly on the Gantt chart by dragging the edge of its block. The system will automatically recalculate the end time and check for cascading conflicts with subsequent surgeries and their SDSTs.
In-place Editing: For quick modifications, some information might be editable directly within its display context, such as changing a surgery's status via a dropdown menu integrated into its Gantt chart block, or quick-editing a resource's availability on a calendar view.
The interaction design for complex scheduling adjustments must be more than just flagging a conflict (FR-SCHEDOP-002); it must actively support resolution (FR-SCOPE-005). When a conflict arises, particularly a nuanced one involving SDST or multiple resource constraints, a simple error message is insufficient. The system should adopt a "conversational" approach. For instance, if a user attempts to schedule a surgery that violates SDST, the system should explain why (e.g., "This placement requires 60 minutes for setup between Cardiac and Orthopedic procedures, but only 30 minutes are available in this gap") and then offer intelligent suggestions or guided choices for resolution (e.g., "Option 1: Shift the subsequent surgery by 30 minutes?", "Option 2: View alternative ORs with sufficient time?", "Option 3: See if a compatible surgeon with a shorter SDST pairing is available?"). This transforms the system from a rigid gatekeeper into a supportive partner in the decision-making process.Given that Schedulers often need to explore multiple "what-if" scenarios when dealing with the intricacies of SDST optimization or accommodating urgent cases (SRD 2.3, FR-SCOPE-005), the risk of making an undesirable change can be high. Committing every modification immediately can be inefficient if backtracking is needed. The principle of providing users with control and freedom, including the ability to undo actions, is crucial.1 Therefore, the interaction design for the main scheduling screen (Gantt chart) should incorporate a robust multi-level "Undo" functionality for recent actions. Furthermore, for more extensive explorations, a "Draft Mode" or "Sandbox Mode" should be considered. In this mode, Schedulers could experiment with complex schedule changes (e.g., moving multiple surgeries, reassigning resources, trying different sequences) and see the cascading effects—especially on SDST calculations, resource availability, and overall utilization metrics—before committing these changes to the live, operational schedule. This allows for risk-free exploration and informed decision-making.5. Visual DesignThe visual design of the Surgery Scheduling System App will aim for a clean, modern, professional, and trustworthy aesthetic. It will directly support usability by enhancing clarity, reducing cognitive load, and guiding user attention effectively, while also ensuring accessibility.15.1. Color Palette
Primary Colors: A base palette featuring calming and professional blues or greens will be selected. These colors are often associated with healthcare, technology, and trustworthiness. If the deploying hospital has established branding guidelines, these will be considered for primary color selection to ensure visual consistency with the institution's identity.
Secondary/Accent Colors: A limited set of secondary colors will be used strategically for calls to action (e.g., a distinct, accessible color for primary buttons), highlighting active UI elements (e.g., selected tabs, focused inputs), and drawing attention to important information.
Semantic Colors for Status and Alerts: A standardized set of semantic colors will be used consistently for status indicators and alerts:

Red/Orange: For critical errors, urgent warnings, and conflict notifications.
Yellow/Amber: For non-critical warnings or pending states.
Green: For success confirmations, positive statuses (e.g., "Available").
Blue: For informational messages or neutral statuses.


Neutral Colors: A range of grays (from light to dark) will be used for body text, backgrounds, borders, and general UI chrome. This ensures that content is legible and the interface does not feel visually overwhelming.
Accessibility (WCAG 1.4.3, 1.4.11): All color choices will strictly adhere to WCAG AA contrast ratio requirements for text against its background, and for non-text UI components (e.g., button borders, input field borders) against their adjacent backgrounds.6 Color will never be the sole means of conveying information; icons, text labels, or patterns will supplement color cues. Online contrast checking tools will be used throughout the design process.
5.2. Typography
Font Choices: Clear, highly legible, and modern sans-serif fonts suitable for user interfaces will be selected (e.g., Inter, Open Sans, Roboto, Lato). A primary font family will be used for most text, with a potential secondary font for specific uses like headings if it enhances hierarchy without sacrificing consistency. A limited number of font weights (e.g., regular, medium, bold) will be used to maintain a clean look.
Hierarchy and Scale: A clear and consistent typographic scale will be established to differentiate headings (H1, H2, H3, etc.), body text, labels, captions, and other text elements. This visual hierarchy will guide the user's eye, improve readability, and help users quickly scan and understand the information structure on each screen.
Readability and Legibility: Font sizes will be chosen to ensure comfortable reading on desktop and tablet displays (OE-004). Adequate line spacing (leading) and letter spacing (tracking) will be applied to enhance readability, especially for dense data displays in tables and reports. The system will support browser-based text resizing up to 200% without loss of content or functionality, as per WCAG 1.4.4.29
5.3. Imagery
Icons: A consistent set of professionally designed icons will be used throughout the App. Icons will be simple, universally recognizable, and pixel-perfect for clarity at various sizes. They will primarily serve functional purposes: to represent actions (e.g., save, edit, delete, add), navigate, indicate status (e.g., warning, success, information), and enhance the visual appeal of UI controls. Where appropriate, icons will be accompanied by text labels to ensure unambiguous understanding, especially for less common actions.
Illustrations and Photographs: Decorative illustrations or photographs will generally be avoided within the core functional areas of the application to maintain focus on data and tasks. If imagery is used (e.g., on the login screen for branding, or in help/documentation sections for explanatory purposes), it will be professional, high-quality, and directly relevant to the healthcare context. System-generated visuals, such as charts and graphs in the reporting module, are considered functional imagery and their design will prioritize clarity and data integrity.
5.4. Use of White Space and Visual Hierarchy
White Space (Negative Space): Generous and strategic use of white space is a cornerstone of the visual design. It will be employed to reduce visual clutter, improve readability by separating distinct content blocks, group related elements logically, and create a sense of calm and order on the screen.1 This is particularly important for data-intensive screens like the scheduling Gantt chart or detailed reports.
Visual Hierarchy: A strong visual hierarchy will be established on every screen to guide the user's attention to the most important elements and actions. This will be achieved through the deliberate application of size, color, contrast, typography (weight and style), spacing, and placement. Critical information, primary calls to action, and urgent alerts will be rendered most prominent, while secondary information will be less emphasized but still easily accessible.1
5.5. Overall Aesthetic
Clean and Modern: The App will feature a contemporary, minimalist aesthetic that avoids unnecessary ornamentation or visual noise. The focus will be on clarity, simplicity, and ease of use. UI elements will have a refined and polished appearance.
Professional and Trustworthy: The visual design will aim to instill confidence in the system's capabilities, accuracy, and reliability. This is achieved through consistency in design patterns, meticulous attention to detail, high-quality visual elements, and an overall presentation that feels robust and dependable.1
Data-Focused and Functional: In areas such as the scheduling views, resource management calendars, and reporting dashboards, the design will prioritize the clear, unambiguous, and efficient presentation of data. The visual design will support the data, allowing users to scan, interpret, and act upon it with ease.
The visual design must actively contribute to the comprehension of complex concepts like SDST. This is not merely about displaying a numerical value for SDST; it's about making this abstract concept tangible and its impact immediately obvious. On the Gantt chart, for instance, SDST periods must be visually distinct from the surgery blocks themselves. This could be achieved by using a lighter shade of the main surgery color, a subtle striped pattern, a dedicated "setup" icon within the SDST block, or a different border style. When a surgery is moved or its type changes, the visual representation of its associated SDST (and potentially the SDST of the next surgery if that sequence changes) must update dynamically and clearly. Within the SDST Data Management matrix itself, color-coding could be applied to cells to denote relative setup time durations (e.g., green for short, yellow for moderate, red for long), aiding schedulers in quickly identifying time-consuming transitions.Hospital environments can be inherently stressful. While the scheduling system needs to convey critical alerts effectively, its visual design should not contribute to this stress with an overly aggressive, cluttered, or chaotic interface. The design will adhere to principles of "calm technology." This means alerts should be noticeable and clear but not unnecessarily jarring (e.g., using distinct iconography and color cues rather than excessive flashing animations for most alerts). The overall color palette will be chosen for its soothing and professional qualities. Information density on screens, particularly dashboards and during emergency scheduling workflows, will be carefully managed to avoid overwhelming users. The visual design's goal is to inform, empower, and support users in a high-pressure environment, not to agitate or confuse them.6. Accessibility Considerations (WCAG 2.1 AA)The Surgery Scheduling System App will be designed and developed to meet the Web Content Accessibility Guidelines (WCAG) 2.1 at Level AA conformance (EI-UI-002, NFR-USE-001). This commitment ensures that the App is usable by the widest possible range of individuals, including those with disabilities such as visual, auditory, motor, and cognitive impairments. Adherence to these guidelines is not only a best practice for inclusive design but is particularly crucial in healthcare applications where diverse user abilities must be accommodated.16.1. Perceivable
Guideline 1.1 Text Alternatives: All non-text content (images, icons, charts) that conveys information will have appropriate text alternatives (e.g., alt text for images, ARIA labels for icon buttons) (WCAG 1.1.1). Decorative elements will be implemented in a way that assistive technologies can ignore them.
Guideline 1.3 Adaptable: Content will be structured to be presentable in different ways without losing information or structure.

Information, structure, and relationships conveyed through presentation will be programmatically determinable (e.g., correct use of HTML5 semantic elements like <nav>, <main>, <aside>, <article>; proper heading structure <h1> through <h6>; ordered and unordered lists; and correct table markup including <caption>, <thead>, <tbody>, <th> with appropriate scope attributes for data tables such as the SDST matrix or report tables) (WCAG 1.3.1 29).
When the sequence in which content is presented affects its meaning, a correct reading sequence will be programmatically determinable (WCAG 1.3.2).
Instructions provided for understanding and operating content will not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound (WCAG 1.3.3).


Guideline 1.4 Distinguishable: Content will be made easier for users to see and hear, including separating foreground from background.

Color will not be used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element (WCAG 1.4.1). For example, error states will use icons and text in addition to color.
For any audio that plays automatically for more than 3 seconds, a mechanism will be provided to pause or stop the audio, or control volume independently from the overall system volume (WCAG 1.4.2) (though auto-playing audio is generally discouraged).
Text and images of text will have a contrast ratio of at least 4.5:1 against their background. Large-scale text (18 point or 14 point bold) will have a contrast ratio of at least 3:1 (WCAG 1.4.3).
Text will be resizable up to 200 percent without loss of content or functionality (WCAG 1.4.4).
If the technologies being used can achieve the visual presentation, text will be used to convey information rather than images of text (WCAG 1.4.5).
Visual presentation of user interface components and graphical objects (e.g., icons, input borders) will have a contrast ratio of at least 3:1 against adjacent color(s) (WCAG 1.4.11).


6.2. Operable
Guideline 2.1 Keyboard Accessible: All functionality of the content will be operable through a keyboard interface without requiring specific timings for individual keystrokes (WCAG 2.1.1). There will be no keyboard traps (WCAG 2.1.2). A visible keyboard focus indicator will always be present for interactive elements (WCAG 2.4.7).
Guideline 2.2 Enough Time: Users will be provided with enough time to read and use content. If session timeouts are implemented (FR-AUTH-006), users will be warned and given options to extend the session before data loss occurs (WCAG 2.2.1).
Guideline 2.4 Navigable: Users will be provided with ways to navigate, find content, and determine where they are.

A mechanism to bypass blocks of content that are repeated on multiple Web pages (e.g., "Skip to Main Content" link) will be available (WCAG 2.4.1).
Page titles will be descriptive and informative (WCAG 2.4.2).
The focus order of interactive elements will be logical and preserve meaning (WCAG 2.4.3).
Link purpose will be clear from the link text alone or from link text together with its programmatically determined link context (WCAG 2.4.4).
Multiple ways to locate a Web page within a set of Web pages will be available (e.g., sitemap, search, consistent navigation) (WCAG 2.4.5).
Headings and labels will describe topic or purpose (WCAG 2.4.6).


6.3. Understandable
Guideline 3.1 Readable: Text content will be readable and understandable. The default human language of each Web page will be programmatically determined (WCAG 3.1.1).
Guideline 3.2 Predictable: Web pages will appear and operate in predictable ways.

When any user interface component receives focus, it will not initiate a change of context (WCAG 3.2.1).
Changing the setting of any user interface component will not automatically cause a change of context unless the user has been advised of the behavior before using the component (WCAG 3.2.2).
Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages will occur in the same relative order each time they are repeated, unless a change is initiated by the user (WCAG 3.2.3).
Components that have the same functionality within a set of Web pages will be identified consistently (WCAG 3.2.4).


Guideline 3.3 Input Assistance: Users will be helped to avoid and correct mistakes.

If an input error is automatically detected, the item that is in error will be identified and the error described to the user in text (WCAG 3.3.1, EI-UI-007).
Labels or instructions will be provided when content requires user input (WCAG 3.3.2 29).
If an input error is automatically detected and suggestions for correction are known, then the suggestions will be provided to the user, unless it would jeopardize the security or purpose of the content (WCAG 3.3.3).
For Web pages that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, at least one of the following will be true: submissions are reversible, data entered is checked for input errors and the user is provided an opportunity to correct them, or a mechanism is available for reviewing, confirming, and correcting information before finalizing the submission (WCAG 3.3.4). This is particularly relevant for scheduling actions.


6.4. Robust
Guideline 4.1 Compatible: Content will maximize compatibility with current and future user agents, including assistive technologies. This involves ensuring well-formed HTML, correct use of ARIA (Accessible Rich Internet Applications) attributes where native HTML semantics are insufficient, and avoiding deprecated features (WCAG 4.1.1, 4.1.2).
Specifics for Complex Elements:
Data Tables (SDST Matrix, Reports, Resource Lists):

Will use <caption> for table titles.
<thead>, <tbody>, (and <tfoot> if appropriate) will structure table content.
<th> elements with scope="col" or scope="row" attributes will be used for all header cells to programmatically associate them with data cells.31
For very complex tables that might function like interactive grids, ARIA roles such as grid, rowheader, columnheader, and gridcell may be employed, along with ARIA properties for sortable columns (aria-sort) or selectable rows (aria-selected).


Forms (Surgery Creation, Resource Management, Login, SDST Edits):

All form controls will be explicitly associated with their visible labels using <label for="control-id">.
Related groups of controls will be enclosed in <fieldset> with a descriptive <legend>.
Required fields will be indicated visually (e.g., asterisk) and programmatically (e.g., aria-required="true").
Error messages will be associated with the relevant input field using aria-describedby or aria-errormessage, and aria-invalid="true" will be set on fields with errors.


Gantt Charts and Calendar Views: These highly visual and interactive components present significant accessibility challenges.

A parallel, accessible tabular representation of the schedule data will be considered as a fallback or alternative view for users who cannot effectively interact with the graphical chart.
Keyboard navigation must allow users to traverse through scheduled items, ORs, and time slots. Each focusable item (e.g., a surgery block) must provide comprehensive information to screen readers (e.g., patient, surgery type, time, duration, OR, SDST details, any conflicts).
ARIA roles (e.g., application, grid, treegrid) and properties (aria-readonly, aria-multiselectable, aria-labelledby, aria-describedby) will be thoroughly investigated and implemented to convey the structure, state, and interactivity of these components to assistive technologies.
Conflict alerts and SDST information associated with chart elements must be programmatically accessible.


Addressing accessibility for complex visualizations like Gantt charts (FR-SCHEDOP-005) and dense data grids such as the SDST matrix (FR-SDSTDATA-005) requires more than basic compliance. While WCAG provides foundational guidelines 29, their application to dynamic, interactive data visualizations is a nuanced challenge. A user relying on a screen reader needs to understand not just individual data points (e.g., a surgery's start time) but also their intricate relationships and context (e.g., the sequence of surgeries within an OR, SDST dependencies between them, and any resulting conflicts). This necessitates a robust ARIA implementation strategy. For Gantt charts, each surgery block, including its distinct SDST segment, must be a focusable element that clearly announces its full details (patient, type, time, OR, duration, SDST duration, and the preceding/succeeding surgery types if relevant to SDST). Conflicts associated with a surgery must be announced programmatically when that surgery receives focus. Keyboard navigation must allow users to traverse surgeries chronologically within an OR and move between ORs. For the SDST Matrix, each cell representing a setup time must be understandable in context (e.g., "Setup time from Cardiac Surgery to Orthopedic Surgery: 60 minutes"). Row and column headers must be clearly and programmatically associated with their respective data cells. Providing an alternative, simplified tabular view for such complex visual data should be considered as a crucial fallback to ensure full information access.Furthermore, the diverse user roles (SRD 2.3) imply varied accessibility needs. While WCAG AA serves as the universal baseline, the specific ways users interact with the system can influence priorities. For example, a Scheduler who spends hours working with the dense Gantt chart has different interaction patterns and potential accessibility pain points than a Surgeon who primarily needs to quickly check their personal schedule on a dashboard, possibly on a tablet. User testing involving individuals with disabilities, ideally representing these different user roles, would be invaluable for identifying role-specific accessibility challenges and refining solutions. For instance, a Surgeon might benefit from highly distinguishable audio cues for urgent notifications on their dashboard, especially if they are multitasking or have a visual impairment.Table 2: WCAG 2.1 AA Compliance Strategy for Key UI ComponentsUI ComponentRelevant WCAG Principle(s)Key WCAG Success CriteriaKey Design/Technical Implementation StrategyLogin FormPerceivable, Operable, Understandable, Robust1.3.1, 1.4.3, 1.4.11, 2.1.1, 2.4.7, 3.3.1, 3.3.2, 4.1.2Clear labels (<label for>), sufficient contrast, visible focus, keyboard operable, error identification (aria-invalid, aria-describedby).Main Navigation (Sidebar)Operable, Understandable, Robust2.1.1, 2.4.1 (if applicable), 2.4.3, 2.4.7, 3.2.3, 4.1.2Keyboard operable (arrows, tab), logical focus order, consistent placement, ARIA roles (e.g., navigation, tree if hierarchical). aria-current for active link.Dashboards (Role-Specific)Perceivable, Operable, Understandable1.3.1, 1.4.3, 2.4.6, 3.2.4Semantic headings for widgets, content structured for screen readers, keyboard navigation between widgets.Surgery Scheduling Gantt ChartPerceivable, Operable, Understandable, Robust1.1.1, 1.3.1, 1.4.1, 2.1.1, 2.4.3, 4.1.2Alternative text/tabular view, ARIA grid/treegrid for structure, keyboard navigation for cells/items, programmatic announcement of cell content & SDST/conflict info. Color not sole indicator.Resource CalendarsPerceivable, Operable, Understandable, Robust1.1.1, 1.3.1, 1.4.1, 2.1.1, 2.4.3, 4.1.2Similar to Gantt; ARIA for grid structure, keyboard navigation, programmatic announcement of availability/block-outs.SDST Matrix InputPerceivable, Operable, Understandable, Robust1.3.1, 1.4.11, 2.1.1, 3.3.2, 4.1.2<th> with scope for headers, <caption>, keyboard navigable cells, labels for inputs, ARIA for editable grid cells.Reporting Tables & ChartsPerceivable, Understandable1.1.1, 1.3.1, 1.4.1, 1.4.3alt text for charts (or detailed descriptions), accessible table markup (<th>, scope), sufficient contrast for chart elements.Modal DialogsOperable, Understandable, Robust2.1.1, 2.4.3, 3.2.1, 4.1.2ARIA dialog role, aria-modal="true", manage focus (trap focus inside, return focus on close), keyboard close (Esc key).Forms (General)Perceivable, Operable, Understandable, Robust1.3.1, 1.4.3, 1.4.11, 2.1.1, 2.4.7, 3.3.1, 3.3.2, 3.3.4, 4.1.2<label for>, <fieldset>, <legend>, aria-required, aria-invalid, aria-describedby for errors/instructions. Error prevention for critical data.7. Specific UI/UX Solutions for SDST ManagementSequence-Dependent Setup Time (SDST) is a critical complexity in this system (FR-SCOPE-002.1, FR-SDSTDATA-*, FR-SCHEDOP-003, FR-OPTIM-003). The UI/UX must therefore provide robust, intuitive, and clear solutions for managing, visualizing, and acting upon SDST data to ensure efficient and accurate scheduling. SDST is not merely a "time penalty"; it is a fundamental "sequencing driver." The UI must clearly communicate not just the duration of an SDST but also why that duration applies—specifically, because of the sequence of the preceding and succeeding surgery types. This understanding is vital for schedulers to make intelligent manual adjustments and to comprehend the logic behind optimized schedules.7.1. Visualizing SDST Data
Integrated Gantt Chart Display (FR-SCHEDOP-005):

Distinct Visual Representation: On the OR timeline within the Gantt chart, SDST periods will be visually represented as distinct blocks or segments immediately preceding each surgery block. These SDST blocks will have a different visual treatment (e.g., a lighter shade of the associated surgery's color, a subtle pattern, a different border style, or a specific "setup" icon) to clearly differentiate them from the actual surgery duration, yet they will be visually linked to the surgery they prepare for.
Proportional Length: The length of the SDST block on the timeline will accurately and proportionally represent its calculated duration.
Informative Tooltips: Hovering the cursor over an SDST block will trigger a tooltip providing specific details: "Setup for following: [X] minutes." This reinforces the sequence dependency.
Initial Setup Times: The initial setup time required for the first surgery in an OR for the day (or after a significant idle period), as defined in FR-SDSTDATA-003, will also be visualized similarly before the first scheduled surgery block.


Dedicated SDST Information Panel (Contextual):

When a Scheduler selects a surgery on the Gantt chart or is in the process of scheduling a new surgery, a dedicated panel or section within the UI (e.g., the right-hand contextual panel on the Surgery Scheduling Screen) will display detailed SDST information.
This panel will clearly state:

The calculated SDST for the specific sequence in question.
The "Preceding Surgery Type" and "Succeeding Surgery Type" that determined this SDST value.
A direct link or reference to the corresponding entry in the SDST matrix, allowing authorized users (e.g., Schedulers with appropriate permissions) to quickly verify the source rule if needed.




Color-Coding in SDST Matrix (SDST Data Management Screen):

Within the SDST Data Management screen (Wireframe 3.7), where the matrix of setup times between surgery types is defined, the cells containing the setup time values could be subtly color-coded. For example, shorter setup times might have a light green background, moderate times a light yellow, and particularly long setup times a light red. This provides an at-a-glance visual understanding of which surgery type transitions are most time-consuming or efficient, aiding in strategic SDST rule management.


7.2. Alerting Users to Potential SDST Conflicts (FR-SCHEDOP-002, FR-SCHEDOP-003)
Real-time Feedback During Manual Scheduling:

As a Scheduler interacts with the Gantt chart (e.g., dragging a surgery to a new slot, adjusting a surgery's time, or selecting a time for a new surgery), the system will instantly calculate and display the required SDST based on the dynamically identified preceding surgery.
If the chosen placement results in an SDST violation (e.g., insufficient time between the end of the preceding surgery and the start of the new surgery's calculated SDST period, or if the SDST period itself overlaps with another blocked time), the UI will provide immediate and clear alerts:

Visual Highlighting on Gantt: The conflicting SDST block and/or the affected surgery block(s) will change color (e.g., to red or orange) or display a prominent warning icon.
Descriptive Alert Message: A clear, non-modal alert message will appear in the contextual information panel (or as a tooltip), stating the nature of the conflict: e.g., "SDST Conflict: Requires 60 min setup, only 45 min available before [Patient Z]'s surgery," or "SDST Overlap: Setup time extends into OR cleaning block."




Post-Optimization Review Flags:

When the optimization engine (SRD 3.7) generates a proposed schedule, although it aims to minimize SDST-related inefficiencies (FR-OPTIM-003), any remaining or unavoidable SDST conflicts or very tight transitions should be clearly flagged in the review interface (FR-OPTIM-010). This allows the Scheduler to scrutinize these specific points before accepting the schedule.


Dashboard Notifications:

The Scheduler/OR Manager's dashboard (Wireframe 3.2.1) will include a dedicated widget or section summarizing any current, unresolved SDST conflicts present in the live schedule for the day or upcoming period, with direct links to the affected surgeries on the Master Schedule View.


7.3. Facilitating Manual Adjustments Based on SDST Insights (FR-SCOPE-005)
Interactive Gantt Chart with Guided Resolution:

When an SDST conflict is identified and flagged on the Gantt chart, clicking on the conflict indicator or the problematic surgery could trigger a small pop-up or contextual menu offering intelligent, suggested resolutions. Examples: "Shift by [Z] minutes to accommodate setup?", "View alternative ORs for with sufficient setup gap?", "Explore swapping with if SDST is more favorable?".
Manually adjusting the start time or duration of a surgery on the Gantt chart (e.g., by dragging or resizing) will trigger an immediate recalculation and visual update of its own SDST, the SDST of any immediately subsequent surgery in that OR (if its preceding surgery changes), and any new conflicts that arise.


"Ripple Effect" Visualization (Advanced Consideration):

For Schedulers making complex manual adjustments, a toggleable mode could be offered that visually indicates the "ripple effect" of a change. When a surgery is moved, the UI could subtly animate or highlight how that change, including its SDST implications, impacts the timing and feasibility of subsequent surgeries in that OR's schedule for the day. This provides a clearer understanding of downstream consequences.


Resource Re-allocation Assistance:

If an SDST conflict is indirectly caused by a lack of a specific resource required for the setup itself (e.g., a specialized piece of equipment or a particular staff skill needed during the setup phase is unavailable), the system, upon identifying this, could suggest alternative available resources or highlight time slots where that critical setup resource is available.


7.4. Communicating the Impact of SDST on Overall Schedule Efficiency (FR-REPORT-004, FR-REPORT-005)
Dedicated SDST Analytics and Reports:

"Total Setup Time Analysis": Reports showing the total time spent on SDST per OR, per day, per week, or per month. This can also be expressed as a percentage of total available OR time, providing a clear metric of setup-related "downtime" (FR-REPORT-004).
"SDST Hotspot Identification": Reports that analyze historical data to identify which specific sequences of surgery types (e.g., followed by) contribute most significantly to overall setup times. This can inform decisions about optimal surgery clustering or potential process improvements for high-SDST transitions (FR-REPORT-005).
"Impact of SDST-Aware Optimization": If the optimization engine specifically includes objectives related to minimizing total SDST (FR-OPTIM-003), reports should be available to show "before vs. after" comparisons of total setup time when such optimization strategies are applied. This demonstrates the tangible benefits of the optimization engine in managing SDST.
"Cost of SDST" (Advanced): Potentially, if cost data can be associated with OR time, reports could estimate the operational cost attributable to SDST.


Dashboard KPIs:

The Scheduler/OR Manager and System Administrator dashboards will feature key SDST-related Key Performance Indicators (KPIs), such as "Average SDST as % of Total Scheduled OR Time (Today/This Week)" or "Number of SDST Violations Prevented/Resolved."


Visual Cues in Reporting Dashboards:

Charts (e.g., stacked bar charts) could be used in reports to visually illustrate how different surgery sequencing strategies or the clustering of similar surgery types can impact (reduce or increase) overall SDST within a given period.


Managing the SDST matrix (FR-SDSTDATA-005) is a powerful capability, typically for Administrators or lead Schedulers. However, altering a value in this core dataset can have profound and far-reaching effects on all future scheduling possibilities and the outcomes of the optimization engine. Users making such changes need to understand these potential impacts before a change to a fundamental SDST rule is committed. Therefore, the SDST Data Management screen, particularly the SDST matrix editor, should ideally incorporate a "simulation" or "impact analysis" feature. For example, if a user proposes changing the setup time between "Cardiac - Valve Replacement" and "Orthopedic - Hip Arthroplasty," the system could offer to run a quick analysis on a sample of historical data or a representative future schedule template. This analysis could show how many past or planned schedules would have been affected (e.g., number of new conflicts created, number of surgeries that would need more/less time), or what the potential aggregate change in overall OR utilization or total setup time might be. This elevates the SDST management tool from a simple data entry interface to a strategic decision-support instrument, allowing for more informed and cautious modifications to this critical dataset.Table 3: SDST Visualization and Interaction TechniquesSDST AspectUI Element/LocationVisualization MethodInteraction MethodRationale/BenefitSRD Reference(s)SDST Duration on Gantt ChartSurgery Scheduling Screen (Master Schedule View)Distinct visual block/segment preceding surgery block, proportional length, different color/pattern from surgery.Hover for tooltip with "From Type -> To Type: Duration". Dynamically updates on drag/edit.Clearly shows SDST time allocation and its sequence dependency.FR-SCHEDOP-003, FR-SCHEDOP-005SDST Conflict AlertSurgery Scheduling Screen (Gantt & Contextual Panel), DashboardGantt: Red/orange highlighting of SDST/surgery block, warning icon. Panel/Dashboard: Clear text message detailing conflict.Click on conflict icon for resolution suggestions (if available). Real-time update during manual scheduling.Immediate awareness of SDST violations, facilitates timely correction.FR-SCHEDOP-002SDST Information (Contextual)Surgery Scheduling Screen (Right Panel when surgery selected/dragged)Text display: "Preceding: -> Current: = SDST: [XX] min". Link to SDST matrix entry.Read-only display, link to verify source rule.Reinforces sequence dependency and provides transparency for calculated SDST.FR-SCHEDOP-003SDST in ReportsReporting & Analytics ScreenKPIs (Avg SDST, Total SDST), charts showing SDST trends, impact of sequences on total setup time.Filter reports by date, OR, surgery type. Drill-down into details.Communicates impact of SDST on overall OR efficiency and highlights areas for improvement.FR-REPORT-004, FR-REPORT-005SDST Matrix EntrySDST Data Management ScreenGrid/table with "Preceding Type" (rows) vs. "Succeeding Type" (columns); cells contain editable setup time. Optional color-coding of cells by duration.Direct input into cells, validation. Optional "Impact Analysis" before saving changes.Allows definition and maintenance of core SDST rules with safeguards.FR-SDSTDATA-002, FR-SDSTDATA-005, FR-SDSTDATA-006Initial Setup Time DisplaySurgery Scheduling Screen (Gantt), SDST Data ManagementGantt: Visual block before first surgery. Management: Table of surgery types with editable initial setup times.Read-only on Gantt (derived from settings). Editable in management screen.Ensures accurate scheduling for the start of OR sessions.FR-SDSTDATA-0038. Integration with EHR (UI Considerations) (EI-SW-EHR-*, FR-SCOPE-006)The integration of the Surgery Scheduling System App with existing hospital Electronic Health Record (EHR) systems is a key feature for enhancing data accuracy and workflow efficiency (FR-SCOPE-006). The UI design will focus on making this integration seamless for the user, ensuring clarity in data presentation, and upholding stringent data privacy and security standards.6 The App is designed to interface with EHRs, not to replicate their comprehensive functionalities (SRD 1.4.2).8.1. Retrieving and Displaying Patient Data from EHR (EI-SW-EHR-002)
Patient Lookup and Identification:

When creating a new surgery request (typically on the Surgery Scheduling Screen), the UI will provide a clear and efficient mechanism for users (e.g., Schedulers) to search for and identify the correct patient from the integrated EHR system.
This will likely be an auto-complete search field where the user can type a Patient ID, Medical Record Number (MRN), or Patient Name. As the user types, the system will query the EHR via the defined API and display matching results in a dropdown list for selection.
The search results should display enough information (e.g., Name, DOB, Patient ID) to allow unambiguous identification.


Contextual Patient Information Display:

Once a patient is selected and successfully retrieved from the EHR, a dedicated, read-only section within the surgery creation/details view will display essential patient information. This information will be concise and directly relevant to the scheduling process.
Key data points to display might include:

Full Patient Name, Date of Birth, Gender.
Primary Patient Identifiers (e.g., MRN from EHR).
Critical Alerts or Flags from the EHR, if the API supports their retrieval and they are relevant to surgical planning (e.g., significant allergies, contraindications for certain procedures, infectious disease warnings). This data must be presented very carefully and clearly.
Optionally, relevant upcoming appointments or recent hospital interactions if this information is deemed useful for scheduling context and is accessible via the EHR API.




Clarity of Data Source and Minimized Duplication:

The section displaying EHR-derived data will be explicitly labeled, for example, "Patient Information (Source: EHR)" or "EHR Snapshot." This clearly indicates to the user that this information originates from and is mastered in the EHR system.
The App will primarily link to the patient's record in the EHR system using the patient identifier. It will avoid storing extensive, duplicative clinical details locally. The focus is on retrieving necessary data for scheduling, not on building a local patient record.


EHR integration should provide "actionable context" rather than just displaying static data.32 Simply showing a patient's name and date of birth from an EHR (EI-SW-EHR-002) offers limited value. The real benefit for scheduling efficiency and patient safety emerges when the system can surface actionable EHR data directly at the point of decision-making within the scheduling workflow. For example, if the EHR API can provide critical alerts (e.g., a patient has a known severe latex allergy and the selected surgery type commonly involves latex gloves), the UI should present this as a prominent, non-intrusive alert directly on the surgery scheduling screen (e.g., "Alert from EHR: Patient has Latex Allergy - Verify OR Setup protocol"). This requires careful API design and data mapping with the EHR but significantly enhances the scheduling App's utility and safety contribution.8.2. UI for Potential Write-Back Scenarios (EI-SW-EHR-005 - Low Priority)While initial scope may be read-only for patient data (FR-SCOPE-006), if write-back functionality (e.g., updating the EHR with the final scheduled surgery date/time, OR assignment, or surgery completion status) is implemented (EI-SW-EHR-005), the UI must handle this with explicit user actions and clear feedback.
Explicit User Actions: Actions that trigger a data write-back to the EHR will not be silent or automatic by default for critical updates. They will typically require an explicit user confirmation, e.g., a button labeled "Send Schedule Update to EHR" or a clear notification like "The finalized schedule will now be communicated to the EHR system. Proceed?".
Feedback on Write-Back Status: The UI will provide immediate and clear feedback on the success or failure of any write-back attempt. This could be via toast notifications (e.g., "Surgery schedule successfully updated in EHR," "EHR Update Successful") or more detailed status messages if an error occurs (e.g., "Failed to update EHR:").
Clear Delineation of Data: The UI must maintain a clear distinction between data managed natively within the Surgery Scheduling App and data that is being pushed to or synchronized with the EHR.
8.3. Data Privacy and Security in the UI (NFR-SEC-001, NFR-COMPLIANCE-001)Protecting patient data is paramount.6 The UI will incorporate several measures to ensure data privacy and security when handling EHR-integrated information:
Role-Based Access Control (RBAC) for EHR Data: Even if patient data is retrieved from the EHR, its visibility and the level of detail displayed within the Surgery Scheduling App will be strictly governed by the logged-in user's role (FR-AUTH-002). For example, a Scheduler might only see basic patient identifiers and scheduling-relevant flags, while a Surgeon viewing their own case might see slightly more detailed clinical alerts pertinent to that specific surgery if provided by the EHR.
Audit Trails for EHR Interactions: All significant interactions involving EHR data, such as patient lookups, data retrieval events, and any attempted or successful write-back operations, will be comprehensively logged in the system's audit trail (FR-AUDIT-001). This supports accountability and compliance monitoring.
No Persistent Storage of Sensitive Clinical EHR Data (Beyond Necessary Temporary Caching): The UI will reinforce the App's role as a scheduling system, not a clinical data repository. Sensitive patient clinical details retrieved from the EHR should primarily be for display and immediate use, with minimal local storage beyond what is absolutely necessary for performance (e.g., temporary caching during an active session, which is then cleared).
Visual Cues for Secure Connection: Standard browser HTTPS indicators (e.g., padlock icon) will be present, signifying secure communication with the server. The UI might also subtly reinforce that any displayed EHR data is being handled over a secure connection, perhaps through consistent iconography or footer notices.
Data Masking Considerations: For certain views or roles, or in situations where full patient identifiers are not strictly necessary for the task at hand, partial data masking of sensitive patient identifiers (e.g., showing only the last four digits of an MRN, or initials instead of full name in summary lists) could be considered. This aligns with the principle of minimizing unnecessary data exposure 6, even within a secure system.
Users must have clear expectations regarding the "freshness" and "source of truth" for EHR-derived data. Clinical information in the EHR is dynamic and frequently updated. The Surgery Scheduling App is a consumer of this data, not its master. Users need to understand that the EHR remains the definitive source of truth for all patient clinical information, and what they see within the scheduling App is essentially a snapshot at a particular point in time. To manage these expectations, the UI should, where technically feasible via the EHR API, include subtle indicators of when the displayed EHR data was last refreshed or synchronized. Furthermore, clear visual boundaries, labels (e.g., "Patient data as of from EHR"), or tooltips should consistently identify EHR-sourced data. This helps prevent user confusion and potential errors if users mistakenly believe they can or should update clinical details within the scheduling App itself; clinical updates must always occur within the EHR.ConclusionThe UI/UX design vision for the Surgery Scheduling System App is centered on creating a highly efficient, user-centric, and trustworthy tool that empowers healthcare professionals to manage the complexities of surgical scheduling with greater ease and accuracy. By adhering to the outlined design philosophy, information architecture, and interaction patterns, the App will provide distinct, role-optimized experiences for Schedulers, Surgeons, Nurses, and Administrators.A critical focus of this vision is the intuitive management and clear visualization of Sequence-Dependent Setup Times (SDST). Specific UI/UX solutions have been proposed to demystify SDST, integrate it seamlessly into the scheduling workflow, alert users to potential conflicts, and provide insights into its impact on overall operational efficiency. These solutions aim to transform SDST from a confounding variable into a manageable parameter.The design prioritizes clarity in data presentation, robust error prevention, and seamless integration with EHR systems, all while upholding stringent accessibility (WCAG 2.1 AA) and data security standards. The low-fidelity wireframes provide a foundational blueprint for key screens, emphasizing task-oriented layouts and the logical flow of information. The visual design will strive for a modern, professional aesthetic that instills confidence and supports the demanding nature of the healthcare environment.Ultimately, this UI/UX design vision aims to deliver an application that not only meets the functional requirements outlined in the SRD but also significantly improves the daily workflows of its users. By reducing cognitive load, minimizing errors, and providing powerful decision-support tools, the Surgery Scheduling System App is envisioned to contribute positively to enhanced OR utilization, reduced patient wait times, and more effective resource management within the healthcare facility. The successful implementation of this vision will rely on iterative development, continuous user feedback, and a steadfast commitment to the core principles of user-centered design.


================================================
FILE: index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>



================================================
FILE: jest.config.js
================================================
module.exports = {
  testEnvironment: 'jsdom',
  transform: {
    '^.+\.(vue|js|jsx|ts|tsx|mjs|cjs)$': 'vite-jest',
  },
  moduleFileExtensions: ['vue', 'js', 'json', 'jsx', 'ts', 'tsx', 'node', 'mjs', 'cjs'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transformIgnorePatterns: [
    '/node_modules/(?!(@vitejs/plugin-vue))', // Allow vite-jest to process vite specific modules if needed
  ],
  collectCoverage: true,
  collectCoverageFrom: [
    'src/components/**/*.vue',
    'src/views/**/*.vue', // If you have a views folder
    // Add other paths if needed
  ],
  coverageReporters: ['html', 'text-summary'],
  // vite-jest specific options (if any, consult vite-jest documentation)
  // globals: {
  //   'vite-jest': {
  //     // vite config options
  //   }
  // }
};


================================================
FILE: package.json
================================================
{
  "name": "myapp",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest"
  },
  "dependencies": {
    "pinia": "^3.0.2",
    "vue": "^3.5.13",
    "vue-router": "^4.5.1",
    "vue-toastification": "^2.0.0-rc.5"
  },
  "devDependencies": {
    "@pinia/testing": "^1.0.1",
    "@vitejs/plugin-vue": "^5.2.3",
    "@vitest/ui": "^3.1.4",
    "@vue/test-utils": "^2.4.6",
    "eslint": "^9.27.0",
    "eslint-plugin-vue": "^10.1.0",
    "flush-promises": "^1.0.2",
    "jsdom": "^26.1.0",
    "vite": "^6.3.5",
    "vitest": "^3.1.4"
  }
}



================================================
FILE: vite.config.js
================================================
import { defineConfig } from 'vite'
import { fileURLToPath, URL } from 'node:url';
import vue from '@vitejs/plugin-vue'
// path import is not needed if using fileURLToPath
// import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  server: {
    proxy: {
      // Proxy API requests to backend server
      '/api': {
        target: 'http://localhost:3000', // Replace with your actual backend server address
        changeOrigin: true,
        // rewrite: (path) => path.replace(/^\/api/, '') // Uncomment if your backend doesn't expect /api prefix
      }
    }
  }
})



================================================
FILE: vitest.config.js
================================================
import { fileURLToPath, URL } from 'node:url';
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  test: {
    globals: true,
    environment: 'jsdom',
    deps: {
      inline: ['vue-router'] // Ensure vue-router is processed by Vitest
    },
    moduleNameMapper: {
      '^.+\.svg$': '<rootDir>/__mocks__/svgMock.js' // Or a simple string like 'svg-mock'
    }
  },
})


================================================
FILE: __mocks__/svgMock.js
================================================
// __mocks__/svgMock.js
export default 'SvgrURL'; // Or a simple string component
export const ReactComponent = 'div'; // Or a mock React component if needed



================================================
FILE: src/App.vue
================================================
<template>
  <router-view />
</template>

<script setup>
// This is the main App component.
// It renders the router-view, which handles the display of different screens based on the URL.
// The router is configured in src/router/index.js.

// Pinia setup would typically be done in main.js
// import { useScheduleStore } from './stores/scheduleStore';
// const store = useScheduleStore();
// Data loading should ideally happen within specific screen components or triggered by routing navigation.

</script>

<style scoped>
/* Add any global styles for the #app container here if needed */
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: left; /* Align content left */
  color: var(--color-very-dark-gray); /* Use CSS variable */
  height: 100vh; /* Ensure app container takes full height */
  overflow: hidden; /* Prevent scrollbars on #app if child handles it */
}

/* Remove default margin/padding if a layout component manages it */
body {
    margin: 0;
    padding: 0;
}

</style>



================================================
FILE: src/main.js
================================================
import { createApp } from 'vue'
import { createPinia } from 'pinia' // Add Pinia import
import './style.css'
import App from './App.vue'
import router from './router' // Import the router instance
import 'vue-toastification/dist/index.css'; // Import the CSS FIRST
import Toast from 'vue-toastification'; // Import vue-toastification

const app = createApp(App);
const pinia = createPinia(); // Create Pinia instance

// Test app.provide directly
try {
  if (typeof app.provide === 'function') {
    console.log('app.provide is a function on the app instance created by createApp.');
    app.provide('myCustomTestProvide', 'testValueFromMainJs');
    console.log('Successfully called app.provide directly in main.js.');
  } else {
    console.error('CRITICAL: app.provide is NOT a function on the app instance in main.js.', app);
  }
} catch (e) {
  console.error('Error encountered while testing app.provide directly in main.js:', e);
}

app.use(pinia); // Install Pinia BEFORE mounting
app.use(router); // Use the router
app.use(Toast); // Use vue-toastification

app.mount('#app');


================================================
FILE: src/style.css
================================================
:root {
  /* Color Palette */
  --color-primary: #007bff; /* Professional Blue */
  --color-primary-dark: #0056b3; /* Darker Blue for hover */
  --color-secondary: #6c757d; /* Secondary Gray */
  --color-success: #28a745; /* Green for success */
  --color-warning: #ffc107; /* Yellow for warning */
  --color-danger: #dc3545; /* Red for danger/error */
  --color-info: #17a2b8; /* Cyan for informational */

  /* Neutral Palette */
  --color-white: #ffffff;
  --color-light-gray: #f8f9fa; /* Very light background */
  --color-mid-light-gray: #e9ecef; /* Borders, separators */
  --color-gray: #ced4da; /* Inputs, borders */
  --color-dark-gray: #6c757d; /* Secondary text */
  --color-very-dark-gray: #343a40; /* Body text */

  /* Background */
  --color-background: var(--color-light-gray);

  /* Typography */
  font-family: 'Inter', system-ui, Avenir, Helvetica, Arial, sans-serif; /* Using Inter as an example, fallback to system fonts */
  line-height: 1.6;
  font-weight: 400;
  color: var(--color-very-dark-gray); /* Default text color */

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;

   /* Surgery Type Colors */
  --color-surgery-cabg: #007bff; /* Blue - Cardiac */
  --color-surgery-knee: #28a745; /* Green - Orthopedic */
  --color-surgery-appen: #ffc107; /* Yellow - General */
  --color-surgery-herni: #6c757d; /* Gray - General */
  --color-surgery-catar: #17a2b8; /* Cyan - Ophthalmology */
  --color-surgery-hipre: #20c997; /* Teal - Orthopedic */

  --color-sdst-segment: rgba(255, 255, 255, 0.3); /* Semi-transparent overlay for SDST in blocks */
  --color-sdst-border: rgba(0, 0, 0, 0.2); /* Border around SDST segment */

  /* Additional colors for UI states */
  --color-background-soft: #f1f5f9; /* Slightly darker than background for panels */
  --color-background-mute: #e2e8f0; /* Even darker for active elements */
  --color-background-hover: rgba(0, 0, 0, 0.02); /* Subtle hover effect */
  --color-background-active: rgba(0, 0, 0, 0.05); /* Slightly stronger for active state */

  /* Text colors */
  --color-text: var(--color-very-dark-gray);
  --color-text-secondary: var(--color-dark-gray);
  --color-text-inverted: var(--color-white);

  /* Border colors */
  --color-border: var(--color-mid-light-gray);
  --color-border-soft: var(--color-light-gray);

  /* Accent color for highlights */
  --color-accent: #f59e0b; /* Amber for highlights and current time indicator */

  /* Error color with RGB components for alpha operations */
  --color-error: #dc3545;
  --color-error-rgb: 220, 53, 69;

  /* Primary color with RGB components for alpha operations */
  --color-primary-rgb: 0, 123, 255;

  /* Focus outline color */
  --color-focus: var(--color-primary);


  /* Spacing */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* Typography */
  --font-size-sm: 0.875rem; /* ~14px */
  --font-size-base: 1rem; /* ~16px */
  --font-size-lg: 1.125rem; /* ~18px */
  --font-size-xl: 1.25rem; /* ~20px */
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-bold: 700;

  /* Border Radius */
  --border-radius-sm: 4px;
  --border-radius-md: 8px;

  /* Z-index (Example) */
  --z-index-tooltip: 100;
  --z-index-modal: 1000;

  /* Layout (Example, replace with actual header/footer height if they exist in a layout component) */
  --header-height: 0px; /* Assuming no fixed header within this scope for now */
  --footer-height: 0px; /* Assuming no fixed footer within this scope for now */
}

/* Global box-sizing for easier layout calculations */
*, *::before, *::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh; /* Ensure body takes at least full viewport height */
  background-color: var(--color-background);
  color: var(--color-very-dark-gray);
}

#app {
  /* App container should not have default padding/margin if layout component handles it */
  max-width: none;
  margin: 0;
  padding: 0;
  text-align: left; /* Align content left by default */
  height: 100vh; /* Ensure app container takes full height */
}

h1, h2, h3, h4, h5, h6 {
  color: var(--color-very-dark-gray); /* Headings color */
  line-height: 1.2;
  margin-top: 0;
  margin-bottom: 0.5em;
}

h1 {
  font-size: 2.5em;
}

h2 {
  font-size: 2em;
}

h3 {
  font-size: 1.75em;
}

a {
  font-weight: 500;
  color: var(--color-primary);
  text-decoration: none; /* Remove default underline */
}

a:hover {
  color: var(--color-primary-dark);
  text-decoration: underline; /* Add underline on hover */
}

button {
  border-radius: 4px; /* Slightly less rounded */
  border: 1px solid transparent;
  padding: 0.8em 1.5em; /* More padding */
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: var(--color-primary);
  color: var(--color-white);
  cursor: pointer;
  transition: background-color 0.25s ease, border-color 0.25s ease;
}

button:hover {
  background-color: var(--color-primary-dark);
  border-color: var(--color-primary-dark); /* Match border on hover */
}

button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
  outline-color: var(--color-primary); /* Use primary color for focus */
}

input[type="text"],
input[type="password"],
input[type="email"],
textarea,
select {
  padding: 10px;
  border: 1px solid var(--color-mid-light-gray);
  border-radius: 4px;
  box-sizing: border-box;
  font-size: 1em;
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

input:focus,
textarea:focus,
select:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); /* Focus visible ring */
}

/* Add styles for focus indicator (WCAG 2.4.7) - override default if needed */
*:focus-visible {
    outline: 2px solid var(--color-accent); /* Use accent color for focus */
    outline-offset: 2px;
}

/* --- App Layout Styles (from previous step, add if not already present) --- */
/* Note: These styles assume #app is the container for the main layout */
/* If using a separate AppLayout component, apply these styles there */

/* Basic layout for the Surgery Scheduling Screen */
.surgery-scheduling-layout {
  display: flex;
  /* Use calc for height if there's a fixed header/footer */
  height: calc(100vh - var(--header-height) - var(--footer-height)); /* Example height calculation based on variables */
  overflow: hidden; /* Prevent outer scrollbars */
}

.main-schedule-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* Manage scrolling within this area */
}

/* .pending-surgeries-panel styles are mostly in PendingSurgeriesList.vue */
/* .details-panel styles are mostly in SurgeryDetailsPanel.vue */

/* Add any other global styles or utility classes here */

/* Helper class for visually hiding elements for accessibility */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}




================================================
FILE: src/components/AddEditInitialSetupModal.vue
================================================
<template>
  <div class="modal-overlay" v-if="show" @click.self="handleCancel">
    <div class="modal-content">
      <h3>{{ isEditing ? 'Edit Initial Setup Time' : 'Add New Initial Setup Time' }}</h3>
      <form @submit.prevent="handleSubmit">

        <div class="input-group">
          <label for="setup-type">Surgery Type</label>
          <!-- Dropdown to select surgery type -->
          <!-- This dropdown should be populated by surgery types passed from the parent -->
          <select id="setup-type" v-model="formData.typeId" required :disabled="isEditing"> <!-- Disable type selection when editing -->
            <option value="">Select Surgery Type</option>
            <!-- Options will be populated via v-for on a prop -->
             <option v-for="type in surgeryTypes" :key="type.id" :value="type.id">{{ type.name }}</option>
          </select>
          <small v-if="isEditing">Cannot change Surgery Type when editing.</small>
        </div>

        <div class="input-group">
          <label for="setup-time">Initial Setup Time (minutes)</label>
          <input type="number" id="setup-time" v-model.number="formData.time" required min="0">
        </div>

        <div class="form-actions">
          <button type="submit" class="button-primary">{{ isEditing ? 'Save Changes' : 'Add Setup Time' }}</button>
          <button type="button" class="button-secondary" @click="handleCancel">Cancel</button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue';

// Define props to receive initial data for editing, editing flag, and the list of surgery types
const props = defineProps({
  show: { type: Boolean, default: false }, // Added show prop
  initialData: { type: Object, default: null }, // Data for the setup time being edited
  isEditing: { type: Boolean, default: false },
  surgeryTypes: { type: Array, required: true }, // List of surgery types to populate dropdown
});

// Define emits to communicate with parent (e.g., SDSTDataManagementScreen)
const emit = defineEmits(['save', 'cancel']);

// Initialize form data
const formData = ref({
  typeId: null,
  time: 0,
});

// Watch for changes in initialData prop to populate form when editing
watch(() => props.initialData, (newData) => {
  if (newData) {
    // Ensure we don't overwrite typeId if editing
    formData.value = { ...newData };
  } else {
    // Reset form when not editing (e.g., adding new)
     formData.value = { typeId: null, time: 0 };
  }
}, { immediate: true, deep: true }); // Run immediately and watch deeply


const handleSubmit = () => {
  console.log('Submitting Initial Setup Time data:', formData.value);
   // Add validation here if needed (e.g., check if typeId is selected, time is non-negative)
  if (!formData.value.typeId) {
      alert('Please select a Surgery Type.'); // Basic alert, replace with better UI feedback
      return;
  }
   if (formData.value.time < 0) {
       alert('Setup time cannot be negative.'); // Basic alert
       return;
   }

  // Emit the form data to the parent component
  emit('save', formData.value);
  // Reset form (handled by watch effect when parent closes modal/clears initialData)
};

const handleCancel = () => {
  console.log('Cancelling Initial Setup Time form');
  // Emit cancel event to the parent component
  emit('cancel');
  // Reset form (handled by watch effect when parent closes modal/clears initialData)
};

</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000; /* Ensure modal is on top */
}

.modal-content {
  background-color: var(--color-white);
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  max-width: 500px; /* Limit modal width */
  width: 90%;
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: var(--color-very-dark-gray);
  border-bottom: 1px solid var(--color-mid-light-gray);
  padding-bottom: 10px;
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: var(--color-dark-gray);
  font-size: 0.9em;
}

.input-group input[type="number"],
.input-group select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--color-gray);
  border-radius: 4px;
  box-sizing: border-box; /* Include padding and border in element's total width */
  font-size: 1em;
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

.input-group input:focus,
.input-group select:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); /* Example focus style */
}

.input-group small {
     display: block;
     margin-top: 5px;
     color: var(--color-dark-gray);
     font-size: 0.8em;
     font-style: italic;
}

.form-actions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px; /* Space between buttons */
}

.form-actions button {
    padding: 10px 20px;
    font-size: 1em;
}

.button-primary {
     background-color: var(--color-primary);
     color: var(--color-white);
     border: none;
}

.button-primary:hover {
    background-color: var(--color-primary-dark);
}

.button-secondary {
     background-color: var(--color-secondary);
     color: var(--color-white);
     border: none;
}

.button-secondary:hover {
     background-color: #5a6268;
}

</style>


================================================
FILE: src/components/AddEditSurgeryTypeModal.vue
================================================
<template>
  <div class="modal-overlay" v-if="show" @click.self="handleCancel">
    <div class="modal-content">
      <h3>{{ isEditing ? 'Edit Surgery Type' : 'Add New Surgery Type' }}</h3>
      <form @submit.prevent="handleSubmit">
        <div class="input-group">
          <label for="type-name">Name</label>
          <input type="text" id="type-name" v-model="formData.name" required>
        </div>

        <div class="input-group">
          <label for="type-code">Code (e.g., CABG, TKR)</label>
          <input type="text" id="type-code" v-model="formData.code">
        </div>

        <div class="input-group">
          <label for="type-description">Description</label>
          <textarea id="type-description" v-model="formData.description"></textarea>
        </div>

        <div class="form-actions">
          <button type="submit" class="button-primary">{{ isEditing ? 'Save Changes' : 'Add Type' }}</button>
          <button type="button" class="button-secondary" @click="handleCancel">Cancel</button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue';

// Define props to receive initial data for editing and a flag for edit mode
const props = defineProps({
  show: { type: Boolean, default: false }, // Added show prop
  initialData: { type: Object, default: null }, // Data for the type being edited
  isEditing: { type: Boolean, default: false },
});

// Define emits to communicate with parent (e.g., SDSTDataManagementScreen)
const emit = defineEmits(['save', 'cancel']);

// Initialize form data
const formData = ref({
  id: null, // Include ID for editing
  name: '',
  code: '',
  description: '',
});

// Watch for changes in initialData prop to populate form when editing
watch(() => props.initialData, (newData) => {
  if (newData) {
    formData.value = { ...newData }; // Populate form for editing
  } else {
    // Reset form when not editing (e.g., adding new)
     formData.value = { id: null, name: '', code: '', description: '' };
  }
}, { immediate: true }); // Run immediately to set initial state


const handleSubmit = () => {
  console.log('Submitting Surgery Type data:', formData.value);
  // Emit the form data to the parent component
  emit('save', formData.value);
  // Reset form (handled by watch effect when parent closes modal/clears initialData)
};

const handleCancel = () => {
  console.log('Cancelling Surgery Type form');
  // Emit cancel event to the parent component
  emit('cancel');
  // Reset form (handled by watch effect when parent closes modal/clears initialData)
};

</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000; /* Ensure modal is on top */
}

.modal-content {
  background-color: var(--color-white);
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  max-width: 500px; /* Limit modal width */
  width: 90%;
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: var(--color-very-dark-gray);
  border-bottom: 1px solid var(--color-mid-light-gray);
  padding-bottom: 10px;
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: var(--color-dark-gray);
  font-size: 0.9em;
}

.input-group input[type="text"],
.input-group textarea {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--color-gray);
  border-radius: 4px;
  box-sizing: border-box; /* Include padding and border in element's total width */
  font-size: 1em;
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

.input-group input:focus,
.input-group textarea:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); /* Example focus style */
}

.form-actions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px; /* Space between buttons */
}

.form-actions button {
    padding: 10px 20px;
    font-size: 1em;
}

.button-primary {
     background-color: var(--color-primary);
     color: var(--color-white);
     border: none;
}

.button-primary:hover {
    background-color: var(--color-primary-dark);
}

.button-secondary {
     background-color: var(--color-secondary);
     color: var(--color-white);
     border: none;
}

.button-secondary:hover {
     background-color: #5a6268;
}

</style>


================================================
FILE: src/components/AddEquipmentForm.vue
================================================
<template>
  <div class="add-equipment-form">
    <h3>{{ formTitle }}</h3>
    <form @submit.prevent="handleSubmit">
      <div class="input-group">
        <label for="equipment-name">Name/ID</label>
        <input type="text" id="equipment-name" v-model="equipmentData.name" @input="clearError('name')">
        <span v-if="errors.name" class="error-message">{{ errors.name }}</span>
      </div>

      <div class="input-group">
        <label for="equipment-type">Type</label>
        <input type="text" id="equipment-type" v-model="equipmentData.type" @input="clearError('type')">
        <span v-if="errors.type" class="error-message">{{ errors.type }}</span>
      </div>

      <div class="input-group">
        <label for="equipment-status">Status</label>
        <select id="equipment-status" v-model="equipmentData.status" @change="clearError('status')">
          <option value="">Select Status</option>
          <option value="Available">Available</option>
          <option value="In Use">In Use</option>
          <option value="Maintenance">Maintenance</option>
          <option value="Retired">Retired</option>
        </select>
        <span v-if="errors.status" class="error-message">{{ errors.status }}</span>
      </div>

       <div class="input-group">
        <label for="equipment-location">Location</label>
        <input type="text" id="equipment-location" v-model="equipmentData.location">
         <small>E.g., OR 5, Storage Room B</small>
         <!-- Location is optional, so no specific validation message for being empty -->
      </div>

      <div class="form-actions">
        <button type="submit" class="button-primary">{{ submitButtonText }}</button>
        <button type="button" class="button-secondary" @click="handleCancel">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup>
import { ref, watch, computed } from 'vue';

// Props definition
const props = defineProps({
  equipmentToEdit: {
    type: Object,
    default: null
  }
});

// Define initial form data structure
const initialEquipmentData = () => ({
  id: null,
  name: '',
  type: '',
  status: '',
  location: '',
});

const equipmentData = ref(initialEquipmentData());
const errors = ref({}); // Added for validation errors

// Functions to clear errors
const clearError = (field) => {
  if (errors.value[field]) {
    errors.value[field] = '';
  }
};

const clearAllErrors = () => {
  errors.value = {};
};

// Define emits to communicate with parent
const emit = defineEmits(['save', 'cancel']);

// Computed properties for dynamic UI elements
const isEditMode = computed(() => !!props.equipmentToEdit);
const formTitle = computed(() => isEditMode.value ? 'Edit Equipment' : 'Add New Equipment');
const submitButtonText = computed(() => isEditMode.value ? 'Update Equipment' : 'Save Equipment');

// Watch for changes in equipmentToEdit prop to pre-fill or reset the form
watch(() => props.equipmentToEdit, (newVal) => {
  clearAllErrors(); // Clear errors when equipmentToEdit changes
  if (newVal) {
    // Pre-fill form for editing
    equipmentData.value = { ...newVal };
  } else {
    // Reset form for adding or after cancellation
    equipmentData.value = initialEquipmentData();
  }
}, { immediate: true }); // immediate: true to run on component mount if prop is initially set

const validateForm = () => {
  clearAllErrors();
  let isValid = true;
  if (!equipmentData.value.name.trim()) {
    errors.value.name = 'Name/ID is required.';
    isValid = false;
  }
  if (!equipmentData.value.type.trim()) {
    errors.value.type = 'Type is required.';
    isValid = false;
  }
  if (!equipmentData.value.status) {
    errors.value.status = 'Status is required.';
    isValid = false;
  }
  return isValid;
};

const handleSubmit = () => {
  if (!validateForm()) {
    return; // Stop submission if validation fails
  }

  const dataToSave = { ...equipmentData.value };
  if (isEditMode.value) {
    dataToSave.isUpdate = true; // Add a flag to indicate an update operation
  }
  console.log('Submitting Equipment data:', dataToSave);
  emit('save', dataToSave);
  equipmentData.value = initialEquipmentData(); // Reset form after emitting save
  clearAllErrors(); // Clear errors on successful submission
};

const handleCancel = () => {
  console.log('Cancelling Equipment form');
  equipmentData.value = initialEquipmentData();
  clearAllErrors(); // Clear errors on cancel
  emit('cancel');
};

</script>

<style scoped>
.add-equipment-form {
  background-color: var(--color-white);
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  border: 1px solid var(--color-mid-light-gray);
  margin-top: 20px; /* Space above the form */
  max-width: 600px; /* Limit form width */
  margin-left: auto;
  margin-right: auto; /* Center the form */
}

.add-equipment-form h3 {
    font-size: 1.1em;
    margin-top: 0;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--color-mid-light-gray);
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: var(--color-dark-gray);
  font-size: 0.9em;
}

.input-group input[type="text"],
.input-group select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--color-gray);
  border-radius: 4px;
  box-sizing: border-box;
  font-size: 1em;
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

.error-message {
  color: var(--color-error);
  font-size: 0.8em;
  margin-top: 4px;
  display: block;
}

.input-group input.invalid,
.input-group select.invalid {
  border-color: var(--color-error);
}

.input-group input:focus,
.input-group select:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.input-group small {
    display: block;
    margin-top: 5px;
    color: var(--color-dark-gray);
    font-size: 0.85em;
    font-style: italic;
}

.form-actions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px; /* Space between buttons */
}

.form-actions button {
    padding: 10px 20px;
    font-size: 1em;
}

.button-primary {
     background-color: var(--color-primary);
     color: var(--color-white);
     border: none;
}

.button-primary:hover {
    background-color: var(--color-primary-dark);
}

.button-secondary {
     background-color: var(--color-secondary);
     color: var(--color-white);
     border: none;
}

.button-secondary:hover {
     background-color: #5a6268;
}


</style>


================================================
FILE: src/components/AddOrForm.vue
================================================
<template>
  <div class="add-or-form">
    <h3>{{ formTitle }}</h3>
    <form @submit.prevent="handleSubmit">
      <div class="input-group">
        <label for="or-name">Name/ID</label>
        <input type="text" id="or-name" v-model="orData.name" @input="clearError('name')">
        <span v-if="errors.name" class="error-message">{{ errors.name }}</span>
      </div>

      <div class="input-group">
        <label for="or-location">Location</label>
        <input type="text" id="or-location" v-model="orData.location">
        <!-- No validation for location in this example, but can be added -->
      </div>

      <div class="input-group">
        <label for="or-status">Status</label>
        <select id="or-status" v-model="orData.status" @change="clearError('status')">
          <option value="">Select Status</option>
          <option value="Active">Active</option>
          <option value="Under Maintenance">Under Maintenance</option>
          <option value="Inactive">Inactive</option>
        </select>
        <span v-if="errors.status" class="error-message">{{ errors.status }}</span>
      </div>

      <div class="input-group">
        <label for="or-service">Primary Service</label>
        <input type="text" id="or-service" v-model="orData.primaryService">
        <!-- No validation for primary service in this example, but can be added -->
      </div>

      <div class="form-actions">
        <button type="submit" class="button-primary">{{ submitButtonText }}</button>
        <button type="button" class="button-secondary" @click="handleCancel">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup>
import { ref, watch, computed } from 'vue';

const props = defineProps({
  orToEdit: {
    type: Object,
    default: null
  }
});

const emit = defineEmits(['save', 'cancel']);

const orData = ref({
  id: null,
  name: '',
  location: '',
  status: '',
  primaryService: '',
});

const errors = ref({ // Added for validation errors
  name: '',
  status: ''
});

// Functions to clear errors
const clearError = (field) => {
  if (errors.value[field]) {
    errors.value[field] = '';
  }
};

const clearAllErrors = () => {
  errors.value = { name: '', status: '' };
};

const isEditMode = computed(() => !!props.orToEdit);
const formTitle = computed(() => isEditMode.value ? 'Edit Operating Room' : 'Add New Operating Room');
const submitButtonText = computed(() => isEditMode.value ? 'Update OR' : 'Save OR');

watch(() => props.orToEdit, (newOr) => {
  if (newOr) {
    orData.value = { ...newOr };
  } else {
    orData.value = { id: null, name: '', location: '', status: '', primaryService: '' };
  }
  clearAllErrors(); // Clear errors when form data changes (e.g. switching to add/edit)
}, { immediate: true });

const validateForm = () => {
  let isValid = true;
  errors.value = { name: '', status: '' }; // Reset errors

  if (!orData.value.name.trim()) {
    errors.value.name = 'Name/ID is required.';
    isValid = false;
  }
  if (!orData.value.status) {
    errors.value.status = 'Status is required.';
    isValid = false;
  }
  return isValid;
};

const handleSubmit = () => {
  if (!validateForm()) {
    return; // Stop submission if validation fails
  }

  if (isEditMode.value) {
    console.log('Updating OR data:', orData.value);
    emit('save', { ...orData.value, isUpdate: true });
  } else {
    console.log('Submitting new OR data:', orData.value);
    const newOrPayload = { ...orData.value, id: orData.value.id || Date.now().toString() };
    emit('save', newOrPayload);
  }
  clearAllErrors(); // Clear errors on successful submission
};

const handleCancel = () => {
  console.log('Cancelling OR form');
  orData.value = { id: null, name: '', location: '', status: '', primaryService: '' };
  clearAllErrors(); // Clear errors on cancel
  emit('cancel');
};

</script>

<style scoped>
.add-or-form {
  background-color: var(--color-white);
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  border: 1px solid var(--color-mid-light-gray);
  margin-top: 20px; /* Space above the form */
  max-width: 600px; /* Limit form width */
  margin-left: auto;
  margin-right: auto; /* Center the form */
}

.add-or-form h3 {
    font-size: 1.1em;
    margin-top: 0;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--color-mid-light-gray);
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: var(--color-dark-gray);
  font-size: 0.9em;
}

.input-group input[type="text"],
.input-group select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--color-gray);
  border-radius: 4px;
  box-sizing: border-box;
  font-size: 1em;
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

.error-message {
  display: block;
  color: var(--color-danger);
  font-size: 0.8em;
  margin-top: 4px;
}

.input-group input.invalid,
.input-group select.invalid {
  border-color: var(--color-danger);
}

.input-group input:focus,
.input-group select:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.form-actions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px; /* Space between buttons */
}

.form-actions button {
    padding: 10px 20px;
    font-size: 1em;
}

.button-primary {
     background-color: var(--color-primary);
     color: var(--color-white);
     border: none;
}

.button-primary:hover {
    background-color: var(--color-primary-dark);
}

.button-secondary {
     background-color: var(--color-secondary);
     color: var(--color-white);
     border: none;
}

.button-secondary:hover {
     background-color: #5a6268;
}


</style>


================================================
FILE: src/components/AddStaffForm.vue
================================================
<template>
  <div class="add-staff-form">
    <h3>{{ formTitle }}</h3>
    <form @submit.prevent="handleSubmit">
      <div class="input-group">
        <label for="staff-name">Name</label>
        <input type="text" id="staff-name" v-model="staffData.name" @input="clearError('name')">
        <span v-if="errors.name" class="error-message">{{ errors.name }}</span>
      </div>

      <div class="input-group">
        <label for="staff-role">Role</label>
         <select id="staff-role" v-model="staffData.role" @change="clearError('role')">
          <option value="">Select Role</option>
          <option value="Surgeon">Surgeon</option>
          <option value="Nurse">Nurse</option>
          <option value="Anesthetist">Anesthetist</option>
          <option value="Other">Other</option>
        </select>
        <span v-if="errors.role" class="error-message">{{ errors.role }}</span>
      </div>

      <div class="input-group">
        <label for="staff-specializations">Specialization(s)</label>
        <input type="text" id="staff-specializations" v-model="staffData.specializationsString">
        <small>Enter specializations separated by commas (e.g., Orthopedics, Sports Medicine)</small>
        <!-- Basic validation for specializations can be added if it becomes a strict requirement -->
      </div>

       <div class="input-group">
        <label for="staff-status">Status</label>
        <select id="staff-status" v-model="staffData.status" @change="clearError('status')">
          <option value="">Select Status</option>
          <option value="Active">Active</option>
          <option value="On Leave">On Leave</option>
          <option value="Inactive">Inactive</option>
        </select>
        <span v-if="errors.status" class="error-message">{{ errors.status }}</span>
      </div>

      <div class="form-actions">
        <button type="submit" class="button-primary">{{ submitButtonText }}</button>
        <button type="button" class="button-secondary" @click="handleCancel">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup>
import { ref, watch, computed } from 'vue';

const props = defineProps({
  staffToEdit: {
    type: Object,
    default: null
  }
});

const emit = defineEmits(['save', 'cancel']);

const initialStaffData = () => ({
  id: null,
  name: '',
  role: '',
  specializations: [],
  specializationsString: '',
  status: '',
});

const staffData = ref(initialStaffData());
const errors = ref({}); // Added for validation errors

const isEditMode = computed(() => !!props.staffToEdit);
const formTitle = computed(() => isEditMode.value ? 'Edit Staff Member' : 'Add New Staff Member');
const submitButtonText = computed(() => isEditMode.value ? 'Update Staff' : 'Save Staff');

const clearError = (field) => {
  if (errors.value[field]) {
    errors.value[field] = '';
  }
};

const clearAllErrors = () => {
  errors.value = {};
};

// Watch for changes in staffToEdit prop to pre-fill form
watch(() => props.staffToEdit, (newStaff) => {
  clearAllErrors(); // Clear errors when staffToEdit changes
  if (newStaff) {
    staffData.value = {
      ...newStaff,
      specializationsString: newStaff.specializations ? newStaff.specializations.join(', ') : ''
    };
  } else {
    staffData.value = initialStaffData();
  }
}, { immediate: true });

// Watch the string input and update the array
watch(() => staffData.value.specializationsString, (newValue) => {
    staffData.value.specializations = newValue.split(',').map(s => s.trim()).filter(s => s);
});


const validateForm = () => {
  clearAllErrors();
  let isValid = true;
  if (!staffData.value.name.trim()) {
    errors.value.name = 'Name is required.';
    isValid = false;
  }
  if (!staffData.value.role) {
    errors.value.role = 'Role is required.';
    isValid = false;
  }
  if (!staffData.value.status) {
    errors.value.status = 'Status is required.';
    isValid = false;
  }
  return isValid;
};

const handleSubmit = () => {
  if (!validateForm()) {
    return; // Stop submission if validation fails
  }

  const payload = { ...staffData.value };
  delete payload.specializationsString;

  if (isEditMode.value) {
    console.log('Updating Staff data:', payload);
    emit('save', { ...payload, isUpdate: true });
  } else {
    console.log('Submitting new Staff data:', payload);
    emit('save', payload);
  }
  staffData.value = initialStaffData(); // Reset form after successful submission
  clearAllErrors(); // Clear errors on successful submission
};

const handleCancel = () => {
  console.log('Cancelling Staff form');
  staffData.value = initialStaffData(); // Reset form
  clearAllErrors(); // Clear errors on cancel
  emit('cancel');
};

</script>

<style scoped>
.add-staff-form {
  background-color: var(--color-white);
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  border: 1px solid var(--color-mid-light-gray);
  margin-top: 20px; /* Space above the form */
  max-width: 600px; /* Limit form width */
  margin-left: auto;
  margin-right: auto; /* Center the form */
}

.add-staff-form h3 {
    font-size: 1.1em;
    margin-top: 0;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--color-mid-light-gray);
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 600;
  color: var(--color-dark-gray);
  font-size: 0.9em;
}

.input-group input[type="text"],
.input-group select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--color-gray);
  border-radius: 4px;
  box-sizing: border-box;
  font-size: 1em;
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

.error-message {
  color: var(--color-error);
  font-size: 0.8em;
  margin-top: 4px;
  display: block;
}

.input-group input.invalid,
.input-group select.invalid {
  border-color: var(--color-error);
}

.input-group input:focus,
.input-group select:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.input-group small {
    display: block;
    margin-top: 5px;
    color: var(--color-dark-gray);
    font-size: 0.85em;
    font-style: italic;
}

.form-actions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px; /* Space between buttons */
}

.form-actions button {
    padding: 10px 20px;
    font-size: 1em;
}

.button-primary {
     background-color: var(--color-primary);
     color: var(--color-white);
     border: none;
}

.button-primary:hover {
    background-color: var(--color-primary-dark);
}

.button-secondary {
     background-color: var(--color-secondary);
     color: var(--color-white);
     border: none;
}

.button-secondary:hover {
     background-color: #5a6268;
}


</style>


================================================
FILE: src/components/AdministrationScreen.vue
================================================
<template>
  <div class="section-container">
    <h1>Administration</h1>
    <div class="admin-sections">
      <!-- Placeholder navigation for different admin sections -->
      <p>Admin sections placeholder:</p>
      <button>User Management</button>
      <button>Role Management</button>
      <button>System Settings</button>
    </div>
  </div>
</template>

<script setup>
// Component logic will go here later
</script>

<style scoped>
.section-container {
  padding: 20px;
}
</style>


================================================
FILE: src/components/AnalyticsDashboard.vue
================================================
<template>
  <div class="analytics-dashboard">
    <h1>Analytics Dashboard</h1>
    
    <!-- Date Range Selector -->
    <div class="date-range-selector">
      <h3>Date Range</h3>
      <div class="date-inputs">
        <div class="date-input">
          <label for="start-date">Start Date</label>
          <input 
            type="date" 
            id="start-date" 
            :value="formatDateForInput(dateRange.start)"
            @change="updateStartDate"
          >
        </div>
        <div class="date-input">
          <label for="end-date">End Date</label>
          <input 
            type="date" 
            id="end-date" 
            :value="formatDateForInput(dateRange.end)"
            @change="updateEndDate"
          >
        </div>
        <button class="apply-button" @click="applyDateRange">Apply</button>
      </div>
      <div class="quick-ranges">
        <button @click="setQuickRange('last7')">Last 7 Days</button>
        <button @click="setQuickRange('last30')">Last 30 Days</button>
        <button @click="setQuickRange('thisMonth')">This Month</button>
        <button @click="setQuickRange('lastMonth')">Last Month</button>
      </div>
    </div>
    
    <!-- Loading Indicator -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="spinner"></div>
      <p>Loading analytics data...</p>
    </div>
    
    <!-- Error Message -->
    <div v-else-if="error" class="error-message">
      <p>{{ error }}</p>
      <button @click="loadAnalyticsData">Retry</button>
    </div>
    
    <!-- Dashboard Content -->
    <div v-else class="dashboard-content">
      <!-- Summary Metrics -->
      <div class="summary-metrics">
        <div class="metric-card">
          <h3>Total Surgeries</h3>
          <div class="metric-value">{{ totalSurgeries }}</div>
          <div class="metric-trend" :class="surgeryTrend.direction">
            {{ surgeryTrend.value }}% {{ surgeryTrend.direction === 'up' ? '↑' : '↓' }}
          </div>
        </div>
        
        <div class="metric-card">
          <h3>Average OR Utilization</h3>
          <div class="metric-value">{{ formatPercentage(averageORUtilization) }}</div>
          <div class="metric-trend" :class="utilizationTrend.direction">
            {{ utilizationTrend.value }}% {{ utilizationTrend.direction === 'up' ? '↑' : '↓' }}
          </div>
        </div>
        
        <div class="metric-card">
          <h3>On-Time Start Rate</h3>
          <div class="metric-value">{{ formatPercentage(onTimeStartRate) }}</div>
          <div class="metric-trend" :class="onTimeTrend.direction">
            {{ onTimeTrend.value }}% {{ onTimeTrend.direction === 'up' ? '↑' : '↓' }}
          </div>
        </div>
        
        <div class="metric-card">
          <h3>Avg. Turnaround Time</h3>
          <div class="metric-value">{{ averageTurnaround }} min</div>
          <div class="metric-trend" :class="turnaroundTrend.direction === 'up' ? 'down' : 'up'">
            {{ turnaroundTrend.value }}% {{ turnaroundTrend.direction === 'up' ? '↑' : '↓' }}
          </div>
        </div>
      </div>
      
      <!-- Main Charts -->
      <div class="chart-row">
        <div class="chart-container">
          <h3>Daily Surgery Volume</h3>
          <div class="chart-placeholder">
            <!-- Chart would be rendered here using a charting library -->
            <div class="chart-mock">
              <div v-for="(value, index) in dailySurgeryData" :key="index" 
                   class="chart-bar" 
                   :style="{ height: `${value * 100}%` }">
              </div>
            </div>
          </div>
        </div>
        
        <div class="chart-container">
          <h3>OR Utilization by Room</h3>
          <div class="chart-placeholder">
            <!-- Chart would be rendered here using a charting library -->
            <div class="chart-mock horizontal">
              <div v-for="(or, index) in orUtilizationData" :key="index" class="chart-item">
                <div class="chart-label">{{ or.name }}</div>
                <div class="chart-bar-container">
                  <div class="chart-bar" :style="{ width: `${or.value * 100}%` }"></div>
                </div>
                <div class="chart-value">{{ formatPercentage(or.value) }}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="chart-row">
        <div class="chart-container">
          <h3>Surgery Type Distribution</h3>
          <div class="chart-placeholder">
            <!-- Chart would be rendered here using a charting library -->
            <div class="chart-mock pie">
              <div v-for="(segment, index) in surgeryTypeData" :key="index" 
                   class="pie-segment"
                   :style="{ 
                     backgroundColor: segment.color,
                     transform: `rotate(${segment.startAngle}deg)`,
                     clipPath: `polygon(50% 50%, 100% 0, 100% 100%, 0 100%, 0 0)`
                   }">
              </div>
              <div class="pie-legend">
                <div v-for="(segment, index) in surgeryTypeData" :key="`legend-${index}`" class="legend-item">
                  <div class="color-box" :style="{ backgroundColor: segment.color }"></div>
                  <div>{{ segment.name }}: {{ formatPercentage(segment.value) }}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="chart-container">
          <h3>Surgeon Performance</h3>
          <div class="chart-placeholder">
            <!-- Chart would be rendered here using a charting library -->
            <div class="chart-mock horizontal">
              <div v-for="(surgeon, index) in surgeonPerformanceData" :key="index" class="chart-item">
                <div class="chart-label">{{ surgeon.name }}</div>
                <div class="chart-bar-container">
                  <div class="chart-bar" :style="{ width: `${surgeon.value * 100}%` }"></div>
                </div>
                <div class="chart-value">{{ surgeon.surgeries }} surgeries</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Report Links -->
      <div class="report-links">
        <h3>Detailed Reports</h3>
        <div class="report-buttons">
          <button @click="navigateTo('utilization')">OR Utilization Report</button>
          <button @click="navigateTo('efficiency')">Scheduling Efficiency Report</button>
          <button @click="navigateTo('custom')">Custom Report Builder</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useAnalyticsStore } from '@/stores/analyticsStore';
import { storeToRefs } from 'pinia';

const router = useRouter();
const analyticsStore = useAnalyticsStore();
const { isLoading, error, dateRange, cachedData } = storeToRefs(analyticsStore);

// Mock data for charts (in a real app, this would come from the store)
const dailySurgeryData = ref([0.5, 0.7, 0.6, 0.8, 0.9, 0.4, 0.6]);
const orUtilizationData = ref([
  { name: 'OR 1', value: 0.85 },
  { name: 'OR 2', value: 0.72 },
  { name: 'OR 3', value: 0.65 },
  { name: 'OR 4', value: 0.91 },
  { name: 'OR 5', value: 0.78 },
]);
const surgeryTypeData = ref([
  { name: 'CABG', value: 0.35, color: '#007bff', startAngle: 0 },
  { name: 'KNEE', value: 0.25, color: '#28a745', startAngle: 126 },
  { name: 'APPEN', value: 0.15, color: '#ffc107', startAngle: 216 },
  { name: 'HIPRE', value: 0.15, color: '#20c997', startAngle: 270 },
  { name: 'Other', value: 0.10, color: '#6c757d', startAngle: 324 },
]);
const surgeonPerformanceData = ref([
  { name: 'Dr. Smith', value: 0.9, surgeries: 45 },
  { name: 'Dr. Adams', value: 0.75, surgeries: 38 },
  { name: 'Dr. Chen', value: 0.6, surgeries: 30 },
  { name: 'Dr. Wong', value: 0.4, surgeries: 20 },
]);

// Summary metrics
const totalSurgeries = ref(133);
const averageORUtilization = ref(0.78);
const onTimeStartRate = ref(0.82);
const averageTurnaround = ref(24);

// Trend data (would be calculated from historical data)
const surgeryTrend = ref({ value: 12, direction: 'up' });
const utilizationTrend = ref({ value: 5, direction: 'up' });
const onTimeTrend = ref({ value: 3, direction: 'up' });
const turnaroundTrend = ref({ value: 8, direction: 'down' });

// Load analytics data on component mount
onMounted(async () => {
  await loadAnalyticsData();
});

// Load analytics data
const loadAnalyticsData = async () => {
  await analyticsStore.loadAnalyticsData();
  
  // In a real app, we would update the chart data from the store
  // For now, we'll use the mock data
};

// Format date for input element
const formatDateForInput = (date) => {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Format percentage
const formatPercentage = (value) => {
  return `${Math.round(value * 100)}%`;
};

// Update date range
const updateStartDate = (event) => {
  const newDate = new Date(event.target.value);
  if (!isNaN(newDate.getTime())) {
    dateRange.value.start = newDate;
  }
};

const updateEndDate = (event) => {
  const newDate = new Date(event.target.value);
  if (!isNaN(newDate.getTime())) {
    dateRange.value.end = newDate;
  }
};

const applyDateRange = async () => {
  analyticsStore.setDateRange(dateRange.value.start, dateRange.value.end);
  await loadAnalyticsData();
};

// Set quick date range
const setQuickRange = async (range) => {
  const today = new Date();
  let start, end;
  
  switch (range) {
    case 'last7':
      start = new Date(today);
      start.setDate(today.getDate() - 7);
      end = new Date(today);
      break;
    case 'last30':
      start = new Date(today);
      start.setDate(today.getDate() - 30);
      end = new Date(today);
      break;
    case 'thisMonth':
      start = new Date(today.getFullYear(), today.getMonth(), 1);
      end = new Date(today);
      break;
    case 'lastMonth':
      start = new Date(today.getFullYear(), today.getMonth() - 1, 1);
      end = new Date(today.getFullYear(), today.getMonth(), 0);
      break;
    default:
      return;
  }
  
  dateRange.value.start = start;
  dateRange.value.end = end;
  await applyDateRange();
};

// Navigate to detailed reports
const navigateTo = (route) => {
  router.push(`/reporting-analytics/${route}`);
};
</script>

<style scoped>
.analytics-dashboard {
  padding: var(--spacing-md);
  max-width: 1200px;
  margin: 0 auto;
}

h1 {
  margin-bottom: var(--spacing-lg);
}

h3 {
  margin-top: 0;
  margin-bottom: var(--spacing-sm);
  color: var(--color-text);
}

/* Date Range Selector */
.date-range-selector {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  margin-bottom: var(--spacing-lg);
}

.date-inputs {
  display: flex;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-sm);
  align-items: flex-end;
}

.date-input {
  flex: 1;
}

.date-input label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.date-input input {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
}

.apply-button {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
}

.quick-ranges {
  display: flex;
  gap: var(--spacing-sm);
}

.quick-ranges button {
  background-color: var(--color-background-mute);
  border: 1px solid var(--color-border);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-sm);
  cursor: pointer;
}

.quick-ranges button:hover {
  background-color: var(--color-background-hover);
}

/* Loading and Error */
.loading-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(var(--color-primary-rgb), 0.1);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
  margin-bottom: var(--spacing-md);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error-message {
  background-color: rgba(var(--color-error-rgb), 0.1);
  color: var(--color-error);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  text-align: center;
  margin: var(--spacing-lg) 0;
}

.error-message button {
  background-color: var(--color-error);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  margin-top: var(--spacing-sm);
  cursor: pointer;
}

/* Summary Metrics */
.summary-metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.metric-card {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  text-align: center;
}

.metric-value {
  font-size: 2rem;
  font-weight: var(--font-weight-bold);
  margin: var(--spacing-sm) 0;
}

.metric-trend {
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
}

.metric-trend.up {
  color: var(--color-success);
}

.metric-trend.down {
  color: var(--color-error);
}

/* Charts */
.chart-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-lg);
}

.chart-container {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
}

.chart-placeholder {
  height: 300px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

/* Mock charts for demonstration */
.chart-mock {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: flex-end;
  justify-content: space-around;
  padding: var(--spacing-md);
}

.chart-mock.horizontal {
  flex-direction: column;
  align-items: stretch;
  justify-content: space-around;
}

.chart-bar {
  background-color: var(--color-primary);
  width: 30px;
  border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
}

.chart-mock.horizontal .chart-item {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.chart-mock.horizontal .chart-label {
  width: 80px;
  text-align: right;
  margin-right: var(--spacing-sm);
  font-size: var(--font-size-sm);
}

.chart-mock.horizontal .chart-bar-container {
  flex-grow: 1;
  height: 20px;
  background-color: var(--color-background-mute);
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

.chart-mock.horizontal .chart-bar {
  height: 100%;
  width: 0%; /* Will be set dynamically */
}

.chart-mock.horizontal .chart-value {
  width: 80px;
  margin-left: var(--spacing-sm);
  font-size: var(--font-size-sm);
}

.chart-mock.pie {
  position: relative;
  border-radius: 50%;
  width: 200px;
  height: 200px;
  margin: 0 auto;
}

.pie-segment {
  position: absolute;
  width: 100%;
  height: 100%;
  transform-origin: 50% 50%;
}

.pie-legend {
  position: absolute;
  top: 220px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: var(--spacing-sm);
}

.legend-item {
  display: flex;
  align-items: center;
  font-size: var(--font-size-sm);
}

.color-box {
  width: 12px;
  height: 12px;
  margin-right: 4px;
  border-radius: 2px;
}

/* Report Links */
.report-links {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  margin-top: var(--spacing-lg);
}

.report-buttons {
  display: flex;
  gap: var(--spacing-md);
  flex-wrap: wrap;
}

.report-buttons button {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
}

.report-buttons button:hover {
  background-color: var(--color-primary-dark);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .date-inputs {
    flex-direction: column;
    gap: var(--spacing-sm);
  }
  
  .chart-row {
    grid-template-columns: 1fr;
  }
  
  .summary-metrics {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .summary-metrics {
    grid-template-columns: 1fr;
  }
  
  .quick-ranges {
    flex-wrap: wrap;
  }
}
</style>



================================================
FILE: src/components/AppLayout.vue
================================================
<template>
  <div :class="['app-layout', { 'sidebar-collapsed': isSidebarCollapsed }]">
    <header class="top-nav-bar">
      <div class="app-brand">
         <button @click="toggleSidebar" class="icon-button toggle-sidebar-button" aria-label="Toggle Sidebar">
             <!-- Hamburger or arrow icon -->
             <span v-if="isSidebarCollapsed">&#x25BA;</span> <!-- Right arrow -->
             <span v-else>&#x25C4;</span> <!-- Left arrow -->
         </button>
        <!-- App Logo/Name -->
        <img src="/vite.svg" alt="App Logo" class="app-logo-small"> <!-- Assuming vite.svg is in public folder -->
        <span v-if="!isSidebarCollapsed">Surgery Scheduler</span>
      </div>
      <div class="global-search">
        <!-- Global Search Bar -->
        <input type="text" placeholder="Search..." v-model="searchTerm" @input="handleSearch" aria-label="Search">
      </div>
      <div class="user-utilities">
        <!-- Notification Icon -->
        <button class="icon-button" aria-label="Notifications">🔔</button>
        <!-- User Profile Dropdown -->
        <div class="user-profile" aria-haspopup="true" aria-expanded="false"> <!-- Add ARIA for dropdown -->
          <span>{{ authStore.user?.username || 'User Name' }}</span> <!-- Display dynamic username -->
          <!-- Dropdown icon/button here -->
           <span class="user-profile-dropdown-icon">▼</span> <!-- Simple dropdown arrow -->
        </div>
      </div>
    </header>

    <aside class="left-sidebar">
      <!-- Navigation Links -->
      <nav aria-label="Main Navigation">
        <ul>
          <li><router-link to="/dashboard"><span class="nav-icon" aria-hidden="true">🏠</span><span v-if="!isSidebarCollapsed" class="nav-text">Dashboard</span></router-link></li>
          <li><router-link to="/scheduling"><span class="nav-icon" aria-hidden="true">📅</span><span v-if="!isSidebarCollapsed" class="nav-text">Scheduling</span></router-link></li>
          <li><router-link to="/resource-management"><span class="nav-icon" aria-hidden="true">🛠️</span><span v-if="!isSidebarCollapsed" class="nav-text">Resource Management</span></router-link></li>
          <li><router-link to="/sdst-data-management"><span class="nav-icon" aria-hidden="true">📊</span><span v-if="!isSidebarCollapsed" class="nav-text">SDST Data Management</span></router-link></li>
          <li><router-link to="/reporting-analytics"><span class="nav-icon" aria-hidden="true">📈</span><span v-if="!isSidebarCollapsed" class="nav-text">Reporting & Analytics</span></router-link></li>
          <li><router-link to="/notifications"><span class="nav-icon" aria-hidden="true">🔔</span><span v-if="!isSidebarCollapsed" class="nav-text">Notifications</span></router-link></li>
          <li><router-link to="/administration"><span class="nav-icon" aria-hidden="true">⚙️</span><span v-if="!isSidebarCollapsed" class="nav-text">Administration</span></router-link></li>
          <li><router-link to="/patient-management"><span class="nav-icon" aria-hidden="true">👨‍⚕️</span><span v-if="!isSidebarCollapsed" class="nav-text">Patient Management</span></router-link></li>
          <li><router-link to="/my-profile-settings"><span class="nav-icon" aria-hidden="true">👤</span><span v-if="!isSidebarCollapsed" class="nav-text">My Profile / Settings</span></router-link></li>
          <li><router-link to="/help-documentation"><span class="nav-icon" aria-hidden="true">❓</span><span v-if="!isSidebarCollapsed" class="nav-text">Help / Documentation</span></router-link></li>
          <li class="logout-item"><button @click="handleLogout" class="logout-button"><span class="nav-icon" aria-hidden="true">🚪</span><span v-if="!isSidebarCollapsed" class="nav-text">Logout</span></button></li>
        </ul>
      </nav>
    </aside>

    <main class="main-content">
      <!-- Router View renders the specific page component -->
      <router-view />
    </main>
    <!-- Toast notifications are typically triggered programmatically, not placed as a component here -->
    <!-- Toasts will be rendered by the plugin at the root level -->
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
// import { setAuthenticated } from '../router'; // REMOVED
import { useToast } from 'vue-toastification'; // Assuming you use this for notifications

// Import the authentication store
import { useAuthStore } from '@/stores/authStore';
import { storeToRefs } from 'pinia';

const router = useRouter();
const authStore = useAuthStore(); // Get store instance

// Use storeToRefs for reactive state from the store if needed in template directly
const { isAuthenticated, user, isLoading, error } = storeToRefs(authStore);

const isSidebarCollapsed = ref(false); // State for sidebar collapse
const searchTerm = ref(''); // State for global search input

const toggleSidebar = () => {
  isSidebarCollapsed.value = !isSidebarCollapsed.value;
};

const handleLogout = () => {
  console.log('AppLayout: Handling logout click.');
  authStore.logout(); // Call the logout action from the auth store
  // The auth store will handle clearing state and redirecting
};

const handleSearch = () => {
  // Placeholder for actual search logic
  console.log('Searching for:', searchTerm.value);
  // In a real app, this would trigger a search action,
  // potentially navigating to a search results page or filtering data.
};

// Optional: Check auth state on mount to ensure consistency (though router guard should handle initial check)
// onMounted(() => {
//    if (!authStore.isAuthenticated && router.currentRoute.value.meta.requiresAuth) {
//        router.push({ name: 'Login' });
//    }
// });

</script>

<style scoped>
/* Basic Variables (Consider moving to a global CSS file or :root) */
/* These variables should ideally be in a global file like src/style.css */
/* Duplicated here for demonstration, but avoid in production */
:root {
  --color-primary: #4A90E2; /* Example Primary Color */
  --color-primary-dark: #357ABD;
  --color-background: #f4f7f6; /* Light grayish background */
  --color-surface: #ffffff; /* For cards, modals, sidebars */
  --color-text-primary: #333333;
  --color-text-secondary: #555555;
  --color-border: #e0e0e0;
  --sidebar-width: 240px;
  --sidebar-width-collapsed: 60px;
  --top-nav-height: 60px;

  /* Ensure using the variables from src/style.css */
  /* Example: */
  /* --color-primary: var(--color-primary); */
  /* --color-background: var(--color-background); */
  /* etc. */
}

.app-layout {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr; /* Default: Wider Sidebar */
  grid-template-rows: var(--top-nav-height) 1fr; /* Top nav fixed height */
  height: 100vh; /* Full viewport height */
  background-color: var(--color-background);
  overflow: hidden; /* Prevent scrollbars on layout itself */
  transition: grid-template-columns 0.3s ease-in-out; /* Smooth transition for collapse */
}

.app-layout.sidebar-collapsed {
    grid-template-columns: var(--sidebar-width-collapsed) 1fr; /* Collapsed: Narrower Sidebar */
}

.top-nav-bar {
  grid-column: 1 / 3; /* Span across both columns */
  grid-row: 1;
  background-color: var(--color-surface);
  padding: 0 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  z-index: 1000;
  height: var(--top-nav-height);
}

.app-brand {
  display: flex;
  align-items: center;
  font-size: 1.25em;
  font-weight: 600;
  color: var(--color-text-primary);
  overflow: hidden;
}

.toggle-sidebar-button {
    margin-right: 15px;
    font-size: 1.2em;
    padding: 8px;
    background: none;
    border: none;
    color: var(--color-text-secondary);
    cursor: pointer;
    transition: color 0.2s ease, transform 0.3s ease;
}

.toggle-sidebar-button:hover {
    color: var(--color-primary);
}

.app-logo-small {
    height: 32px;
    margin-right: 10px;
    transition: margin-right 0.3s ease-in-out;
}

.app-layout.sidebar-collapsed .app-brand span {
    display: none;
}

.app-layout.sidebar-collapsed .app-logo-small {
     margin-right: 0;
}

.global-search input[type="text"] {
    padding: 9px 15px;
    border: 1px solid var(--color-border);
    border-radius: 18px;
    font-size: 0.9em;
    width: 280px;
    background-color: #f0f2f5;
    color: var(--color-text-primary);
    transition: width 0.3s ease-in-out, background-color 0.2s ease;
}

.global-search input[type="text"]:focus {
    background-color: var(--color-surface);
    border-color: var(--color-primary);
    outline: none;
    box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
}

.user-utilities {
    display: flex;
    align-items: center;
}

.icon-button {
    background: none;
    border: none;
    font-size: 1.4em;
    cursor: pointer;
    margin-left: 15px;
    padding: 8px;
    color: var(--color-text-secondary);
    border-radius: 50%;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.icon-button:hover {
    background-color: #e9ecef;
    color: var(--color-primary);
}

.user-profile {
    display: flex;
    align-items: center;
    cursor: pointer;
    margin-left: 15px;
    padding: 5px 10px;
    border-radius: 15px;
    transition: background-color 0.2s ease;
}

.user-profile:hover {
    background-color: #e9ecef;
}

.user-profile span {
    margin-right: 8px;
    color: var(--color-text-primary);
    font-weight: 500;
    font-size: 0.9em;
}

.user-profile-dropdown-icon {
     font-size: 0.7em;
     color: var(--color-text-secondary);
}


.left-sidebar {
  grid-column: 1;
  grid-row: 2;
  background-color: var(--color-surface);
  padding-top: 15px;
  box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
  overflow-y: auto;
  overflow-x: hidden;
  transition: width 0.3s ease-in-out;
  border-right: 1px solid var(--color-border);
}

.left-sidebar nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.left-sidebar nav li {
  margin-bottom: 2px;
}

.left-sidebar nav a,
.left-sidebar nav .logout-button {
  display: flex;
  align-items: center;
  padding: 12px 20px;
  text-decoration: none;
  color: var(--color-text-secondary);
  font-weight: 500;
  font-size: 0.95em;
  transition: background-color 0.2s ease, color 0.2s ease, padding-left 0.3s ease-in-out;
  white-space: nowrap;
  overflow: hidden;
  border-left: 3px solid transparent;
}

.app-layout.sidebar-collapsed .left-sidebar nav a,
.app-layout.sidebar-collapsed .left-sidebar nav .logout-button {
    padding-left: calc((var(--sidebar-width-collapsed) - 24px - 6px) / 2);
    justify-content: center;
}

.app-layout.sidebar-collapsed .left-sidebar nav .nav-text {
    display: none;
}

.left-sidebar nav a:hover,
.left-sidebar nav .logout-button:hover {
  background-color: #e9ecef;
  color: var(--color-primary);
}

.left-sidebar nav a.router-link-exact-active {
  color: var(--color-primary);
  background-color: #e7f3ff;
  border-left-color: var(--color-primary);
}

.nav-icon {
    margin-right: 12px;
    font-size: 1.2em;
    width: 24px;
    text-align: center;
    transition: margin-right 0.3s ease-in-out;
}

.app-layout.sidebar-collapsed .left-sidebar nav .nav-icon {
    margin-right: 0;
}

.logout-item {
    margin-top: auto;
    padding-top: 20px;
    border-top: 1px solid var(--color-border);
}

.logout-button {
  width: 100%;
  background: none;
  border: none;
  cursor: pointer;
  text-align: left;
   /* Use danger color for the button */
    color: var(--color-danger);
    font-weight: var(--font-weight-medium);
}

.logout-button:hover {
     background-color: #e9ecef; /* Light hover */
     color: var(--color-danger-dark); /* Consider adding a danger-dark variable */
}

.main-content {
  grid-column: 2;
  grid-row: 2;
  padding: 25px;
  overflow-y: auto;
  background-color: var(--color-background);
}

/* Scrollbar styling (optional, for a more polished look) */
.left-sidebar::-webkit-scrollbar,
.main-content::-webkit-scrollbar {
  width: 6px;
}

.left-sidebar::-webkit-scrollbar-thumb,
.main-content::-webkit-scrollbar-thumb {
  background-color: #cccccc;
  border-radius: 3px;
}

.left-sidebar::-webkit-scrollbar-thumb:hover,
.main-content::-webkit-scrollbar-thumb:hover {
  background-color: #aaaaaa;
}

.left-sidebar::-webkit-scrollbar-track,
.main-content::-webkit-scrollbar-track {
  background-color: transparent;
}
</style>



================================================
FILE: src/components/BulkSDSTEditor.vue
================================================
<template>
  <div class="modal-overlay" v-if="show">
    <div class="modal-content bulk-edit-modal" role="dialog" aria-labelledby="bulk-edit-title">
      <h3 id="bulk-edit-title">Bulk Edit SDST Values</h3>
      
      <div class="tabs">
        <button 
          v-for="tab in tabs" 
          :key="tab.id" 
          :class="['tab-button', { active: activeTab === tab.id }]"
          @click="activeTab = tab.id"
        >
          {{ tab.label }}
        </button>
      </div>
      
      <!-- Pattern-based editing -->
      <div v-if="activeTab === 'pattern'" class="tab-content">
        <p class="description">
          Apply a pattern to multiple SDST values at once. This is useful for setting up initial values or making bulk changes.
        </p>
        
        <div class="form-group">
          <label for="pattern-type">Pattern Type:</label>
          <select id="pattern-type" v-model="patternType" class="form-control">
            <option value="fixed">Fixed Value</option>
            <option value="percentage">Percentage Adjustment</option>
            <option value="increment">Increment/Decrement</option>
          </select>
        </div>
        
        <div class="form-group" v-if="patternType === 'fixed'">
          <label for="fixed-value">Set all selected values to:</label>
          <input 
            type="number" 
            id="fixed-value" 
            v-model.number="fixedValue" 
            min="0" 
            max="180"
            class="form-control"
          />
          <span class="input-hint">minutes</span>
        </div>
        
        <div class="form-group" v-if="patternType === 'percentage'">
          <label for="percentage-value">Adjust by percentage:</label>
          <div class="input-with-prefix">
            <select v-model="percentageDirection" class="form-control prefix">
              <option value="increase">Increase by</option>
              <option value="decrease">Decrease by</option>
            </select>
            <input 
              type="number" 
              id="percentage-value" 
              v-model.number="percentageValue" 
              min="1" 
              max="100"
              class="form-control"
            />
            <span class="input-hint">%</span>
          </div>
        </div>
        
        <div class="form-group" v-if="patternType === 'increment'">
          <label for="increment-value">Adjust by fixed amount:</label>
          <div class="input-with-prefix">
            <select v-model="incrementDirection" class="form-control prefix">
              <option value="increase">Increase by</option>
              <option value="decrease">Decrease by</option>
            </select>
            <input 
              type="number" 
              id="increment-value" 
              v-model.number="incrementValue" 
              min="1" 
              max="60"
              class="form-control"
            />
            <span class="input-hint">minutes</span>
          </div>
        </div>
        
        <div class="form-group">
          <label>Apply to:</label>
          <div class="checkbox-group">
            <label class="checkbox-label">
              <input type="checkbox" v-model="applyToAll" @change="handleApplyToAllChange" />
              All SDST values
            </label>
            <label class="checkbox-label" v-if="!applyToAll">
              <input type="checkbox" v-model="applyToLow" />
              Low values (≤ 15 min)
            </label>
            <label class="checkbox-label" v-if="!applyToAll">
              <input type="checkbox" v-model="applyToMedium" />
              Medium values (16-30 min)
            </label>
            <label class="checkbox-label" v-if="!applyToAll">
              <input type="checkbox" v-model="applyToHigh" />
              High values (> 30 min)
            </label>
          </div>
        </div>
      </div>
      
      <!-- CSV Import/Export -->
      <div v-if="activeTab === 'csv'" class="tab-content">
        <p class="description">
          Import or export SDST values as CSV for editing in spreadsheet software.
        </p>
        
        <div class="action-buttons">
          <button class="btn btn-secondary" @click="exportCSV">
            <span class="icon">📤</span> Export as CSV
          </button>
          <button class="btn btn-primary" @click="triggerFileInput">
            <span class="icon">📥</span> Import from CSV
          </button>
          <input 
            type="file" 
            ref="fileInput" 
            accept=".csv" 
            style="display: none;" 
            @change="handleFileUpload"
          />
        </div>
        
        <div class="csv-format-info">
          <h4>CSV Format</h4>
          <p>The CSV file should have the following format:</p>
          <pre>FromType,ToType,Minutes
CABG,KNEE,30
CABG,APPEN,45
...</pre>
          <p>The first row is a header row. Each subsequent row represents one SDST value.</p>
        </div>
      </div>
      
      <div class="preview-section" v-if="activeTab === 'pattern' && hasSelection">
        <h4>Preview of Changes</h4>
        <p>{{ getPreviewText() }}</p>
        <div class="affected-count">
          {{ getAffectedCount() }} values will be affected
        </div>
      </div>
      
      <div class="modal-actions">
        <button class="btn btn-secondary" @click="cancel">Cancel</button>
        <button 
          class="btn btn-primary" 
          @click="applyChanges"
          :disabled="!isValid"
        >
          Apply Changes
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';

const props = defineProps({
  show: Boolean
});

const emit = defineEmits(['close', 'update']);

const store = useScheduleStore();

// Tabs
const tabs = [
  { id: 'pattern', label: 'Pattern-based Editing' },
  { id: 'csv', label: 'CSV Import/Export' }
];
const activeTab = ref('pattern');

// Pattern-based editing
const patternType = ref('fixed');
const fixedValue = ref(30);
const percentageDirection = ref('increase');
const percentageValue = ref(10);
const incrementDirection = ref('increase');
const incrementValue = ref(5);
const applyToAll = ref(true);
const applyToLow = ref(false);
const applyToMedium = ref(false);
const applyToHigh = ref(false);

// File input reference
const fileInput = ref(null);

// Handle apply to all checkbox
const handleApplyToAllChange = () => {
  if (applyToAll.value) {
    applyToLow.value = false;
    applyToMedium.value = false;
    applyToHigh.value = false;
  }
};

// Watch individual category checkboxes
watch([applyToLow, applyToMedium, applyToHigh], ([newLow, newMedium, newHigh]) => {
  if (newLow || newMedium || newHigh) {
    applyToAll.value = false;
  }
});

// Computed property to check if any selection is made
const hasSelection = computed(() => {
  return applyToAll.value || applyToLow.value || applyToMedium.value || applyToHigh.value;
});

// Computed property to check if the form is valid
const isValid = computed(() => {
  if (activeTab.value === 'pattern') {
    return hasSelection.value;
  }
  return true;
});

// Get preview text based on current settings
const getPreviewText = () => {
  if (patternType.value === 'fixed') {
    return `Set selected SDST values to ${fixedValue.value} minutes`;
  } else if (patternType.value === 'percentage') {
    return `${percentageDirection.value === 'increase' ? 'Increase' : 'Decrease'} selected SDST values by ${percentageValue.value}%`;
  } else if (patternType.value === 'increment') {
    return `${incrementDirection.value === 'increase' ? 'Increase' : 'Decrease'} selected SDST values by ${incrementValue.value} minutes`;
  }
  return '';
};

// Get count of affected values
const getAffectedCount = () => {
  let count = 0;
  const surgeryTypes = Object.keys(store.surgeryTypes);
  
  for (const fromType of surgeryTypes) {
    for (const toType of surgeryTypes) {
      if (fromType === toType) continue; // Skip same type
      
      const value = store.sdsRules[fromType]?.[toType];
      if (value === undefined) continue;
      
      if (applyToAll.value || 
          (applyToLow.value && value <= 15) ||
          (applyToMedium.value && value > 15 && value <= 30) ||
          (applyToHigh.value && value > 30)) {
        count++;
      }
    }
  }
  
  return count;
};

// Apply the pattern changes
const applyChanges = () => {
  if (activeTab.value === 'pattern') {
    applyPatternChanges();
  }
  emit('update');
  emit('close');
};

// Apply pattern-based changes
const applyPatternChanges = () => {
  const surgeryTypes = Object.keys(store.surgeryTypes);
  
  for (const fromType of surgeryTypes) {
    for (const toType of surgeryTypes) {
      if (fromType === toType) continue; // Skip same type
      
      const currentValue = store.sdsRules[fromType]?.[toType];
      if (currentValue === undefined) continue;
      
      // Check if this value should be updated
      if (applyToAll.value || 
          (applyToLow.value && currentValue <= 15) ||
          (applyToMedium.value && currentValue > 15 && currentValue <= 30) ||
          (applyToHigh.value && currentValue > 30)) {
        
        let newValue = currentValue;
        
        // Calculate new value based on pattern type
        if (patternType.value === 'fixed') {
          newValue = fixedValue.value;
        } else if (patternType.value === 'percentage') {
          if (percentageDirection.value === 'increase') {
            newValue = Math.round(currentValue * (1 + percentageValue.value / 100));
          } else {
            newValue = Math.round(currentValue * (1 - percentageValue.value / 100));
          }
        } else if (patternType.value === 'increment') {
          if (incrementDirection.value === 'increase') {
            newValue = currentValue + incrementValue.value;
          } else {
            newValue = Math.max(0, currentValue - incrementValue.value);
          }
        }
        
        // Update the value in the store
        store.updateSDSTValue(fromType, toType, newValue);
      }
    }
  }
};

// Trigger file input click
const triggerFileInput = () => {
  fileInput.value.click();
};

// Handle file upload
const handleFileUpload = (event) => {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (e) => {
    const contents = e.target.result;
    processCSV(contents);
  };
  reader.readAsText(file);
};

// Process CSV data
const processCSV = (csvData) => {
  const lines = csvData.split('\n');
  const headers = lines[0].split(',');
  
  // Validate headers
  if (headers.length < 3 || 
      !headers.includes('FromType') || 
      !headers.includes('ToType') || 
      !headers.includes('Minutes')) {
    alert('Invalid CSV format. Please ensure the CSV has FromType, ToType, and Minutes columns.');
    return;
  }
  
  const fromIndex = headers.indexOf('FromType');
  const toIndex = headers.indexOf('ToType');
  const minutesIndex = headers.indexOf('Minutes');
  
  let updatedCount = 0;
  
  // Process data rows
  for (let i = 1; i < lines.length; i++) {
    if (!lines[i].trim()) continue;
    
    const values = lines[i].split(',');
    if (values.length < 3) continue;
    
    const fromType = values[fromIndex].trim();
    const toType = values[toIndex].trim();
    const minutes = parseInt(values[minutesIndex].trim(), 10);
    
    if (isNaN(minutes) || minutes < 0) continue;
    
    // Update the value in the store
    if (store.surgeryTypes[fromType] && store.surgeryTypes[toType] && fromType !== toType) {
      store.updateSDSTValue(fromType, toType, minutes);
      updatedCount++;
    }
  }
  
  alert(`Successfully updated ${updatedCount} SDST values.`);
  emit('update');
  emit('close');
};

// Export to CSV
const exportCSV = () => {
  const surgeryTypes = Object.keys(store.surgeryTypes);
  let csvContent = 'FromType,ToType,Minutes\n';
  
  for (const fromType of surgeryTypes) {
    for (const toType of surgeryTypes) {
      if (fromType === toType) continue; // Skip same type
      
      const value = store.sdsRules[fromType]?.[toType];
      if (value !== undefined) {
        csvContent += `${fromType},${toType},${value}\n`;
      }
    }
  }
  
  // Create a download link
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', 'sdst_values.csv');
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Cancel and close
const cancel = () => {
  emit('close');
};
</script>

<style scoped>
.bulk-edit-modal {
  width: 600px;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
}

.tabs {
  display: flex;
  border-bottom: 1px solid var(--color-border);
  margin-bottom: var(--spacing-md);
}

.tab-button {
  padding: var(--spacing-sm) var(--spacing-md);
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  cursor: pointer;
  font-weight: var(--font-weight-medium);
  color: var(--color-text-secondary);
}

.tab-button.active {
  color: var(--color-primary);
  border-bottom-color: var(--color-primary);
}

.tab-content {
  margin-bottom: var(--spacing-md);
}

.description {
  margin-bottom: var(--spacing-md);
  color: var(--color-text-secondary);
}

.input-with-prefix {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.prefix {
  width: 130px;
  flex-shrink: 0;
}

.input-hint {
  margin-left: var(--spacing-xs);
  color: var(--color-text-secondary);
}

.checkbox-group {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
  margin-top: var(--spacing-xs);
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  cursor: pointer;
}

.preview-section {
  margin-top: var(--spacing-md);
  padding: var(--spacing-md);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--color-border);
}

.affected-count {
  margin-top: var(--spacing-sm);
  font-weight: var(--font-weight-bold);
  color: var(--color-primary);
}

.action-buttons {
  display: flex;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-md);
}

.icon {
  margin-right: var(--spacing-xs);
}

.csv-format-info {
  margin-top: var(--spacing-md);
  padding: var(--spacing-md);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--color-border);
}

pre {
  background-color: var(--color-background);
  padding: var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  overflow-x: auto;
  font-family: monospace;
  margin: var(--spacing-sm) 0;
}

@media (max-width: 768px) {
  .action-buttons {
    flex-direction: column;
  }
  
  .input-with-prefix {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .prefix {
    width: 100%;
  }
}
</style>



================================================
FILE: src/components/ConfirmationModal.vue
================================================
<template>
  <div class="modal-overlay" v-if="show" @click.self="handleCancel">
    <div class="modal-content">
      <h3>{{ title || 'Confirm Action' }}</h3>
      <div class="modal-body">
        <p>{{ message || 'Are you sure you want to perform this action?' }}</p>
      </div>
      
      <div class="form-actions">
        <button type="button" class="button-danger" @click="handleConfirm">Confirm</button>
        <button type="button" class="button-secondary" @click="handleCancel">Cancel</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue';

const props = defineProps({
  show: { type: Boolean, default: false }, // Added show prop
  title: { type: String, default: 'Confirm Action' },
  message: { type: String, default: 'Are you sure you want to perform this action?' },
});

const emit = defineEmits(['confirm', 'cancel']);

const handleConfirm = () => {
  emit('confirm');
};

const handleCancel = () => {
  emit('cancel');
};
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000; /* Ensure it's above other modals */
}

.modal-content {
  background-color: var(--color-white);
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
  max-width: 400px; /* Smaller modal for confirmation */
  width: 90%;
  text-align: center; /* Center content */
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 15px;
  color: var(--color-very-dark-gray);
  font-size: 1.4em;
}

.modal-body p {
    font-size: 1em;
    color: var(--color-dark-gray);
    margin-bottom: 20px;
    line-height: 1.5;
}

.form-actions {
  margin-top: 20px;
  display: flex;
  justify-content: center; /* Center buttons */
  gap: 15px; /* Space between buttons */
}

.form-actions button {
    padding: 10px 20px;
    font-size: 1em;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.25s ease, border-color 0.25s ease, color 0.25s ease;
    border: none;
}

.button-danger {
    background-color: var(--color-danger);
    color: var(--color-white);
}

.button-danger:hover {
    background-color: #c82333; /* Darker red */
}

.button-secondary {
     background-color: var(--color-secondary);
     color: var(--color-white);
}

.button-secondary:hover {
     background-color: #5a6268;
}

</style>



================================================
FILE: src/components/CustomReportBuilder.vue
================================================
<template>
  <div class="custom-report-builder">
    <h1>Custom Report Builder</h1>
    
    <div class="report-builder-container">
      <!-- Report Configuration Form -->
      <div class="report-config-form">
        <h2>Report Configuration</h2>
        
        <div class="form-group">
          <label for="report-name">Report Name</label>
          <input 
            type="text" 
            id="report-name" 
            v-model="reportConfig.name" 
            placeholder="Enter a name for your report"
          >
        </div>
        
        <div class="form-group">
          <label for="report-type">Report Type</label>
          <select id="report-type" v-model="reportConfig.type">
            <option value="orUtilization">OR Utilization</option>
            <option value="surgeonUtilization">Surgeon Utilization</option>
            <option value="surgeryTypeDistribution">Surgery Type Distribution</option>
            <option value="sdstEfficiency">SDST Efficiency</option>
            <option value="dailyMetrics">Daily Metrics</option>
          </select>
        </div>
        
        <div class="form-group">
          <label>Date Range</label>
          <div class="date-range-inputs">
            <div class="date-input">
              <label for="start-date">Start Date</label>
              <input 
                type="date" 
                id="start-date" 
                v-model="reportConfig.dateRange.start"
              >
            </div>
            <div class="date-input">
              <label for="end-date">End Date</label>
              <input 
                type="date" 
                id="end-date" 
                v-model="reportConfig.dateRange.end"
              >
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Metrics to Include</label>
          <div class="metrics-selection">
            <div v-if="reportConfig.type === 'orUtilization'" class="checkbox-group">
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="utilizationRate">
                Utilization Rate
              </label>
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="idleTime">
                Idle Time
              </label>
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="overtimeRate">
                Overtime Rate
              </label>
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="surgeryCount">
                Surgery Count
              </label>
            </div>
            
            <div v-else-if="reportConfig.type === 'surgeonUtilization'" class="checkbox-group">
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="surgeryCount">
                Surgery Count
              </label>
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="totalHours">
                Total Hours
              </label>
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="averageDuration">
                Average Duration
              </label>
              <label>
                <input type="checkbox" v-model="reportConfig.metrics" value="onTimeStart">
                On-Time Start %
              </label>
            </div>
            
            <!-- Other metric options for different report types would go here -->
            <div v-else class="checkbox-group">
              <p>Select a report type to see available metrics</p>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="chart-type">Chart Type</label>
          <select id="chart-type" v-model="reportConfig.chartType">
            <option value="bar">Bar Chart</option>
            <option value="line">Line Chart</option>
            <option value="pie">Pie Chart</option>
            <option value="table">Table Only</option>
          </select>
        </div>
        
        <div class="form-actions">
          <button class="secondary-button" @click="resetForm">Reset</button>
          <button class="primary-button" @click="generateReport" :disabled="!isFormValid">Generate Report</button>
        </div>
      </div>
      
      <!-- Report Preview -->
      <div class="report-preview">
        <h2>Report Preview</h2>
        
        <div v-if="isLoading" class="loading-overlay">
          <div class="spinner"></div>
          <p>Generating report preview...</p>
        </div>
        
        <div v-else-if="!reportGenerated" class="empty-preview">
          <p>Configure your report and click "Generate Report" to see a preview</p>
        </div>
        
        <div v-else class="preview-content">
          <h3>{{ reportConfig.name }}</h3>
          
          <!-- Chart Preview -->
          <div class="chart-preview">
            <div class="chart-placeholder">
              <div class="chart-mock" :class="reportConfig.chartType">
                <!-- Mock chart content based on chartType -->
                <template v-if="reportConfig.chartType === 'bar'">
                  <div 
                    v-for="(item, index) in previewData" 
                    :key="index" 
                    class="chart-bar" 
                    :style="{ height: `${item.value * 100}%` }"
                  >
                    <div class="bar-label">{{ item.label }}</div>
                  </div>
                </template>
              </div>
            </div>
          </div>
          
          <!-- Table Preview -->
          <div class="table-preview">
            <table>
              <thead>
                <tr>
                  <th>Resource</th>
                  <th v-for="metric in reportConfig.metrics" :key="metric">
                    {{ formatMetricName(metric) }}
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(item, index) in previewData" :key="index">
                  <td>{{ item.label }}</td>
                  <td v-for="metric in reportConfig.metrics" :key="`${index}-${metric}`">
                    {{ formatMetricValue(item[metric], metric) }}
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <div class="preview-actions">
            <button class="secondary-button" @click="saveReport">Save Report</button>
            <button class="primary-button" @click="exportReport">Export Report</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Saved Reports Section -->
    <div class="saved-reports">
      <h2>Saved Reports</h2>
      
      <div v-if="savedReports.length === 0" class="no-saved-reports">
        <p>You haven't saved any custom reports yet</p>
      </div>
      
      <div v-else class="saved-reports-list">
        <div v-for="report in savedReports" :key="report.id" class="saved-report-card">
          <div class="report-info">
            <h3>{{ report.name }}</h3>
            <p>{{ getReportTypeLabel(report.type) }}</p>
            <p class="date-range">{{ formatDateRange(report.dateRange) }}</p>
          </div>
          <div class="report-actions">
            <button class="icon-button" @click="loadReport(report)">
              <span class="icon">📋</span>
              <span class="label">Load</span>
            </button>
            <button class="icon-button" @click="deleteReport(report.id)">
              <span class="icon">🗑️</span>
              <span class="label">Delete</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useAnalyticsStore } from '@/stores/analyticsStore';
import { storeToRefs } from 'pinia';

const analyticsStore = useAnalyticsStore();
const { isLoading, savedReports } = storeToRefs(analyticsStore);

// Report configuration state
const reportConfig = ref({
  name: '',
  type: '',
  dateRange: {
    start: new Date(new Date().setDate(new Date().getDate() - 30)).toISOString().split('T')[0],
    end: new Date().toISOString().split('T')[0]
  },
  metrics: [],
  chartType: 'bar'
});

// Preview data state
const reportGenerated = ref(false);
const previewData = ref([]);

// Computed properties
const isFormValid = computed(() => {
  return (
    reportConfig.value.name.trim() !== '' &&
    reportConfig.value.type !== '' &&
    reportConfig.value.metrics.length > 0
  );
});

// Methods
const resetForm = () => {
  reportConfig.value = {
    name: '',
    type: '',
    dateRange: {
      start: new Date(new Date().setDate(new Date().getDate() - 30)).toISOString().split('T')[0],
      end: new Date().toISOString().split('T')[0]
    },
    metrics: [],
    chartType: 'bar'
  };
  reportGenerated.value = false;
};

const generateReport = async () => {
  if (!isFormValid.value) return;
  
  isLoading.value = true;
  
  try {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Generate mock preview data based on report type
    if (reportConfig.value.type === 'orUtilization') {
      previewData.value = [
        { label: 'OR 1', utilizationRate: 0.85, idleTime: 1.2, overtimeRate: 0.0, surgeryCount: 12 },
        { label: 'OR 2', utilizationRate: 0.72, idleTime: 2.2, overtimeRate: 0.0, surgeryCount: 8 },
        { label: 'OR 3', utilizationRate: 0.65, idleTime: 2.8, overtimeRate: 0.0, surgeryCount: 6 },
        { label: 'OR 4', utilizationRate: 0.91, idleTime: 0.7, overtimeRate: 0.0, surgeryCount: 14 },
        { label: 'OR 5', utilizationRate: 0.78, idleTime: 1.8, overtimeRate: 0.0, surgeryCount: 10 },
      ];
    } else if (reportConfig.value.type === 'surgeonUtilization') {
      previewData.value = [
        { label: 'Dr. Smith', surgeryCount: 45, totalHours: 90, averageDuration: 120, onTimeStart: 0.9, value: 0.9 },
        { label: 'Dr. Adams', surgeryCount: 38, totalHours: 76, averageDuration: 120, onTimeStart: 0.85, value: 0.75 },
        { label: 'Dr. Chen', surgeryCount: 30, totalHours: 45, averageDuration: 90, onTimeStart: 0.8, value: 0.6 },
        { label: 'Dr. Wong', surgeryCount: 20, totalHours: 30, averageDuration: 90, onTimeStart: 0.75, value: 0.4 },
      ];
    }
    
    // Set value property for chart visualization
    previewData.value.forEach(item => {
      if (!item.value) {
        // Default to first metric if value not set
        const firstMetric = reportConfig.value.metrics[0];
        item.value = item[firstMetric] || 0.5;
      }
    });
    
    reportGenerated.value = true;
  } catch (error) {
    console.error('Error generating report:', error);
  } finally {
    isLoading.value = false;
  }
};

const saveReport = async () => {
  if (!reportGenerated.value) return;
  
  try {
    const reportId = await analyticsStore.saveCustomReport({
      name: reportConfig.value.name,
      type: reportConfig.value.type,
      dateRange: {
        start: new Date(reportConfig.value.dateRange.start),
        end: new Date(reportConfig.value.dateRange.end)
      },
      metrics: [...reportConfig.value.metrics],
      chartType: reportConfig.value.chartType
    });
    
    console.log('Report saved with ID:', reportId);
    alert('Report saved successfully!');
  } catch (error) {
    console.error('Error saving report:', error);
    alert('Failed to save report. Please try again.');
  }
};

const exportReport = () => {
  if (!reportGenerated.value) return;
  
  console.log('Exporting report:', reportConfig.value);
  alert('Report export functionality will be implemented in the next phase.');
};

const loadReport = (report) => {
  reportConfig.value = {
    name: report.name,
    type: report.type,
    dateRange: {
      start: new Date(report.dateRange.start).toISOString().split('T')[0],
      end: new Date(report.dateRange.end).toISOString().split('T')[0]
    },
    metrics: [...report.metrics],
    chartType: report.chartType
  };
  
  generateReport();
};

const deleteReport = async (reportId) => {
  if (confirm('Are you sure you want to delete this report?')) {
    await analyticsStore.deleteCustomReport(reportId);
    console.log('Report deleted:', reportId);
  }
};

const formatMetricName = (metric) => {
  switch (metric) {
    case 'utilizationRate': return 'Utilization Rate';
    case 'idleTime': return 'Idle Time (hrs)';
    case 'overtimeRate': return 'Overtime Rate';
    case 'surgeryCount': return 'Surgery Count';
    case 'totalHours': return 'Total Hours';
    case 'averageDuration': return 'Avg. Duration (min)';
    case 'onTimeStart': return 'On-Time Start %';
    default: return metric;
  }
};

const formatMetricValue = (value, metric) => {
  if (value === undefined) return 'N/A';
  
  switch (metric) {
    case 'utilizationRate':
    case 'overtimeRate':
    case 'onTimeStart':
      return `${Math.round(value * 100)}%`;
    case 'idleTime':
    case 'totalHours':
      return value.toFixed(1);
    case 'averageDuration':
      return `${Math.round(value)} min`;
    default:
      return value;
  }
};

const getReportTypeLabel = (type) => {
  switch (type) {
    case 'orUtilization': return 'OR Utilization';
    case 'surgeonUtilization': return 'Surgeon Utilization';
    case 'surgeryTypeDistribution': return 'Surgery Type Distribution';
    case 'sdstEfficiency': return 'SDST Efficiency';
    case 'dailyMetrics': return 'Daily Metrics';
    default: return type;
  }
};

const formatDateRange = (dateRange) => {
  const start = new Date(dateRange.start);
  const end = new Date(dateRange.end);
  
  return `${start.toLocaleDateString()} - ${end.toLocaleDateString()}`;
};

// Initialize the component
onMounted(() => {
  // Nothing to do on mount for now
});
</script>

<style scoped>
.custom-report-builder {
  padding: var(--spacing-md);
  max-width: 1200px;
  margin: 0 auto;
}

h1, h2, h3 {
  margin-top: 0;
  color: var(--color-text);
}

h1 {
  margin-bottom: var(--spacing-lg);
}

h2 {
  margin-bottom: var(--spacing-md);
}

h3 {
  margin-bottom: var(--spacing-sm);
}

/* Report Builder Container */
.report-builder-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-xl);
}

/* Form Styles */
.report-config-form {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
}

.form-group {
  margin-bottom: var(--spacing-md);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: var(--font-weight-medium);
}

input[type="text"],
select {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  background-color: var(--color-background);
}

.date-range-inputs {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-sm);
}

.date-input label {
  font-weight: var(--font-weight-normal);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.checkbox-group {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.checkbox-group label {
  display: flex;
  align-items: center;
  font-weight: var(--font-weight-normal);
  cursor: pointer;
}

.checkbox-group input[type="checkbox"] {
  margin-right: var(--spacing-xs);
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-lg);
}

.primary-button,
.secondary-button {
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  border: none;
  cursor: pointer;
}

.primary-button {
  background-color: var(--color-primary);
  color: white;
}

.primary-button:disabled {
  background-color: var(--color-background-mute);
  color: var(--color-text-secondary);
  cursor: not-allowed;
}

.secondary-button {
  background-color: var(--color-background-mute);
  color: var(--color-text);
}

/* Report Preview */
.report-preview {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
}

.empty-preview {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 300px;
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  color: var(--color-text-secondary);
  text-align: center;
  padding: var(--spacing-md);
}

.loading-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 300px;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(var(--color-primary-rgb), 0.1);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
  margin-bottom: var(--spacing-md);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.preview-content h3 {
  text-align: center;
  margin-bottom: var(--spacing-md);
}

.chart-preview {
  margin-bottom: var(--spacing-md);
}

.chart-placeholder {
  height: 300px;
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

/* Mock charts for demonstration */
.chart-mock {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: flex-end;
  justify-content: space-around;
  padding: var(--spacing-md);
}

.chart-bar {
  background-color: var(--color-primary);
  width: 60px;
  border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
  position: relative;
}

.bar-label {
  position: absolute;
  bottom: -25px;
  left: 0;
  right: 0;
  text-align: center;
  font-size: var(--font-size-sm);
}

.table-preview {
  margin-bottom: var(--spacing-md);
  overflow-x: auto;
}

.table-preview table {
  width: 100%;
  border-collapse: collapse;
}

.table-preview th,
.table-preview td {
  padding: var(--spacing-sm);
  text-align: left;
  border-bottom: 1px solid var(--color-border);
}

.table-preview th {
  background-color: var(--color-background-mute);
  font-weight: var(--font-weight-bold);
}

.preview-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
}

/* Saved Reports */
.saved-reports {
  margin-top: var(--spacing-xl);
}

.no-saved-reports {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  text-align: center;
  color: var(--color-text-secondary);
}

.saved-reports-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: var(--spacing-md);
}

.saved-report-card {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  display: flex;
  flex-direction: column;
}

.report-info {
  flex-grow: 1;
}

.report-info h3 {
  margin-bottom: var(--spacing-xs);
}

.report-info p {
  margin: 0 0 var(--spacing-xs) 0;
  color: var(--color-text-secondary);
}

.date-range {
  font-size: var(--font-size-sm);
}

.report-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

.icon-button {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
}

.icon-button:hover {
  background-color: var(--color-background-hover);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .report-builder-container {
    grid-template-columns: 1fr;
  }
  
  .date-range-inputs {
    grid-template-columns: 1fr;
  }
}
</style>



================================================
FILE: src/components/DashboardScreen.vue
================================================
<template>
  <div class="dashboard-container">
    <h1>Welcome, {{ authStore.user?.username || 'User' }}!</h1>

    <div v-if="scheduleStore.isLoading" class="loading-message">
      Loading dashboard data...
    </div>

    <div v-else class="dashboard-widgets">
      <!-- Quick Actions Widget -->
      <div class="widget quick-actions-widget">
        <h2>Quick Actions</h2>
        <div class="quick-action-buttons">
          <button @click="scheduleNewSurgery">Schedule New Elective Surgery</button>
          <button class="btn btn-secondary" @click="addEmergencyCase">Add Emergency Case</button>
          <button @click="goToMasterSchedule">Go to Master Schedule</button>
          <button @click="manageResources">Manage Resources</button>
          <button class="btn btn-secondary" @click="runOptimization">Run Optimization</button>
        </div>
      </div>

      <!-- Key Performance Indicators (KPIs) Widget -->
      <div class="widget kpis-widget">
        <h2>Key Performance Indicators</h2>
        <div class="kpi-list">
          <!-- KPIs will likely come from the scheduleStore or a dedicated reporting store later -->
          <div class="kpi-item" @click="navigateToReport('OR Utilization')">
            <span class="kpi-label">OR Utilization (Today):</span>
            <!-- Using simulated data for now -->
            <span class="kpi-value">{{ orUtilizationToday }}%</span>
          </div>
          <div class="kpi-item" @click="navigateToReport('Avg. SDST')">
            <span class="kpi-label">Avg. SDST (Today):</span>
             <!-- Using simulated data for now -->
            <span class="kpi-value">{{ avgSdstToday }} min</span>
          </div>
          <div class="kpi-item" @click="navigateToReport('Emergency Cases')">
            <span class="kpi-label">Emergency Cases (Today):</span>
             <!-- Using simulated data for now -->
            <span class="kpi-value">{{ emergencyCasesToday }}</span>
          </div>
          <div class="kpi-item" @click="navigateToReport('Cancelled Surgeries')">
            <span class="kpi-label">Cancelled Surgeries (Today):</span>
             <!-- Using simulated data for now -->
            <span class="kpi-value">{{ cancelledSurgeriesToday }}</span>
          </div>
        </div>
        <!-- Placeholder for charts/visualizations -->
        <p><em>(Placeholder for KPI charts/visualizations)</em></p>
      </div>

      <!-- Today's OR Schedule Overview Widget -->
      <div class="widget schedule-overview-widget">
        <h2>Today's OR Schedule Overview</h2>
        <!-- Display a snippet of today's scheduled surgeries from the store -->
        <ul v-if="todayScheduleSnippet.length > 0" class="schedule-list">
           <li v-for="surgery in todayScheduleSnippet" :key="surgery.id">
              {{ formatTime(surgery.startTime) }} - OR {{ surgery.orName }}: {{ surgery.patientName }} - {{ surgery.type }}
              <span v-if="surgery.conflicts && surgery.conflicts.length > 0" class="schedule-item-conflict">⚠️</span>
           </li>
        </ul>
        <p v-else class="no-items">No surgeries scheduled for today in the current view.</p>
        <p>Provides at-a-glance view of today's operations across all ORs.</p>
      </div>

      <!-- Critical Resource Alerts Widget -->
      <div class="widget alerts-widget">
        <h2>Critical Resource Alerts</h2>
        <!-- Alerts would ideally come from a dedicated alerts store or the schedule store's processed data -->
        <ul>
          <li v-for="alert in criticalAlerts" :key="alert.id" class="alert-item" @click="handleAlertClick(alert)">{{ alert.message }}</li>
          <li v-if="criticalAlerts.length === 0" class="no-items">No critical alerts</li>
        </ul>
      </div>

      <!-- SDST Conflict Summary Widget -->
      <div class="widget sdst-conflicts-widget">
        <h2>SDST Conflict Summary</h2>
        <!-- SDST Conflicts come from the scheduleStore's processed data -->
        <ul>
          <li v-for="conflict in sdstConflictsFromStore" :key="conflict.id" class="conflict-item" @click="handleConflictClick(conflict)">{{ conflict.message }}</li>
          <li v-if="sdstConflictsFromStore.length === 0" class="no-items">No SDST conflicts</li>
        </ul>
      </div>

      <!-- Conflict Details Display Area - Might be a modal or separate view later -->
      <div v-if="selectedConflict" class="widget conflict-details-widget">
        <h2>Conflict Details</h2>
        <p>Conflict details will be displayed here.</p>
        <p>Selected Conflict: {{ selectedConflict.message }}</p>

        <!-- Conflict Resolution Actions -->
        <div class="conflict-actions">
            <button @click="viewConflictingSurgeries">View Conflicting Surgeries</button>
            <button class="btn btn-secondary" @click="ignoreConflict">Ignore Conflict</button>
        </div>
      </div>

      <!-- Pending Surgeries Queue Widget -->
      <div class="widget pending-surgeries-widget">
        <h2>Pending Surgeries Queue</h2>
        <!-- Display pending surgeries from the store -->
        <ul class="pending-surgeries-list">
          <li v-for="surgery in pendingSurgeriesFromStore" :key="surgery.id" class="pending-surgery-item" @click="handlePendingSurgeryClick(surgery)">{{ surgery.patientName }} - {{ surgery.type }} ({{ surgery.estimatedDuration }} min)</li>
          <li v-if="pendingSurgeriesFromStore.length === 0" class="no-items">No pending surgeries</li>
        </ul>
        <p>Sortable list of surgeries awaiting scheduling.</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '@/stores/authStore';
import { useScheduleStore } from '@/stores/scheduleStore';
import { storeToRefs } from 'pinia';

const router = useRouter();
const authStore = useAuthStore();
const scheduleStore = useScheduleStore();

// Use storeToRefs to get reactive state and getters from stores
const { user } = storeToRefs(authStore);
const { visibleScheduledSurgeries, pendingSurgeries } = storeToRefs(scheduleStore);

// Local state for the dashboard component
// const isLoading = ref(true); // Use scheduleStore.isLoading instead
const selectedConflict = ref(null); // State to hold selected conflict details for the details widget

// Simulated data for KPIs (replace with data from stores/APIs later)
const orUtilizationToday = ref(85);
const avgSdstToday = ref(30);
const emergencyCasesToday = ref(2);
const cancelledSurgeriesToday = ref(1);

// Simulated data for other widgets (replace with data from stores later)
const criticalAlerts = ref([
  { id: 1, message: 'OR 3: A/C Maintenance Overdue' },
  { id: 2, message: 'Anesthesia Machine X: Unavailable' },
]);

// Computed property to get SDST conflicts from the schedule store
const sdstConflictsFromStore = computed(() => {
    // Assuming conflicts array on surgery objects includes SDST violations
    const conflicts = [];
    scheduleStore.scheduledSurgeries.forEach(surgery => {
        if (surgery.conflicts && surgery.conflicts.length > 0) {
            surgery.conflicts.forEach(conflictMsg => {
                if (conflictMsg.includes('SDST')) { // Filter for SDST specific conflicts (simple check)
                    conflicts.push({ id: surgery.id + conflictMsg.slice(0, 10), message: `${surgery.patientName} (${surgery.type}): ${conflictMsg}` });
                }
            });
        }
    });
    return conflicts;
});

// Computed property to get pending surgeries from the store
const pendingSurgeriesFromStore = computed(() => {
    return pendingSurgeries.value; // Direct use of storeToRefs ref
});

// Computed property for a snippet of today's schedule (e.g., first few surgeries or key ones)
const todayScheduleSnippet = computed(() => {
    // For a dashboard snippet, we might just show a limited number
    // Or filter for high priority/upcoming ones.
    // Let's show the first 5 surgeries from the visible scheduled list for OR1 and OR2 as an example
    const snippet = [];
    const orsToShow = ['OR1', 'OR2']; // Example: show schedule for key ORs

    orsToShow.forEach(orId => {
         const surgeriesInOR = scheduleStore.getSurgeriesForOR(orId);
         // Add a header or separator for each OR in the snippet if desired
        // snippet.push({ id: 'or-header-' + orId, isHeader: true, name: scheduleStore.operatingRooms.find(o => o.id === orId)?.name || orId });
         snippet.push(...surgeriesInOR.slice(0, 3)); // Take first 3 from each OR
    });

    // Sort the final snippet by time if combining from multiple ORs
    snippet.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

    return snippet.slice(0, 10); // Limit total snippet size
});


// --- Quick Action Button Handlers ---
const scheduleNewSurgery = () => {
  console.log('Navigate to Schedule New Surgery form');
  // Assuming a route named 'CreateSurgeryForm' or similar
  // router.push({ name: 'CreateSurgeryForm' });
};

const addEmergencyCase = () => {
  console.log('Navigate to Add Emergency Case form');
  // Assuming a route named 'AddEmergencyCaseForm' or similar
  // router.push({ name: 'AddEmergencyCaseForm' });
};

const goToMasterSchedule = () => {
  console.log('Navigate to Master Schedule');
  router.push({ name: 'Scheduling' });
};

const manageResources = () => {
  console.log('Navigate to Resource Management');
  router.push({ name: 'ResourceManagement' });
};

const runOptimization = () => {
  console.log('Trigger Optimization Engine');
  // This might open a modal or dispatch a store action
  // scheduleStore.runOptimization();
  // If it navigates, assuming a route named 'OptimizationControl'
  // router.push({ name: 'OptimizationControl' });
};
// -------------------------------------

// --- KPI Click Handler ---
const navigateToReport = (kpiName) => {
  console.log(`Navigating to report for: ${kpiName}`);
  // Assuming a Reporting route with query parameters or dynamic segments
  // router.push({ name: 'ReportingAnalytics', query: { report: kpiName.replace(/[^a-zA-Z0-9]/g, '') } });
};

// --- Alert Click Handler ---
const handleAlertClick = (alert) => {
  console.log('View details for alert:', alert);
  // Implement modal or navigation to alert details later
};

// --- Pending Surgery Click Handler ---
const handlePendingSurgeryClick = (surgery) => {
  console.log('View details for pending surgery:', surgery);
  // This should likely navigate to the Surgery Scheduling screen
  // with this surgery pre-selected or highlighted, or open a modal.
  // For now, we can simulate selecting it in the store, which the Details Panel listens to.
   scheduleStore.selectSurgery(surgery.id);
   router.push({ name: 'Scheduling' }); // Optional: Navigate to scheduling screen
};

// --- Conflict Click Handler ---
const handleConflictClick = (conflict) => {
  selectedConflict.value = conflict; // Set the selected conflict for display in the widget
   console.log('Viewing conflict details for:', conflict);
   // This might also navigate or highlight on the scheduling screen later
};

const viewConflictingSurgeries = () => {
  console.log('View conflicting surgeries for:', selectedConflict.value);
  // In a real app, open a modal or navigate to a view showing related surgeries
  // This would likely involve navigating to the Scheduling screen and highlighting the relevant surgeries
};

const ignoreConflict = () => {
  console.log('Ignore conflict:', selectedConflict.value);
  // In a real app, send an API call to mark the conflict as ignored or resolved
  // After successful API call, update the store or refetch relevant data
};


const formatTime = (dateString) => {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

// Load initial data for the dashboard when the component is mounted
// This might involve calling scheduleStore actions to fetch data relevant to the dashboard view
onMounted(() => {
  console.log('DashboardScreen mounted. Loading data...');
  // The scheduleStore.loadInitialData() might be called here or earlier (e.g., on app startup)
  // If data is already loaded, the store will provide it reactively.
  // If not, calling it here ensures data is fetched when the dashboard is accessed.
  // scheduleStore.loadInitialData(); // Ensure data is loaded
  // Note: scheduleStore.loadInitialData is already called in SurgerySchedulingScreen on mount.
  // We might need a separate, lighter dashboard-specific data fetch action later.
});
</script>

<style scoped>
/* Remove local :root - global variables are in src/style.css */
/*
:root {
  --color-white: #ffffff;
  --color-primary: #0075c2;
  --color-secondary: #6c757d;
  --color-danger: #dc3545;
  --color-warning: #ffc107;
  --color-light-gray: #f5f5f5;
  --color-mid-light-gray: #e0e0e0;
  --color-mid-gray: #aaaaaa;
  --color-dark-gray: #555555;
  --color-very-dark-gray: #333333;
}
*/

.dashboard-container {
  padding: var(--spacing-md); /* Use global spacing variable */
}

.dashboard-widgets {
  display: grid;
  /* Use global spacing variables for gap */
  gap: var(--spacing-md); /* Space between widgets */
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Responsive grid */
  margin-top: var(--spacing-md); /* Use global spacing variable */
}

.widget {
  background-color: var(--color-white); /* Use global white variable */
  padding: var(--spacing-md); /* Use global spacing variable */
  border-radius: var(--border-radius-sm); /* Use global border radius variable */
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  border: 1px solid var(--color-border); /* Use global border variable */
}

.widget h2 {
  font-size: var(--font-size-lg); /* Use global font size variable */
  margin-top: 0;
  margin-bottom: var(--spacing-md); /* Use global spacing variable */
  padding-bottom: var(--spacing-sm); /* Use global spacing variable */
  border-bottom: 1px solid var(--color-border-soft); /* Use global border variable */
  color: var(--color-very-dark-gray); /* Use global text color variable */
}

/* Quick Actions Widget Specific Styles */
.quick-actions-widget .quick-action-buttons,
.conflict-details-widget .conflict-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm); /* Use global spacing variable */
}

.quick-actions-widget button,
.conflict-details-widget button {
  /* Inherits base button styles from global style.css */
  /* You can add minor overrides here if needed */
}

.quick-actions-widget .btn-secondary,
.conflict-details-widget .btn-secondary {
    /* Inherits .btn-secondary styles from global style.css */
}


/* KPI Widget Specific Styles */
.kpi-list {
  display: grid;
  grid-template-columns: 1fr 1fr; /* Two columns for KPI items */
  gap: var(--spacing-sm); /* Use global spacing variable */
}

.kpi-item {
  text-align: left;
  cursor: pointer;
  transition: background-color 0.2s ease;
  padding: var(--spacing-sm); /* Use global spacing variable */
  border-radius: var(--border-radius-sm); /* Use global border radius variable */
}

.kpi-item:hover {
  background-color: var(--color-background-soft); /* Use global background variable */
}

.kpi-item .kpi-label {
  display: block;
  font-size: var(--font-size-sm); /* Use global font size variable */
  color: var(--color-dark-gray); /* Use global text color variable */
  margin-bottom: var(--spacing-xs); /* Use global spacing variable */
}

.kpi-item .kpi-value {
  font-size: var(--font-size-xl); /* Use global font size variable */
  font-weight: var(--font-weight-bold); /* Use global font weight variable */
  color: var(--color-primary); /* Use global primary color variable */
  line-height: 1.2;
}

/* Specific widget adjustments */
.schedule-overview-widget p,
.pending-surgeries-widget p {
  font-size: var(--font-size-sm); /* Use global font size variable */
  color: var(--color-dark-gray); /* Use global text color variable */
}

.alerts-widget ul,
.sdst-conflicts-widget ul,
.pending-surgeries-widget ul,
.schedule-overview-widget ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.alerts-widget li,
.sdst-conflicts-widget li,
.pending-surgeries-widget li,
.schedule-overview-widget li {
  margin-bottom: var(--spacing-xs); /* Use global spacing variable */
  padding: var(--spacing-xs); /* Use global spacing variable */
  border-bottom: 1px dashed var(--color-border-soft); /* Use global border variable */
  font-size: var(--font-size-base); /* Use global font size variable */
}

.alerts-widget li:last-child,
.sdst-conflicts-widget li:last-child,
.pending-surgeries-widget li:last-child,
.schedule-overview-widget li:last-child {
  border-bottom: none;
}

.pending-surgeries-widget li,
.alerts-widget li,
.sdst-conflicts-widget li {
  cursor: pointer;
  transition: background-color 0.2s ease;
  border-left: 5px solid transparent; /* Add space for potential status indicator */
  padding-left: var(--spacing-sm); /* Adjust padding */
}

.pending-surgeries-widget li:hover,
.alerts-widget li:hover,
.sdst-conflicts-widget li:hover {
  background-color: var(--color-background-soft); /* Use global background variable */
}

.no-items {
  text-align: center;
  color: var(--color-dark-gray); /* Use global text color variable */
  font-style: italic;
}

.loading-message {
  font-size: var(--font-size-lg); /* Use global font size variable */
  color: var(--color-dark-gray); /* Use global text color variable */
  text-align: center;
  padding: var(--spacing-md); /* Use global spacing variable */
}

/* Specific styling for alerts/conflicts using global color variables */
.alert-item {
  border-left-color: var(--color-danger); /* Red color for alerts */
  color: var(--color-danger); /* Use danger color for alerts */
  font-weight: var(--font-weight-medium); /* Use global font weight variable */
}

.conflict-item {
  border-left-color: var(--color-warning); /* Yellow color for conflicts */
  color: var(--color-warning); /* Use warning color for conflicts */
  font-weight: var(--font-weight-medium); /* Use global font weight variable */
}

.schedule-item-conflict {
    color: var(--color-warning); /* Warning icon color */
    margin-left: var(--spacing-xs); /* Space after text */
}

.conflict-details-widget .conflict-actions {
    margin-top: var(--spacing-md); /* Space above action buttons */
    padding-top: var(--spacing-md); /* Space above action buttons */
     border-top: 1px solid var(--color-border-soft);
}
</style>



================================================
FILE: src/components/GanttAccessibleTable.vue
================================================
<template>
  <div class="visually-hidden">
    <table>
      <caption>Operating Room Schedule (Tabular View)</caption>
      <thead>
        <tr>
          <th scope="col">Operating Room</th>
          <th scope="col">Start Time</th>
          <th scope="col">End Time</th>
          <th scope="col">Surgery Type</th>
          <th scope="col">Patient</th>
          <th scope="col">Surgeon</th>
          <th scope="col">SDST Duration</th>
          <th scope="col">SDST Reason (Preceding Type)</th>
          <th scope="col">Conflicts</th>
        </tr>
      </thead>
      <tbody>
        <template v-for="or in operatingRooms" :key="or.id">
          <tr v-if="getSurgeriesForOR(or.id).length === 0">
              <th scope="row">{{ or.name }}</th>
              <td colspan="8">No surgeries scheduled for this OR.</td>
          </tr>
          <tr v-for="surgery in getSurgeriesForOR(or.id)" :key="surgery.id">
            <th scope="row">{{ or.name }}</th>
            <td>{{ formatDateTime(surgery.startTime) }}</td>
            <td>{{ formatDateTime(surgery.endTime) }}</td>
            <td>{{ surgery.fullType }}</td>
            <td>{{ surgery.patientName }}</td>
            <td>{{ surgery.surgeon }}</td>
            <td>{{ surgery.sdsTime }} minutes</td>
            <td>{{ surgery.precedingType }}</td>
             <td>
                <span v-if="surgery.conflicts && surgery.conflicts.length">{{ surgery.conflicts.join(', ') }}</span>
                <span v-else>None</span>
             </td>
          </tr>
        </template>
      </tbody>
    </table>
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';
import { storeToRefs } from 'pinia';

const store = useScheduleStore();
// Use visibleScheduledSurgeries from the store getter
const { operatingRooms, visibleScheduledSurgeries } = storeToRefs(store);

// Get surgeries for a specific OR within the current view, sorted by time
const getSurgeriesForOR = (orId) => {
  return visibleScheduledSurgeries.value
            .filter(s => s.orId === orId)
            .sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
};

const formatDateTime = (dateString) => {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    // Format date and time clearly for a table
    return date.toLocaleString([], { dateStyle: 'short', timeStyle: 'short' });
};
</script>

<style scoped>
/* Visually hidden class to hide content from sighted users but keep it for screen readers */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}

table {
  border-collapse: collapse;
  margin-top: var(--spacing-md);
}

th, td {
  border: 1px solid var(--color-border);
  padding: var(--spacing-sm);
  text-align: left;
}

th {
  background-color: var(--color-background-soft);
  font-weight: bold;
}

caption {
  caption-side: top;
  font-weight: bold;
  margin-bottom: var(--spacing-sm);
  text-align: left;
}
</style>


================================================
FILE: src/components/GanttChart.vue
================================================
<template>
  <div class="gantt-container">
    <div class="gantt-header">
      <div class="gantt-title">
        <h3>Operating Room Schedule</h3>
        <span class="view-mode-indicator">{{ scheduleStore.ganttViewMode }} View</span>
      </div>
      <div class="view-controls">
        <div class="date-navigation">
          <button class="btn btn-icon" @click="navigateDateRange('prev')" aria-label="Previous day">
            <span aria-hidden="true">◀</span>
          </button>
          <span class="current-date-display">{{ formattedDateRange }}</span>
          <button class="btn btn-icon" @click="navigateDateRange('next')" aria-label="Next day">
            <span aria-hidden="true">▶</span>
          </button>
        </div>
        <div class="view-mode-buttons">
          <button
            class="btn"
            :class="{'btn-primary': scheduleStore.ganttViewMode === 'Day', 'btn-secondary': scheduleStore.ganttViewMode !== 'Day'}"
            @click="changeViewMode('Day')">
            Day
          </button>
          <button
            class="btn"
            :class="{'btn-primary': scheduleStore.ganttViewMode === 'Week', 'btn-secondary': scheduleStore.ganttViewMode !== 'Week'}"
            @click="changeViewMode('Week')">
            Week
          </button>
          <button class="btn btn-secondary" @click="resetToToday()">Today</button>
        </div>
      </div>
    </div>

    <!-- SDST Legend -->
    <div class="sdst-legend">
      <div class="legend-title">SDST Color Coding:</div>
      <div class="legend-items">
        <div class="legend-item">
          <div class="legend-color sdst-low"></div>
          <div class="legend-label">Short (≤15 min)</div>
        </div>
        <div class="legend-item">
          <div class="legend-color sdst-medium"></div>
          <div class="legend-label">Medium (16-30 min)</div>
        </div>
        <div class="legend-item">
          <div class="legend-color sdst-high"></div>
          <div class="legend-label">Long (>30 min)</div>
        </div>
        <div class="legend-item">
          <div class="legend-icon">→</div>
          <div class="legend-label">Surgery Type Transition</div>
        </div>
      </div>
    </div>

    <div class="gantt-grid" ref="ganttGrid">
      <div class="gantt-time-axis">
        <!-- Hourly markers (adjust based on view mode) -->
        <div v-for="hour in hours" :key="hour" class="time-marker">{{ formatHourMarker(hour) }}</div>
      </div>
      <div class="gantt-or-rows">
        <div
          v-for="or in availableOperatingRooms"
          :key="or.id"
          class="gantt-or-row"
          :class="{'drop-target': currentDropTarget === or.id}"
          @dragover.prevent="onDragOver($event, or.id)"
          @dragenter.prevent="onDragEnter($event, or.id)"
          @dragleave="onDragLeave($event, or.id)"
          @drop="onDrop($event, or.id)"
          :aria-label="`Operating Room: ${or.name}`"
        >
          <div class="or-label">{{ or.name }}</div>
          <div class="or-timeline">
            <!-- Surgery blocks positioned here -->
            <div
              v-for="surgery in getSurgeriesForOR(or.id)"
              :key="surgery.id"
              :style="getSurgeryBlockStyle(surgery)"
              :class="{
                'surgery-block': true,
                'has-conflict': surgery.conflicts && surgery.conflicts.length > 0,
                'is-selected': isSelected(surgery),
                'is-dragging': isDragging(surgery)
              }"
              @mouseover="showTooltip($event, surgery)"
              @mouseleave="hideTooltip"
              @click="selectSurgery(surgery)"
              draggable="true"
              @dragstart="onDragStart($event, surgery)"
              @dragend="onDragEnd"
              :aria-label="getSurgeryAccessibleLabel(surgery)"
              :aria-invalid="surgery.conflicts && surgery.conflicts.length > 0 ? 'true' : null"
              tabindex="0"
            >
              <div
                v-if="surgery.sdsTime > 0"
                class="sdst-segment"
                :class="{
                  'sdst-low': surgery.sdsTime <= 15,
                  'sdst-medium': surgery.sdsTime > 15 && surgery.sdsTime <= 30,
                  'sdst-high': surgery.sdsTime > 30
                }"
                :style="getSDSTSegmentStyle(surgery)"
              >
                <span class="sdst-label" v-if="surgery.sdsTime >= 10 && pixelsPerMinute.value > 1">
                  {{ surgery.sdsTime }}m
                </span>
                <div class="sdst-transition-icon" :title="`${surgery.precedingType || 'Initial'} → ${surgery.type}`">
                  →
                </div>
              </div>
              <div class="surgery-info">
                {{ surgery.patientName }} - {{ surgery.type }}
              </div>
              <!-- Conflict Indicator Icon (WCAG 1.4.1 - not relying on color alone) -->
              <span v-if="surgery.conflicts && surgery.conflicts.length > 0" class="conflict-indicator" aria-hidden="true">⚠️</span>
            </div>

            <!-- Current time indicator (vertical line) -->
            <div v-if="isCurrentTimeVisible" class="current-time-indicator" :style="currentTimeIndicatorStyle"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Enhanced tooltip component -->
    <div v-if="tooltip.visible" class="surgery-tooltip" :style="tooltip.style" role="tooltip">
      <div class="tooltip-header">
        <strong>{{ tooltip.surgery?.patientName }}</strong>
      </div>
      <div class="tooltip-body">
        <p><strong>Type:</strong> {{ tooltip.surgery?.fullType }}</p>
        <p><strong>Surgeon:</strong> {{ tooltip.surgery?.surgeon }}</p>
        <p><strong>Time:</strong> {{ formatTime(tooltip.surgery?.startTime) }} - {{ formatTime(tooltip.surgery?.endTime) }}</p>
        <p><strong>Duration:</strong> {{ tooltip.surgery?.duration }} min</p>
        <div class="tooltip-sdst-section">
          <p><strong>SDST:</strong> {{ tooltip.surgery?.sdsTime }} min</p>
          <div class="tooltip-sdst-detail">
            <div class="sdst-transition">
              <span class="sdst-from">{{ tooltip.surgery?.precedingType || 'Initial' }}</span>
              <span class="sdst-arrow">→</span>
              <span class="sdst-to">{{ tooltip.surgery?.type }}</span>
            </div>
            <div
              class="sdst-indicator"
              :class="{
                'sdst-low': tooltip.surgery?.sdsTime <= 15,
                'sdst-medium': tooltip.surgery?.sdsTime > 15 && tooltip.surgery?.sdsTime <= 30,
                'sdst-high': tooltip.surgery?.sdsTime > 30
              }"
            ></div>
            <div class="sdst-explanation">
              {{ getSDSTExplanation(tooltip.surgery) }}
            </div>
          </div>
        </div>
        <div v-if="tooltip.surgery?.conflicts && tooltip.surgery.conflicts.length > 0" class="tooltip-conflicts">
          <strong>Conflicts:</strong>
          <ul>
            <li v-for="(c, idx) in tooltip.surgery.conflicts" :key="idx">{{ c }}</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Accessible Table View (Visually Hidden) -->
    <GanttAccessibleTable />

    <!-- Loading Indicator -->
    <div v-if="scheduleStore.isLoading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <span>Loading Schedule...</span>
    </div>

    <!-- Ghost element for drag preview -->
    <div v-if="dragGhost.visible" class="drag-ghost" :style="dragGhost.style">
      <div class="sdst-segment" :style="dragGhost.sdstStyle"></div>
      <div class="ghost-info">{{ dragGhost.text }}</div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';
import { storeToRefs } from 'pinia';
import GanttAccessibleTable from './GanttAccessibleTable.vue';

const scheduleStore = useScheduleStore();
// Use storeToRefs to get reactive state and getters from the store
const {
  visibleScheduledSurgeries,
  availableOperatingRooms,
  currentDateRange,
  isLoading,
  selectedSurgeryId
} = storeToRefs(scheduleStore);

// Tooltip state
const tooltip = ref({
  visible: false,
  surgery: null,
  style: {}
});

// Drag ghost element state
const dragGhost = ref({
  visible: false,
  style: {},
  sdstStyle: {},
  text: ''
});

// Track current drop target for visual feedback
const currentDropTarget = ref(null);

// Current time indicator
const isCurrentTimeVisible = computed(() => {
  if (!currentDateRange || !currentDateRange.start || !currentDateRange.end) {
    return false;
  }
  const now = new Date();
  return now >= currentDateRange.start && now <= currentDateRange.end;
});

const currentTimeIndicatorStyle = computed(() => {
  if (!isCurrentTimeVisible.value || !currentDateRange || !currentDateRange.start) return {};

  const now = new Date();
  const minutesFromViewStart = (now.getTime() - currentDateRange.start.getTime()) / (1000 * 60);
  const leftPosition = minutesFromViewStart * pixelsPerMinute.value;

  return {
    left: `${leftPosition}px`
  };
});

// Format the date range for display
const formattedDateRange = computed(() => {
  if (!currentDateRange || !currentDateRange.start || !currentDateRange.end) {
    return 'Loading...';
  }

  const start = currentDateRange.start;
  const end = currentDateRange.end;

  if (scheduleStore.ganttViewMode === 'Day') {
    return start.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
  } else if (scheduleStore.ganttViewMode === 'Week') {
    return `${start.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} - ${end.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}`;
  }
  return '';
});

// Computed property for generating hourly time markers based on current view range
const hours = computed(() => {
  if (!currentDateRange || !currentDateRange.start || !currentDateRange.end) {
    return [];
  }

  const start = currentDateRange.start;
  const end = currentDateRange.end;

  if (scheduleStore.ganttViewMode === 'Day') {
    // For day view, show hours from 7:00 to 19:00 (7am to 7pm)
    const hoursArray = [];
    const startHour = 7; // 7am
    const endHour = 19; // 7pm

    for (let h = startHour; h <= endHour; h++) {
      hoursArray.push(h);
    }
    return hoursArray;
  } else if (scheduleStore.ganttViewMode === 'Week') {
    // For week view, show days of the week with key hours
    const daysArray = [];
    const dayCount = 7; // 7 days in a week
    const startDate = new Date(start);

    for (let d = 0; d < dayCount; d++) {
      const currentDate = new Date(startDate);
      currentDate.setDate(startDate.getDate() + d);
      daysArray.push(currentDate);
    }
    return daysArray;
  }

  return [];
});

// Format hour markers based on view mode
const formatHourMarker = (hour) => {
  if (scheduleStore.ganttViewMode === 'Day') {
    // Format as 24-hour time for day view
    return `${String(hour).padStart(2, '0')}:00`;
  } else if (scheduleStore.ganttViewMode === 'Week') {
    // Format as day name for week view
    return hour.toLocaleDateString(undefined, { weekday: 'short', day: 'numeric' });
  }
  return '';
};

// Get surgeries for a specific OR within the current view, sorted by time
const getSurgeriesForOR = (orId) => {
  return scheduleStore.getSurgeriesForOR(orId);
};

// Define a scale (pixels per minute) for the Gantt chart based on the view mode
const pixelsPerMinute = computed(() => {
  if (scheduleStore.ganttViewMode === 'Day') {
    return 2; // 2px per minute = 120px per hour
  } else if (scheduleStore.ganttViewMode === 'Week') {
    return 0.3; // 0.3px per minute = 18px per hour, 432px per day
  }
  return 1; // Default fallback
});

// Calculate surgery block position and size
const getSurgeryBlockStyle = (surgery) => {
  if (!currentDateRange || !currentDateRange.start || !surgery) {
    return {
      left: '0px',
      width: '100px',
      backgroundColor: 'var(--color-primary)',
    };
  }

  const startTime = new Date(surgery.startTime);
  const endTime = new Date(surgery.endTime);
  const durationWithSDST = (endTime.getTime() - startTime.getTime()) / (1000 * 60);

  const viewStartTime = currentDateRange.start;
  const startMinutesFromViewStart = (startTime.getTime() - viewStartTime.getTime()) / (1000 * 60);

  const leftPosition = startMinutesFromViewStart * pixelsPerMinute.value;
  const width = durationWithSDST * pixelsPerMinute.value;

  // Get surgery type color from CSS variables
  const surgeryTypeColorVar = `--color-surgery-${surgery.type?.toLowerCase() || 'default'}`;
  const element = document.documentElement;
  const surgeryColor = getComputedStyle(element).getPropertyValue(surgeryTypeColorVar).trim() || 'var(--color-primary)';

  return {
    left: `${leftPosition}px`,
    width: `${width}px`,
    backgroundColor: surgeryColor,
  };
};

// Calculate SDST segment style with color coding based on duration
const getSDSTSegmentStyle = (surgery) => {
  if (!surgery || surgery.sdsTime === undefined || surgery.sdsTime === null) {
    return {
      width: '0px',
      backgroundColor: 'transparent',
      borderRight: 'none',
      flexShrink: 0,
      position: 'relative',
    };
  }

  const sdstWidth = surgery.sdsTime * pixelsPerMinute.value;

  // Color coding based on SDST duration
  let backgroundColor = 'var(--color-sdst-low, rgba(40, 167, 69, 0.4))'; // Default: green for short setup
  let borderColor = 'var(--color-sdst-low-border, rgba(40, 167, 69, 0.8))';

  if (surgery.sdsTime > 30) {
    // Red for long setup times
    backgroundColor = 'var(--color-sdst-high, rgba(220, 53, 69, 0.4))';
    borderColor = 'var(--color-sdst-high-border, rgba(220, 53, 69, 0.8))';
  } else if (surgery.sdsTime > 15) {
    // Yellow for medium setup times
    backgroundColor = 'var(--color-sdst-medium, rgba(255, 193, 7, 0.4))';
    borderColor = 'var(--color-sdst-medium-border, rgba(255, 193, 7, 0.8))';
  }

  return {
    width: `${sdstWidth}px`,
    backgroundColor: backgroundColor,
    borderRight: `2px dashed ${borderColor}`,
    flexShrink: 0,
    position: 'relative',
  };
};

// Check if a surgery is currently selected
const isSelected = (surgery) => {
  return surgery.id === selectedSurgeryId.value;
};

// Check if a surgery is currently being dragged
const isDragging = (surgery) => {
  return surgery.id === draggedSurgeryId.value;
};

// Interaction Logic
const selectSurgery = (surgery) => {
  scheduleStore.selectSurgery(surgery.id);
};

// Show tooltip with surgery details
const showTooltip = (event, surgery) => {
  tooltip.value.surgery = surgery;
  tooltip.value.visible = true;

  // Position tooltip near the element
  const rect = event.target.getBoundingClientRect();

  // Calculate position to avoid going off-screen
  const viewportWidth = window.innerWidth;
  let left = rect.left + rect.width / 2;

  // Adjust if tooltip would go off right edge
  const tooltipWidth = 300; // Approximate width
  if (left + tooltipWidth / 2 > viewportWidth) {
    left = viewportWidth - tooltipWidth / 2 - 10;
  }

  // Adjust if tooltip would go off left edge
  if (left - tooltipWidth / 2 < 0) {
    left = tooltipWidth / 2 + 10;
  }

  tooltip.value.style = {
    top: `${rect.bottom + 10}px`,
    left: `${left}px`,
    transform: 'translateX(-50%)',
  };
};

const hideTooltip = () => {
  tooltip.value.visible = false;
};

// Format time for display
const formatTime = (dateString) => {
  if (!dateString) return 'N/A';
  const date = new Date(dateString);
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

// Navigation and view controls
const navigateDateRange = (direction) => {
  scheduleStore.navigateGanttDate(direction);
};

const changeViewMode = (mode) => {
  scheduleStore.updateGanttViewMode(mode);
};

const resetToToday = () => {
  scheduleStore.resetGanttToToday();
};

// Drag and Drop Logic
let draggedSurgeryId = ref(null);

const onDragStart = (event, surgery) => {
  draggedSurgeryId.value = surgery.id;
  event.dataTransfer.effectAllowed = 'move';
  event.dataTransfer.setData('text/plain', surgery.id);

  // Create custom drag image
  dragGhost.value = {
    visible: true,
    text: `${surgery.patientName} - ${surgery.type}`,
    style: {
      width: `${surgery.duration * pixelsPerMinute.value}px`,
      backgroundColor: getSurgeryBlockStyle(surgery).backgroundColor,
    },
    sdstStyle: getSDSTSegmentStyle(surgery)
  };
};

const onDragEnd = () => {
  draggedSurgeryId.value = null;
  dragGhost.value.visible = false;
  currentDropTarget.value = null;
};

const onDragOver = (event, orId) => {
  event.preventDefault();
  event.dataTransfer.dropEffect = 'move';

  // Update ghost position during drag
  if (dragGhost.value.visible) {
    const ganttTimeline = event.target.closest('.or-timeline');
    if (ganttTimeline) {
      const timelineRect = ganttTimeline.getBoundingClientRect();
      const clickX = event.clientX - timelineRect.left;

      // Update ghost position for visual feedback
      // This would be implemented in a real app
    }
  }
};

const onDragEnter = (event, orId) => {
  event.preventDefault();
  currentDropTarget.value = orId;
};

const onDragLeave = (event, orId) => {
  if (currentDropTarget.value === orId) {
    currentDropTarget.value = null;
  }
};

const onDrop = (event, targetORId) => {
  event.preventDefault();
  currentDropTarget.value = null;

  const surgeryId = event.dataTransfer.getData('text/plain');
  if (!surgeryId || !currentDateRange || !currentDateRange.start) return;

  // Calculate drop time
  const ganttTimeline = event.target.closest('.or-timeline');
  if (!ganttTimeline) return;

  const timelineRect = ganttTimeline.getBoundingClientRect();
  const clickX = event.clientX - timelineRect.left;
  const scrollX = ganttTimeline.parentElement.parentElement.scrollLeft || 0;
  const totalX = clickX + scrollX;

  const minutesFromViewStart = totalX / pixelsPerMinute.value;
  const newStartTime = new Date(currentDateRange.start.getTime() + minutesFromViewStart * 60 * 1000);

  // Snap to 15-minute intervals
  const minutes = newStartTime.getMinutes();
  newStartTime.setMinutes(Math.round(minutes / 15) * 15, 0, 0);

  // Call store action to reschedule
  scheduleStore.rescheduleSurgery(surgeryId, targetORId, newStartTime);

  draggedSurgeryId.value = null;
  dragGhost.value.visible = false;
};

// Get a human-readable explanation of the SDST
const getSDSTExplanation = (surgery) => {
  if (!surgery || !surgery.sdsTime) return '';

  const fromType = surgery.precedingType || 'Initial';
  const toType = surgery.type;

  let explanation = '';

  if (surgery.sdsTime <= 15) {
    explanation = `Quick transition from ${fromType} to ${toType} surgery.`;
  } else if (surgery.sdsTime <= 30) {
    explanation = `Standard setup time required when transitioning from ${fromType} to ${toType} surgery.`;
  } else {
    explanation = `Extended setup time required when transitioning from ${fromType} to ${toType} surgery.`;
  }

  return explanation;
};

// Accessibility
const getSurgeryAccessibleLabel = (surgery) => {
  let label = `Surgery: ${surgery.fullType} for ${surgery.patientName}, scheduled in OR ${surgery.orName} from ${formatTime(surgery.startTime)} to ${formatTime(surgery.endTime)}. Estimated duration: ${surgery.estimatedDuration} minutes.`;

  if (surgery.sdsTime > 0) {
    label += ` Requires ${surgery.sdsTime} minutes setup time due to preceding ${surgery.precedingType || 'Initial'} surgery.`;
  }

  if (surgery.conflicts && surgery.conflicts.length > 0) {
    label += ` Alerts: ${surgery.conflicts.join(', ')}.`;
  }

  return label;
};

// Update current time indicator periodically
let currentTimeInterval = null;

// Lifecycle hooks
onMounted(() => {
  // Load initial data
  scheduleStore.loadInitialData();

  // Set up interval to update current time indicator
  currentTimeInterval = setInterval(() => {
    // Force re-computation of current time indicator
    if (isCurrentTimeVisible.value) {
      // This is a trick to force Vue to re-render the computed property
      currentTimeIndicatorStyle.value;
    }
  }, 60000); // Update every minute
});

onUnmounted(() => {
  // Clean up interval
  if (currentTimeInterval) {
    clearInterval(currentTimeInterval);
  }
});

</script>

<style scoped>
/* Gantt Chart Container */
.gantt-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
  position: relative;
  background-color: var(--color-background);
  border-radius: var(--border-radius-md);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

/* Header Section */
.gantt-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
  background-color: var(--color-background);
  flex-shrink: 0;
}

.gantt-title {
  display: flex;
  flex-direction: column;
}

.gantt-title h3 {
  margin: 0;
  color: var(--color-text);
  font-weight: var(--font-weight-bold);
}

.view-mode-indicator {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
  margin-top: var(--spacing-xs);
}

.view-controls {
  display: flex;
  gap: var(--spacing-md);
  align-items: center;
}

.date-navigation {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  margin-right: var(--spacing-md);
  padding: var(--spacing-xs) var(--spacing-sm);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-sm);
}

.current-date-display {
  font-weight: var(--font-weight-medium);
  padding: 0 var(--spacing-sm);
  min-width: 150px;
  text-align: center;
}

.view-mode-buttons {
  display: flex;
  gap: var(--spacing-xs);
}

.btn {
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  border: 1px solid var(--color-border);
  background-color: var(--color-background);
  color: var(--color-text);
  cursor: pointer;
  font-size: var(--font-size-sm);
  transition: all 0.2s ease;
}

.btn:hover {
  background-color: var(--color-background-mute);
}

.btn-primary {
  background-color: var(--color-primary);
  color: var(--color-text-inverted);
  border-color: var(--color-primary);
}

.btn-primary:hover {
  background-color: var(--color-primary-dark, var(--color-primary));
  opacity: 0.9;
}

.btn-secondary {
  background-color: var(--color-background-soft);
}

.btn-icon {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}

/* Gantt Grid */
.gantt-grid {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: auto;
  position: relative;
}

.gantt-time-axis {
  display: flex;
  padding-left: 120px; /* Width of OR label column */
  border-bottom: 1px solid var(--color-border);
  background-color: var(--color-background-soft);
  position: sticky;
  top: 0;
  z-index: 2;
}

.time-marker {
  width: 120px; /* Width per hour */
  flex-shrink: 0;
  text-align: center;
  padding: var(--spacing-xs) 0;
  border-right: 1px solid var(--color-border-soft);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
  font-weight: var(--font-weight-medium);
}

.gantt-or-rows {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  min-width: calc(120px * 13); /* 13 hours (7am to 7pm) */
}

.gantt-or-row {
  display: flex;
  border-bottom: 1px solid var(--color-border-soft);
  min-height: 60px;
  position: relative;
  transition: background-color 0.2s ease;
  width: 100%;
}

.gantt-or-row:hover {
  background-color: var(--color-background-hover, rgba(0, 0, 0, 0.02));
}

.gantt-or-row.drop-target {
  background-color: var(--color-background-active, rgba(0, 0, 0, 0.05));
  border: 2px dashed var(--color-primary);
}

.or-label {
  width: 120px; /* Width of OR label column */
  flex-shrink: 0;
  padding: var(--spacing-sm);
  background-color: var(--color-background-soft);
  border-right: 1px solid var(--color-border);
  font-weight: var(--font-weight-bold);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text);
  position: sticky;
  left: 0;
  z-index: 1;
}

.or-timeline {
  flex-grow: 1;
  position: relative;
  min-height: 60px;
  background-color: var(--color-background);
  /* Add subtle grid lines for hours */
  background-image: repeating-linear-gradient(
    to right,
    var(--color-border-soft) 0px,
    var(--color-border-soft) 1px,
    transparent 1px,
    transparent 120px /* Width per hour */
  );
}

/* Current time indicator */
.current-time-indicator {
  position: absolute;
  top: 0;
  height: 100%;
  width: 2px;
  background-color: var(--color-accent, red);
  z-index: 3;
  pointer-events: none;
}

/* Surgery Blocks */
.surgery-block {
  position: absolute;
  top: 5px; /* Small margin from top of row */
  height: calc(100% - 10px); /* Height with margins */
  border-radius: var(--border-radius-sm);
  display: flex;
  flex-direction: row;
  align-items: center;
  overflow: hidden;
  cursor: grab;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
  transition: box-shadow 0.2s ease, transform 0.1s ease;
  color: var(--color-text-inverted, #fff); /* Default to white text, can be overridden */
  z-index: 1; /* Above the timeline grid */
  padding: var(--spacing-xs);
}

.surgery-block:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transform: translateY(-2px);
  z-index: 2; /* Bring to front when hovered */
}

.surgery-block:active {
  cursor: grabbing;
}

.surgery-block.is-dragging {
  opacity: 0.6;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
}

.surgery-block.is-selected {
  border: 2px solid var(--color-primary);
  box-shadow: 0 0 0 2px rgba(var(--color-primary-rgb, 0, 120, 212), 0.3);
  z-index: 3; /* Above other blocks */
}

.surgery-info {
  padding: 0 var(--spacing-xs);
  font-size: var(--font-size-sm);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
}

/* SDST Segment */
.sdst-segment {
  height: 100%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  overflow: visible;
}

/* SDST color coding */
.sdst-low {
  background-color: rgba(40, 167, 69, 0.4) !important; /* Green with opacity */
  border-right: 2px dashed rgba(40, 167, 69, 0.8) !important;
}

.sdst-medium {
  background-color: rgba(255, 193, 7, 0.4) !important; /* Yellow with opacity */
  border-right: 2px dashed rgba(255, 193, 7, 0.8) !important;
}

.sdst-high {
  background-color: rgba(220, 53, 69, 0.4) !important; /* Red with opacity */
  border-right: 2px dashed rgba(220, 53, 69, 0.8) !important;
}

/* SDST duration label */
.sdst-label {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-bold);
  color: var(--color-text);
  background-color: rgba(255, 255, 255, 0.8);
  padding: 1px 3px;
  border-radius: 2px;
  white-space: nowrap;
  z-index: 1;
}

/* Transition icon */
.sdst-transition-icon {
  position: absolute;
  right: -4px;
  top: 50%;
  transform: translateY(-50%);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-bold);
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: 50%;
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  cursor: help;
}

/* Conflict Styling */
.surgery-block.has-conflict {
  border: 2px solid var(--color-error);
  animation: pulse 2s infinite;
}

.conflict-indicator {
  margin-right: var(--spacing-xs);
  font-size: var(--font-size-sm);
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(var(--color-error-rgb, 255, 0, 0), 0.4);
  }
  70% {
    box-shadow: 0 0 0 5px rgba(var(--color-error-rgb, 255, 0, 0), 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(var(--color-error-rgb, 255, 0, 0), 0);
  }
}

/* Enhanced Tooltip */
.surgery-tooltip {
  position: fixed;
  z-index: 1000;
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-md);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  font-size: var(--font-size-sm);
  max-width: 300px;
  pointer-events: none; /* Allow clicking through the tooltip */
  overflow: hidden;
}

.tooltip-header {
  background-color: var(--color-background-soft);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-bottom: 1px solid var(--color-border-soft);
  font-weight: var(--font-weight-bold);
}

.tooltip-body {
  padding: var(--spacing-sm);
}

.tooltip-body p {
  margin: var(--spacing-xs) 0;
}

.tooltip-sdst-section {
  margin-bottom: var(--spacing-sm);
  border: 1px solid var(--color-border-soft);
  border-radius: var(--border-radius-sm);
  padding: var(--spacing-xs);
  background-color: var(--color-background-soft);
}

.tooltip-sdst-detail {
  font-size: var(--font-size-xs);
  margin-top: var(--spacing-xs);
}

.sdst-transition {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  margin-bottom: var(--spacing-xs);
}

.sdst-from, .sdst-to {
  font-weight: var(--font-weight-bold);
  padding: 2px 4px;
  border-radius: 3px;
  background-color: var(--color-background);
}

.sdst-arrow {
  color: var(--color-text-secondary);
}

.sdst-indicator {
  height: 8px;
  border-radius: 4px;
  margin: var(--spacing-xs) 0;
}

.sdst-explanation {
  font-style: italic;
  color: var(--color-text-secondary);
  margin-top: var(--spacing-xs);
}

.tooltip-conflicts {
  margin-top: var(--spacing-xs);
  padding-top: var(--spacing-xs);
  border-top: 1px solid var(--color-border-soft);
  color: var(--color-error);
}

.tooltip-conflicts ul {
  margin: var(--spacing-xs) 0 0;
  padding-left: var(--spacing-md);
}

/* Loading Overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: var(--spacing-md);
  z-index: 10;
  font-size: var(--font-size-lg);
  color: var(--color-primary);
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(var(--color-primary-rgb, 0, 120, 212), 0.2);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Drag Ghost */
.drag-ghost {
  position: fixed;
  height: 50px;
  border-radius: var(--border-radius-sm);
  display: flex;
  flex-direction: row;
  align-items: center;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(0, 0, 0, 0.1);
  color: var(--color-text-inverted, #fff);
  z-index: 1000;
  pointer-events: none;
  opacity: 0.8;
}

.ghost-info {
  padding: 0 var(--spacing-xs);
  font-size: var(--font-size-sm);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
}

/* SDST Legend */
.sdst-legend {
  padding: var(--spacing-xs) var(--spacing-md);
  background-color: var(--color-background-soft);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: var(--spacing-md);
}

.legend-title {
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-sm);
  color: var(--color-text);
  white-space: nowrap;
}

.legend-items {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-md);
}

.legend-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.legend-color {
  width: 20px;
  height: 10px;
  border-radius: 2px;
}

.legend-icon {
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: var(--font-weight-bold);
  border: 1px solid var(--color-border);
  border-radius: 50%;
  font-size: var(--font-size-xs);
}

.legend-label {
  white-space: nowrap;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
  .gantt-header {
    flex-direction: column;
    align-items: flex-start;
    gap: var(--spacing-sm);
  }

  .view-controls {
    width: 100%;
    flex-direction: column;
    gap: var(--spacing-sm);
  }

  .or-label, .time-marker {
    width: 80px; /* Smaller width on mobile */
  }

  .or-timeline {
    background-image: repeating-linear-gradient(
      to right,
      var(--color-border-soft) 0px,
      var(--color-border-soft) 1px,
      transparent 1px,
      transparent 80px /* Smaller width per hour on mobile */
    );
  }

  .sdst-legend {
    padding: var(--spacing-xs);
    flex-direction: column;
    align-items: flex-start;
  }

  .legend-items {
    margin-top: var(--spacing-xs);
  }

  .legend-item {
    margin-right: var(--spacing-sm);
  }

  .sdst-label {
    display: none; /* Hide SDST labels on mobile */
  }
}

/* Accessibility Enhancements */
.surgery-block:focus {
  outline: 2px solid var(--color-focus, var(--color-primary));
  outline-offset: 2px;
  z-index: 3; /* Bring to front when focused */
}

/* Visually hidden but accessible to screen readers */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
</style>



================================================
FILE: src/components/HelloWorld.vue
================================================
<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>



================================================
FILE: src/components/HelpDocumentationScreen.vue
================================================
<template>
  <div class="section-container">
    <h1>Help / Documentation</h1>
    <!-- Placeholder sections for help topics -->
    <div>
      <h2>Getting Started</h2>
      <p>Basic steps to get started with the application...</p>

      <h2>Managing Surgeries</h2>
      <p>Learn how to create, view, edit, and delete surgeries...</p>

    </div>
  </div>
</template>

<script setup>
// Component logic will go here later
</script>

<style scoped>
.section-container {
  padding: 20px;
}
</style>


================================================
FILE: src/components/KeyboardShortcutsHelp.vue
================================================
<template>
  <Teleport to="body">
    <div v-if="isVisible" class="keyboard-shortcuts-overlay" data-testid="keyboard-shortcuts" @click="close">
      <div class="keyboard-shortcuts-modal" @click.stop>
        <div class="modal-header">
          <h2>Keyboard Shortcuts</h2>
          <button class="close-button" @click="close" aria-label="Close keyboard shortcuts help">
            ✕
          </button>
        </div>
        <div class="modal-body">
          <div v-for="(shortcuts, scope) in groupedShortcuts" :key="scope" class="shortcut-group">
            <h3>{{ formatScopeName(scope) }}</h3>
            <table>
              <thead>
                <tr>
                  <th>Shortcut</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(shortcut, index) in shortcuts" :key="index">
                  <td>
                    <div class="shortcut-keys">
                      <span v-if="shortcut.ctrlKey" class="key">Ctrl</span>
                      <span v-if="shortcut.altKey" class="key">Alt</span>
                      <span v-if="shortcut.shiftKey" class="key">Shift</span>
                      <span v-if="shortcut.metaKey" class="key">Meta</span>
                      <span class="key">{{ formatKeyName(shortcut.key) }}</span>
                    </div>
                  </td>
                  <td>{{ shortcut.description }}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" @click="close">Close</button>
        </div>
      </div>
    </div>
  </Teleport>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue';
import keyboardShortcuts from '@/services/keyboardShortcuts';

const isVisible = ref(false);

// Group shortcuts by scope
const groupedShortcuts = computed(() => {
  const shortcuts = keyboardShortcuts.getShortcuts();
  const groups = {};

  shortcuts.forEach(shortcut => {
    if (!groups[shortcut.scope]) {
      groups[shortcut.scope] = [];
    }
    groups[shortcut.scope].push(shortcut);
  });

  return groups;
});

// Format scope name for display
const formatScopeName = (scope) => {
  return scope.charAt(0).toUpperCase() + scope.slice(1);
};

// Format key name for display
const formatKeyName = (key) => {
  const specialKeys = {
    ' ': 'Space',
    'arrowup': '↑',
    'arrowdown': '↓',
    'arrowleft': '←',
    'arrowright': '→',
    'escape': 'Esc',
    'delete': 'Del',
    'backspace': 'Backspace',
    'tab': 'Tab',
    'enter': 'Enter',
    'return': 'Return',
    'capslock': 'Caps',
    'shift': 'Shift',
    'control': 'Ctrl',
    'alt': 'Alt',
    'meta': 'Meta',
    'pageup': 'PgUp',
    'pagedown': 'PgDn',
    'home': 'Home',
    'end': 'End',
    'insert': 'Ins',
    'f1': 'F1',
    'f2': 'F2',
    'f3': 'F3',
    'f4': 'F4',
    'f5': 'F5',
    'f6': 'F6',
    'f7': 'F7',
    'f8': 'F8',
    'f9': 'F9',
    'f10': 'F10',
    'f11': 'F11',
    'f12': 'F12',
  };

  const formattedKey = specialKeys[key.toLowerCase()] || key.toUpperCase();
  return formattedKey;
};

// Show the keyboard shortcuts help
const show = () => {
  isVisible.value = true;
};

// Close the keyboard shortcuts help
const close = () => {
  isVisible.value = false;
};

// Toggle the keyboard shortcuts help
const toggle = () => {
  isVisible.value = !isVisible.value;
};

// Register keyboard shortcut to show/hide the help
let unregisterShortcut;

onMounted(() => {
  unregisterShortcut = keyboardShortcuts.register('?', toggle, {
    shiftKey: true,
    description: 'Show keyboard shortcuts help',
    scope: 'global'
  });
});

onUnmounted(() => {
  if (unregisterShortcut) {
    unregisterShortcut();
  }
});

// Expose methods to parent components
defineExpose({
  show,
  close,
  toggle
});
</script>

<style scoped>
.keyboard-shortcuts-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.keyboard-shortcuts-modal {
  background-color: var(--color-background);
  border-radius: var(--border-radius-md);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  width: 600px;
  max-width: 90%;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}

.modal-header {
  padding: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  margin: 0;
  font-size: var(--font-size-lg);
  color: var(--color-text);
}

.close-button {
  background: none;
  border: none;
  font-size: var(--font-size-md);
  color: var(--color-text-secondary);
  cursor: pointer;
  padding: var(--spacing-xs);
  border-radius: var(--border-radius-sm);
}

.close-button:hover {
  color: var(--color-text);
  background-color: var(--color-background-mute);
}

.modal-body {
  padding: var(--spacing-md);
  overflow-y: auto;
  flex-grow: 1;
}

.shortcut-group {
  margin-bottom: var(--spacing-lg);
}

.shortcut-group h3 {
  margin-top: 0;
  margin-bottom: var(--spacing-sm);
  color: var(--color-text);
  font-size: var(--font-size-md);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--spacing-xs);
}

table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  padding: var(--spacing-sm);
  text-align: left;
  border-bottom: 1px solid var(--color-border-soft);
}

th {
  font-weight: var(--font-weight-bold);
  color: var(--color-text-secondary);
}

.shortcut-keys {
  display: flex;
  gap: var(--spacing-xs);
}

.key {
  display: inline-block;
  padding: 2px 6px;
  background-color: var(--color-background-mute);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-sm);
  font-family: monospace;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  min-width: 20px;
  text-align: center;
}

.modal-footer {
  padding: var(--spacing-md);
  border-top: 1px solid var(--color-border);
  display: flex;
  justify-content: flex-end;
}
</style>



================================================
FILE: src/components/LoginScreen.vue
================================================
<template>
  <div class="login-container">
    <div class="login-box">
      <header class="app-header">
        <!-- Placeholder for Logo -->
        <!-- Using /vite.svg directly as it's in the public directory -->
        <img src="/vite.svg" alt="App Logo" class="app-logo">
        <h1>Surgery Scheduling System</h1>
      </header>
      <h2 class="form-title">{{ isRegistering ? 'Create Account' : 'Login' }}</h2>

      <!-- Login Form -->
      <form v-if="!isRegistering" class="login-form" @submit.prevent="handleLogin">
        <div class="input-group">
          <label for="username">Username</label>
          <input type="text" id="username" name="username" v-model="username" required autocomplete="username">
        </div>
        <div class="input-group">
          <label for="password">Password</label>
          <input type="password" id="password" name="password" v-model="password" required autocomplete="current-password">
          <!-- Password visibility toggle could be added later -->
        </div>
        <button type="submit" class="login-button" :disabled="isLoading">{{ isLoading ? 'Logging in...' : 'Login' }}</button>
         <!-- Display login error -->
        <p v-if="loginError" class="error-message" aria-live="polite">{{ loginError }}</p>

        <p class="toggle-form-link">
          Don't have an account? <a href="#" @click.prevent="toggleForm">Create one</a>
        </p>
        <!-- Forgot password link only if FR-AUTH-005 is implemented -->
        <!-- <a href="#" class="forgot-password-link">Forgot Password?</a> -->
      </form>

      <!-- Registration Form -->
      <form v-if="isRegistering" class="login-form" @submit.prevent="handleRegister">
        <div class="input-group">
          <label for="new-username">Username</label>
          <input type="text" id="new-username" v-model="newUsername" required autocomplete="new-username">
        </div>
        <div class="input-group">
          <label for="new-password">Password</label>
          <input type="password" id="new-password" v-model="newPassword" required autocomplete="new-password">
        </div>
        <div class="input-group">
          <label for="confirm-password">Confirm Password</label>
          <input type="password" id="confirm-password" v-model="confirmPassword" required autocomplete="new-password">
        </div>
        <button type="submit" class="login-button" :disabled="isLoading">{{ isLoading ? 'Creating Account...' : 'Create Account' }}</button>
         <!-- Display registration errors/success -->
        <p v-if="registrationError" class="error-message" aria-live="polite">{{ registrationError }}</p>
        <p v-if="registrationSuccess" class="success-message" aria-live="polite">{{ registrationSuccess }}</p>

        <p class="toggle-form-link">
          Already have an account? <a href="#" @click.prevent="toggleForm">Login</a>
        </p>
      </form>

      <!-- Optional Footer -->
      <footer class="app-footer">
        <p>&copy; 2023 Your Organization. All rights reserved.</p>
      </footer>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '@/stores/authStore';

const router = useRouter();
const authStore = useAuthStore(); // Initialize auth store

const username = ref('');
const password = ref('');
const loginError = ref('');

const isRegistering = ref(false);
const newUsername = ref('');
const newPassword = ref('');
const confirmPassword = ref('');
const registrationError = ref('');
const registrationSuccess = ref('');

const isLoading = ref(false); // State to manage loading indicator

// --- Authentication Logic ---
const handleLogin = async () => {
  loginError.value = ''; // Clear previous errors

  if (!username.value || !password.value) {
    loginError.value = 'Please enter both username and password.';
    return;
  }

  isLoading.value = true; // Show loading indicator

  try {
    await authStore.login(username.value, password.value);
    // Check if there was an error from the auth store
    if (authStore.error) {
      loginError.value = authStore.error;
    } else if (authStore.isAuthenticated) {
      // Successful login - redirect is handled by the authStore
      router.push({ name: 'Dashboard' });
    }
  } catch (error) {
    console.error('Login component error:', error);
    loginError.value = 'An unexpected error occurred during login.';
  } finally {
    isLoading.value = false;
  }
};

const handleRegister = async () => {
  loginError.value = ''; // Clear login errors on register attempt
  registrationError.value = '';
  registrationSuccess.value = ''; // Clear previous success/error messages

  if (!newUsername.value || !newPassword.value || !confirmPassword.value) {
    registrationError.value = 'Please fill in all fields.';
    return;
  }
  if (newPassword.value !== confirmPassword.value) {
    registrationError.value = 'Passwords do not match.';
    return;
  }

  isLoading.value = true; // Show loading indicator

  try {
    const success = await authStore.register(newUsername.value, newPassword.value);
    if (success) {
      registrationSuccess.value = 'Account created successfully! Please log in.';
      newUsername.value = '';
      newPassword.value = '';
      confirmPassword.value = '';
      isRegistering.value = false; // Switch to login form
    } else {
      // Check authStore.error for the specific error message
      registrationError.value = authStore.error || 'Registration failed.';
    }
  } catch (error) {
    console.error('Registration component error:', error);
    registrationError.value = 'An unexpected error occurred during registration.';
  } finally {
    isLoading.value = false;
  }
};

const toggleForm = () => {
  isRegistering.value = !isRegistering.value;
  loginError.value = ''; // Clear errors when toggling
  registrationError.value = '';
  registrationSuccess.value = ''; // Clear success message when form is manually toggled
  // Clear input fields when toggling
  username.value = '';
  password.value = '';
  if (!isRegistering.value) { // Only clear new user fields when switching *to* login
      newUsername.value = '';
      newPassword.value = '';
      confirmPassword.value = '';
  }
};
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: var(--color-background); /* Use global background variable */
  color: var(--color-very-dark-gray); /* Use global text color variable */
}

.login-box {
  background-color: var(--color-white); /* Use global white variable */
  padding: var(--spacing-xl); /* Use global spacing variable */
  border-radius: var(--border-radius-md); /* Use global border radius variable */
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
  text-align: center;
  max-width: 400px;
  width: 90%;
}

.app-header {
  margin-bottom: var(--spacing-lg); /* Use global spacing variable */
}

.app-logo {
  height: 70px;
  margin-bottom: var(--spacing-md); /* Use global spacing variable */
}

.app-header h1 {
  font-size: var(--font-size-xl); /* Use global font size variable */
  color: var(--color-very-dark-gray);
  margin: 0;
}

.form-title {
  font-size: var(--font-size-lg); /* Use global font size variable */
  color: var(--color-very-dark-gray);
  margin-bottom: var(--spacing-lg); /* Use global spacing variable */
}

.login-form {
  text-align: left;
}

.input-group {
  margin-bottom: var(--spacing-md); /* Use global spacing variable */
}

.input-group label {
  display: block;
  margin-bottom: var(--spacing-xs); /* Use global spacing variable */
  font-weight: var(--font-weight-medium); /* Use global font weight variable */
  color: var(--color-dark-gray); /* Use global text color variable */
  font-size: var(--font-size-base); /* Use global font size variable */
}

.input-group input[type="text"],
.input-group input[type="password"] {
  width: 100%;
  padding: var(--spacing-sm); /* Use global spacing variable */
  border: 1px solid var(--color-gray); /* Use global border color variable */
  border-radius: var(--border-radius-sm); /* Use global border radius variable */
  box-sizing: border-box;
  font-size: var(--font-size-base); /* Use global font size variable */
  color: var(--color-very-dark-gray);
  background-color: var(--color-white);
}

/* Consistent focus styles using global variables */
.input-group input[type="text"]:focus,
.input-group input[type="password"]:focus {
    outline: 2px solid var(--color-accent); /* Use global accent color for focus */
    outline-offset: 2px;
    border-color: transparent; /* Hide default border on focus */
    box-shadow: none; /* Remove default shadow */
}

.login-button {
  width: 100%;
  padding: var(--spacing-sm); /* Use global spacing variable */
  background-color: var(--color-primary);
  color: var(--color-white);
  border: none;
  border-radius: var(--border-radius-sm); /* Use global border radius variable */
  font-size: var(--font-size-base); /* Use global font size variable */
  font-weight: var(--font-weight-medium); /* Use global font weight variable */
  cursor: pointer;
  transition: background-color 0.25s ease, opacity 0.25s ease; /* Add opacity transition for disabled state */
}

.login-button:hover:not(:disabled) {
  background-color: var(--color-primary-dark);
}

.login-button:disabled {
    opacity: 0.7; /* Dim disabled button */
    cursor: not-allowed;
}

.forgot-password-link {
  display: block;
  margin-top: var(--spacing-md); /* Use global spacing variable */
  font-size: var(--font-size-sm); /* Use global font size variable */
  color: var(--color-primary);
  text-decoration: none;
  text-align: center; /* Center the link */
}

.forgot-password-link:hover {
  text-decoration: underline;
}

.toggle-form-link {
  text-align: center;
  margin-top: var(--spacing-md); /* Use global spacing variable */
  font-size: var(--font-size-sm); /* Use global font size variable */
   color: var(--color-very-dark-gray); /* Use global text color */
}

.toggle-form-link a {
  color: var(--color-primary);
  text-decoration: none;
  font-weight: var(--font-weight-bold); /* Use global font weight variable */
}

.toggle-form-link a:hover {
  text-decoration: underline;
}

.app-footer {
  margin-top: var(--spacing-lg); /* Use global spacing variable */
  font-size: var(--font-size-sm); /* Use global font size variable */
  color: var(--color-dark-gray); /* Use global text color variable */
}

.error-message {
  color: var(--color-danger); /* Use global danger color variable */
  margin-top: var(--spacing-md); /* Use global spacing variable */
  font-size: var(--font-size-sm); /* Use global font size variable */
  text-align: center; /* Center error message */
}

.success-message {
  color: var(--color-success); /* Use global success color variable */
  margin-top: var(--spacing-md); /* Use global spacing variable */
  font-size: var(--font-size-sm); /* Use global font size variable */
  text-align: center;
}
</style>


================================================
FILE: src/components/MasterScheduleScreen.vue
================================================
<template>
  <div class="master-schedule-container">
    <h1>Master Surgery Schedule</h1>
    <div v-if="isLoading" class="loading-message">
      Loading schedule data...
    </div>
    <div v-else>
      <!-- Placeholder for calendar view -->
      <div class="calendar-controls">
        <button @click="showDayView">Day</button>
        <button @click="showWeekView">Week</button>
        <button @click="showMonthView">Month</button>
        <button class="button-primary" @click="addNewSurgery">Add New Surgery</button>
      </div>
      <div class="calendar-view">
        <!-- Calendar library component will be rendered here -->
        <div class="calendar-day">
        Day 3
          <p v-for="surgery in scheduledSurgeries.filter(s => s.day === 3)" :key="surgery.id">{{ surgery.time }} - {{ surgery.patient }} ({{ surgery.procedure }})</p>
        </div>
      </div>
    </div>
  </div>
    </div>
</template>

<script setup>
// Script logic will be added here later
import { ref, onMounted } from 'vue';

// TODO: Integrate a calendar library here for robust calendar functionality.


// Loading state
const isLoading = ref(true);

// Simulated data for scheduled surgeries
const scheduledSurgeries = ref([
    { id: 1, day: 1, time: '08:00', patient: 'Patient X', procedure: 'Appendectomy' },
    { id: 2, day: 1, time: '10:00', patient: 'Patient Y', procedure: 'Hernia Repair' },
    { id: 3, day: 2, time: '09:00', patient: 'Patient Z', procedure: 'Cholecystectomy' },
    { id: 4, day: 3, time: '11:00', patient: 'Patient A', procedure: 'Knee Arthroscopy' },
]);

// Placeholder methods for switching calendar views
const showDayView = () => {
  console.log('Switching to Day View');
  // TODO: Call calendar library API to switch to day view
};

const showWeekView = () => {
  console.log('Switching to Week View');
  // TODO: Call calendar library API to switch to week view
};

const showMonthView = () => {
  console.log('Switching to Month View');
  // TODO: Call calendar library API to switch to month view
};
// Placeholder method for adding a new surgery
const addNewSurgery = () => {
  console.log("Add New Surgery button clicked");
};

// Simulate fetching data on component mount
const fetchScheduleData = async () => {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  isLoading.value = false; // Set loading to false after data is "fetched"
};
onMounted(fetchScheduleData);
</script>

<style scoped>
.master-schedule-container {
  padding: 20px;
}

.calendar-view {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Example responsive grid */
  gap: 10px; /* Space between days */
}

.calendar-day {
  border: 1px solid var(--color-mid-light-gray); /* Subtle border */
  padding: 10px;
  min-height: 150px; /* Minimum height for a day cell */
}

/* Basic loading message styling */
.loading-message {
    text-align: center;
    color: var(--color-dark-gray);
}
</style>


================================================
FILE: src/components/MyProfileSettingsScreen.vue
================================================
<template>
  <div class="section-container">
    <h1>My Profile / Settings</h1>
    <!-- User Information Display Area -->
    <div class="profile-info-display">
      <!-- Current User Information Display -->
      <p>Name: [User Name]</p>
      <p>Email: [User Email]</p>
      <!-- Add more user info fields as needed -->
    </div>
    <!-- Profile Edit Form Area -->
    <form class="profile-edit-form">
      <!-- Edit Profile Form -->
      <!-- Form fields for editing profile details will go here -->
      <div>
        <label for="edit-name">Name:</label>
        <input type="text" id="edit-name">
      </div>
      <div>
        <label for="edit-email">Email:</label>
        <input type="email" id="edit-email">
      </div>
      <!-- Add more editable profile fields as needed (e.g., password change) -->
      <button @click.prevent="saveProfileChanges">
        Save Changes
      </button>
    </form>
  </div>
</template>

<script setup>
import { ref } from 'vue';

// Placeholder profile data
const profileData = ref({
  name: '[Current User Name]', // Simulate current name
  email: '[Current User Email]', // Simulate current email
});

// Placeholder method to save profile changes
const saveProfileChanges = () => {
  console.log('Saving profile changes:', profileData.value);
  // TODO: Send updated profileData to the backend API
};
</script>

<style scoped>
.section-container {
  padding: 20px;
}
</style>


================================================
FILE: src/components/NotFound.vue
================================================
<template>
  <div>
    <h1>404 Not Found</h1>
    <p>The page you are looking for does not exist.</p>
    <router-link to="/">Go to Home</router-link>
  </div>
</template>

<script setup>
// No script needed for a simple 404 page
</script>

<style scoped>
div {
  text-align: center;
  padding: 50px;
}
h1 {
  color: var(--primary-color);
  margin-bottom: 20px;
}
</style>


================================================
FILE: src/components/NotificationsScreen.vue
================================================
<template>
  <div class="section-container">
    <h1>Notifications</h1>
    <!-- Placeholder for Notifications List -->
    <div>
      <ul>
        <li>Notification 1: Important update</li>
        <li>Notification 2: Action required</li>
        <li>Notification 3: Surgery scheduled</li>
      </ul>
      <!-- Actual notifications would be fetched and displayed here -->
    </div>

  </div>
</template>

<script setup>
// Component logic will go here later
</script>

<style scoped>
.section-container {
  padding: 20px;
}
</style>


================================================
FILE: src/components/PatientManagementScreen.vue
================================================
<template>
  <div class="patient-management-container">
    <div v-if="!isLoading">
      <h1>Patient Management</h1>
      <!-- Placeholder for patient list or table -->
      <button class="button-primary" @click="addNewPatient">Add New Patient</button>
      <ul v-if="patients.length > 0">
        <li v-for="patient in patients" :key="patient.id">
          {{ patient.name }} (MRN: {{ patient.mrn }}) - DOB: {{ patient.dob }}
        </li>
      </ul>
      <p v-if="patients.length === 0">No patients found.</p>
    </div>

    <div v-if="isLoading" class="loading-message">Loading patient data...</div>

  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';

// Script logic will be added here later

const isLoading = ref(true);

const fetchPatientsData = async () => {
  // Simulate data fetching delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  // In a real app, fetch data from backend and populate `patients.value`
  isLoading.value = false;
};

onMounted(() => {
  fetchPatientsData();
});

const addNewPatient = () => {
  console.log('Add New Patient button clicked');
  // TODO: Navigate to patient creation form or open a modal
};

const patients = ref([
    { id: 1, name: 'Alice Smith', dob: '1990-05-15', mrn: 'MRN12345' },
    { id: 2, name: 'Bob Johnson', dob: '1985-11-20', mrn: 'MRN67890' },
    { id: 3, name: 'Charlie Brown', dob: '2000-01-01', mrn: 'MRN11223' },
]);
</script>

<style scoped>
.patient-management-container {
  padding: 20px;
}
.loading-message {
  text-align: center;
  color: gray;
  margin-top: 20px;
}
</style>


================================================
FILE: src/components/PendingSurgeriesList.vue
================================================

<template>
  <div class="pending-surgeries-list">
    <h4>Pending Surgeries</h4>
    <!-- Add filter/sort controls here later -->
    <div class="pending-items">
      <div
        v-for="surgery in pendingSurgeries"
        :key="surgery.id"
        class="pending-surgery-item"
        draggable="true"
        @dragstart="onDragStart($event, surgery)"
        @dragend="onDragEnd($event)" <!-- Add dragend handler -->
        @click="selectSurgery(surgery)"
        :aria-label="`Pending Surgery: ${surgery.fullType} for ${surgery.patientName}. Estimated duration: ${surgery.estimatedDuration} minutes. Priority: ${surgery.priority}.`"
        tabindex="0"
      >
        <div class="item-info">
          <strong>{{ surgery.patientName }}</strong> - {{ surgery.type }}
        </div>
        <div class="item-details">
          Duration: {{ surgery.estimatedDuration }} min | Priority: {{ surgery.priority }}
        </div>
        <!-- Add quick action buttons like "Schedule Now" or details icon if needed -->
      </div>
      <p v-if="pendingSurgeries.length === 0" class="empty-list-message">
          No pending surgeries at this time.
      </p>
    </div>
  </div>
</template>

<script setup>
import { useScheduleStore } from '@/stores/scheduleStore';
import { storeToRefs } from 'pinia';

const store = useScheduleStore();
const { pendingSurgeries } = storeToRefs(store);

// --- Drag and Drop Logic ---
const onDragStart = (event, surgery) => {
  // Store data to be transferred (e.g., surgery ID)
  // The drop target (GanttChart) expects 'text/plain' with the surgery ID
  event.dataTransfer.setData('text/plain', surgery.id);
  event.dataTransfer.effectAllowed = 'move'; // Indicate that the element can be moved

  // Add a class for visual feedback while dragging
   // Use setTimeout to ensure the class is added after the browser takes the screenshot for the drag image
   setTimeout(() => {
      event.target.classList.add('is-dragging');
   }, 0);
};

const onDragEnd = (event) => {
    // Clean up the dragging class when the drag operation ends (success or cancel)
    event.target.classList.remove('is-dragging');
    // Note: Removing the surgery from the pending list happens in the store action (addSurgeryFromPending)
    // triggered by a successful drop in the GanttChart.
};

// --- Interaction Logic ---
const selectSurgery = (surgery) => {
  store.selectSurgery(surgery.id); // Select the surgery in the store for details panel
};

</script>

<style scoped>
.pending-surgeries-list {
  padding: var(--spacing-md); /* Use global spacing variable */
  border-right: 1px solid var(--color-border); /* Use global border variable */
  overflow-y: auto;
  height: 100%;
  flex-shrink: 0;
  width: 250px;
  background-color: var(--color-background-soft); /* Use global background variable */
}

.pending-surgeries-list h4 {
  margin-top: 0;
  margin-bottom: var(--spacing-md); /* Use global spacing variable */
  color: var(--color-text); /* Use global text color variable */
  border-bottom: 1px solid var(--color-border-soft); /* Use global border variable */
  padding-bottom: var(--spacing-xs); /* Use global spacing variable */
}

.pending-items {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm); /* Use global spacing variable */
}

.pending-surgery-item {
  border: 1px solid var(--color-border); /* Use global border variable */
  border-radius: var(--border-radius-sm); /* Use global border radius variable */
  padding: var(--spacing-sm); /* Use global spacing variable */
  cursor: grab; /* Indicate draggable item */
  background-color: var(--color-background); /* Use global background variable */
  transition: background-color 0.2s ease, border-color 0.2s ease; /* Add transition */
   outline-offset: 2px; /* Ensure outline doesn't overlap border */
    color: var(--color-text); /* Use global text color variable */
}

.pending-surgery-item:hover {
  background-color: var(--color-background-mute); /* Use global background variable */
  border-color: var(--color-primary); /* Use global primary color variable */
}

.pending-surgery-item:active {
    cursor: grabbing; /* Indicate being grabbed */
}

.pending-surgery-item.is-dragging {
    opacity: 0.4;
    border: 2px dashed var(--color-accent); /* Use global accent variable */
    background-color: var(--color-background-mute); /* Use global background variable */
}

.item-info strong {
    color: inherit; /* Inherit color from parent */
}

.item-details {
    font-size: var(--font-size-sm); /* Use global font size variable */
    color: var(--color-text-secondary); /* Use global text color variable */
    margin-top: var(--spacing-xs); /* Use global spacing variable */
}

.empty-list-message {
    color: var(--color-text-secondary); /* Use global text color variable */
    text-align: center;
    font-style: italic;
    margin-top: var(--spacing-md); /* Use global spacing variable */
}
</style>



================================================
FILE: src/components/ReportingAnalyticsScreen.vue
================================================
<template>
  <div class="analytics-container">
    <!-- Analytics Navigation -->
    <div class="analytics-nav">
      <router-link to="/reporting-analytics" class="nav-item" exact-active-class="active">
        Dashboard
      </router-link>
      <router-link to="/reporting-analytics/utilization" class="nav-item" active-class="active">
        Utilization Reports
      </router-link>
      <router-link to="/reporting-analytics/efficiency" class="nav-item" active-class="active">
        Efficiency Reports
      </router-link>
      <router-link to="/reporting-analytics/custom" class="nav-item" active-class="active">
        Custom Reports
      </router-link>
    </div>

    <!-- Router View for Nested Routes -->
    <div class="analytics-content">
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup>
// No additional logic needed - this component just serves as a container for nested routes
</script>

<style scoped>
.analytics-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.analytics-nav {
  display: flex;
  background-color: var(--color-background-soft);
  border-bottom: 1px solid var(--color-border);
  padding: 0 var(--spacing-md);
  overflow-x: auto;
}

.nav-item {
  padding: var(--spacing-sm) var(--spacing-md);
  color: var(--color-text);
  text-decoration: none;
  border-bottom: 3px solid transparent;
  font-weight: var(--font-weight-medium);
  white-space: nowrap;
}

.nav-item:hover {
  color: var(--color-primary);
  background-color: var(--color-background-hover);
}

.nav-item.active {
  color: var(--color-primary);
  border-bottom-color: var(--color-primary);
  background-color: var(--color-background-active);
}

.analytics-content {
  flex: 1;
  overflow-y: auto;
  padding: var(--spacing-md);
}

@media (max-width: 768px) {
  .analytics-nav {
    padding: 0;
  }

  .nav-item {
    padding: var(--spacing-sm);
    font-size: var(--font-size-sm);
  }
}
</style>


================================================
FILE: src/components/ResourceAvailabilityCalendar.vue
================================================
<template>
  <div class="resource-availability-calendar">
    <div class="calendar-header">
      <h3>{{ resource.name }} Availability</h3>
      <div class="resource-info">
        <div class="resource-type">{{ resourceType }}</div>
        <div class="resource-status" :class="getStatusClass(resource.status)">
          {{ resource.status }}
        </div>
      </div>
    </div>

    <div class="calendar-navigation">
      <button class="btn btn-icon" @click="previousMonth" aria-label="Previous month">
        ◀
      </button>
      <div class="current-month">{{ currentMonthName }} {{ currentYear }}</div>
      <button class="btn btn-icon" @click="nextMonth" aria-label="Next month">
        ▶
      </button>
    </div>

    <div class="calendar-grid">
      <!-- Day headers -->
      <div v-for="day in weekDays" :key="day" class="day-header">{{ day }}</div>

      <!-- Calendar days -->
      <div 
        v-for="(day, index) in calendarDays" 
        :key="index"
        class="calendar-day"
        :class="{ 
          'other-month': !day.isCurrentMonth,
          'today': day.isToday,
          'unavailable': day.isUnavailable,
          'has-unavailable-periods': day.hasUnavailablePeriods
        }"
        @click="day.isCurrentMonth && selectDay(day)"
      >
        <div class="day-number">{{ day.day }}</div>
        <div v-if="day.hasUnavailablePeriods" class="unavailable-indicator">
          <div 
            v-for="(period, i) in day.unavailablePeriods" 
            :key="i" 
            class="period-marker"
            :title="period.reason"
          ></div>
        </div>
      </div>
    </div>

    <!-- Day detail view when a day is selected -->
    <div v-if="selectedDay" class="day-detail">
      <div class="day-detail-header">
        <h4>{{ formatDate(selectedDay.date) }}</h4>
        <button class="btn btn-icon" @click="selectedDay = null" aria-label="Close detail view">✕</button>
      </div>

      <div class="availability-status">
        <div class="status-label">Day Status:</div>
        <div class="status-toggle">
          <label class="toggle-switch">
            <input 
              type="checkbox" 
              :checked="!selectedDay.isUnavailable" 
              @change="toggleDayAvailability"
            >
            <span class="toggle-slider"></span>
          </label>
          <span>{{ selectedDay.isUnavailable ? 'Unavailable' : 'Available' }}</span>
        </div>
      </div>

      <div v-if="!selectedDay.isUnavailable">
        <h5>Unavailable Time Periods</h5>
        <div v-if="selectedDay.unavailablePeriods.length === 0" class="no-periods">
          No unavailable periods set for this day.
        </div>
        <div v-else class="periods-list">
          <div 
            v-for="(period, index) in selectedDay.unavailablePeriods" 
            :key="index"
            class="period-item"
          >
            <div class="period-time">{{ period.start }} - {{ period.end }}</div>
            <div class="period-reason">{{ period.reason }}</div>
            <button 
              class="btn btn-icon btn-danger" 
              @click="removePeriod(index)"
              aria-label="Remove period"
            >
              ✕
            </button>
          </div>
        </div>

        <div class="add-period-form">
          <h5>Add Unavailable Period</h5>
          <div class="form-row">
            <div class="form-group">
              <label for="start-time">Start Time</label>
              <input 
                type="time" 
                id="start-time" 
                v-model="newPeriod.start"
                class="form-control"
              >
            </div>
            <div class="form-group">
              <label for="end-time">End Time</label>
              <input 
                type="time" 
                id="end-time" 
                v-model="newPeriod.end"
                class="form-control"
              >
            </div>
          </div>
          <div class="form-group">
            <label for="reason">Reason</label>
            <input 
              type="text" 
              id="reason" 
              v-model="newPeriod.reason"
              class="form-control"
              placeholder="e.g., Meeting, Maintenance, Lunch"
            >
          </div>
          <button 
            class="btn btn-primary" 
            @click="addPeriod"
            :disabled="!isNewPeriodValid"
          >
            Add Period
          </button>
        </div>
      </div>

      <div class="day-detail-actions">
        <button class="btn btn-secondary" @click="selectedDay = null">Close</button>
        <button class="btn btn-primary" @click="saveAvailability">Save Changes</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import { useResourceStore } from '@/stores/resourceStore';
import { useToast } from 'vue-toastification';

const props = defineProps({
  resource: {
    type: Object,
    required: true
  },
  resourceType: {
    type: String,
    required: true,
    validator: (value) => ['operatingRoom', 'staff', 'equipment'].includes(value)
  }
});

const emit = defineEmits(['close', 'update']);

const toast = useToast();
const resourceStore = useResourceStore();

// Calendar state
const currentDate = ref(new Date());
const selectedDay = ref(null);
const newPeriod = ref({
  start: '08:00',
  end: '09:00',
  reason: ''
});

// Computed properties for calendar
const currentYear = computed(() => currentDate.value.getFullYear());
const currentMonth = computed(() => currentDate.value.getMonth());
const currentMonthName = computed(() => {
  return new Date(currentYear.value, currentMonth.value, 1).toLocaleString('default', { month: 'long' });
});

const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

// Generate calendar days for the current month
const calendarDays = computed(() => {
  const year = currentYear.value;
  const month = currentMonth.value;
  
  // Get first day of the month
  const firstDay = new Date(year, month, 1);
  // Get last day of the month
  const lastDay = new Date(year, month + 1, 0);
  
  // Get the day of the week for the first day (0-6, where 0 is Sunday)
  const firstDayOfWeek = firstDay.getDay();
  
  // Calculate days from previous month to show
  const daysFromPrevMonth = firstDayOfWeek;
  
  // Calculate total days to show (previous month + current month + next month)
  const totalDays = 42; // 6 rows of 7 days
  
  const days = [];
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // Add days from previous month
  const prevMonth = new Date(year, month, 0);
  const prevMonthDays = prevMonth.getDate();
  
  for (let i = prevMonthDays - daysFromPrevMonth + 1; i <= prevMonthDays; i++) {
    const date = new Date(year, month - 1, i);
    days.push(createDayObject(date, false));
  }
  
  // Add days from current month
  for (let i = 1; i <= lastDay.getDate(); i++) {
    const date = new Date(year, month, i);
    days.push(createDayObject(date, true));
  }
  
  // Add days from next month
  const remainingDays = totalDays - days.length;
  for (let i = 1; i <= remainingDays; i++) {
    const date = new Date(year, month + 1, i);
    days.push(createDayObject(date, false));
  }
  
  return days;
});

// Create a day object with availability information
function createDayObject(date, isCurrentMonth) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const isToday = date.getTime() === today.getTime();
  const day = date.getDate();
  
  // Check resource availability for this day
  const dateKey = formatDateKey(date);
  const resourceId = props.resource.id;
  const availability = resourceStore.resourceAvailability[dateKey]?.[resourceId];
  
  const isUnavailable = availability ? !availability.available : false;
  const unavailablePeriods = availability?.unavailablePeriods || [];
  
  return {
    date,
    day,
    isCurrentMonth,
    isToday,
    isUnavailable,
    unavailablePeriods,
    hasUnavailablePeriods: unavailablePeriods.length > 0
  };
}

// Format date for display
function formatDate(date) {
  return date.toLocaleDateString('en-US', { 
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
}

// Format date as YYYY-MM-DD for use as a key
function formatDateKey(date) {
  return date.toISOString().split('T')[0];
}

// Navigation methods
function previousMonth() {
  currentDate.value = new Date(currentYear.value, currentMonth.value - 1, 1);
  selectedDay.value = null;
}

function nextMonth() {
  currentDate.value = new Date(currentYear.value, currentMonth.value + 1, 1);
  selectedDay.value = null;
}

// Day selection
function selectDay(day) {
  selectedDay.value = { ...day };
  newPeriod.value = {
    start: '08:00',
    end: '09:00',
    reason: ''
  };
}

// Toggle day availability
function toggleDayAvailability() {
  if (!selectedDay.value) return;
  
  selectedDay.value.isUnavailable = !selectedDay.value.isUnavailable;
  
  // If day is marked as unavailable, clear all periods
  if (selectedDay.value.isUnavailable) {
    selectedDay.value.unavailablePeriods = [];
  }
}

// Add a new unavailable period
function addPeriod() {
  if (!isNewPeriodValid.value) return;
  
  selectedDay.value.unavailablePeriods.push({
    start: newPeriod.value.start,
    end: newPeriod.value.end,
    reason: newPeriod.value.reason
  });
  
  // Sort periods by start time
  selectedDay.value.unavailablePeriods.sort((a, b) => {
    return a.start.localeCompare(b.start);
  });
  
  // Reset form
  newPeriod.value = {
    start: '08:00',
    end: '09:00',
    reason: ''
  };
}

// Remove an unavailable period
function removePeriod(index) {
  selectedDay.value.unavailablePeriods.splice(index, 1);
}

// Save availability changes
async function saveAvailability() {
  if (!selectedDay.value) return;
  
  const dateKey = formatDateKey(selectedDay.value.date);
  const resourceId = props.resource.id;
  
  const availability = {
    available: !selectedDay.value.isUnavailable,
    unavailablePeriods: selectedDay.value.unavailablePeriods
  };
  
  try {
    const result = await resourceStore.updateResourceAvailability(resourceId, dateKey, availability);
    
    if (result.success) {
      toast.success('Availability updated successfully');
      emit('update');
    } else {
      toast.error('Failed to update availability');
    }
  } catch (error) {
    toast.error(`Error: ${error.message}`);
  }
}

// Validation for new period
const isNewPeriodValid = computed(() => {
  if (!newPeriod.value.start || !newPeriod.value.end) return false;
  if (newPeriod.value.start >= newPeriod.value.end) return false;
  return true;
});

// Helper function to get status class
function getStatusClass(status) {
  if (!status) return '';
  
  const statusLower = status.toLowerCase();
  if (statusLower.includes('active') || statusLower.includes('available')) {
    return 'status-active';
  } else if (statusLower.includes('maintenance')) {
    return 'status-maintenance';
  } else {
    return 'status-inactive';
  }
}

// Load initial data
onMounted(() => {
  // Nothing to load initially, as we're using the data from the store
});
</script>

<style scoped>
.resource-availability-calendar {
  background-color: var(--color-background);
  border-radius: var(--border-radius-md);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  padding: var(--spacing-md);
  max-width: 800px;
  margin: 0 auto;
}

.calendar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

.calendar-header h3 {
  margin: 0;
  color: var(--color-text);
}

.resource-info {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.resource-type {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.resource-status {
  padding: 2px 8px;
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-medium);
}

.status-active {
  background-color: rgba(40, 167, 69, 0.2);
  color: #28a745;
}

.status-inactive {
  background-color: rgba(108, 117, 125, 0.2);
  color: #6c757d;
}

.status-maintenance {
  background-color: rgba(255, 193, 7, 0.2);
  color: #ffc107;
}

.calendar-navigation {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
  padding: var(--spacing-sm);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-sm);
}

.current-month {
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-md);
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 1px;
  background-color: var(--color-border-soft);
  border: 1px solid var(--color-border-soft);
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

.day-header {
  background-color: var(--color-background-soft);
  padding: var(--spacing-sm);
  text-align: center;
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
}

.calendar-day {
  background-color: var(--color-background);
  min-height: 80px;
  padding: var(--spacing-xs);
  position: relative;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.calendar-day:hover {
  background-color: var(--color-background-hover);
}

.other-month {
  opacity: 0.5;
  cursor: default;
}

.today {
  background-color: rgba(var(--color-primary-rgb, 0, 120, 212), 0.1);
}

.unavailable {
  background-color: rgba(var(--color-error-rgb, 220, 53, 69), 0.1);
}

.has-unavailable-periods .day-number::after {
  content: "•";
  color: var(--color-error);
  margin-left: 4px;
}

.day-number {
  font-weight: var(--font-weight-medium);
  margin-bottom: var(--spacing-xs);
}

.unavailable-indicator {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.period-marker {
  height: 4px;
  background-color: var(--color-error);
  border-radius: 2px;
}

.day-detail {
  margin-top: var(--spacing-md);
  padding: var(--spacing-md);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-sm);
  border: 1px solid var(--color-border);
}

.day-detail-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

.day-detail-header h4 {
  margin: 0;
  color: var(--color-text);
}

.availability-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  padding: var(--spacing-sm);
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
}

.status-label {
  font-weight: var(--font-weight-medium);
}

.status-toggle {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 20px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .toggle-slider {
  background-color: var(--color-primary);
}

input:checked + .toggle-slider:before {
  transform: translateX(20px);
}

h5 {
  margin-top: var(--spacing-md);
  margin-bottom: var(--spacing-sm);
  color: var(--color-text);
  font-size: var(--font-size-md);
}

.no-periods {
  padding: var(--spacing-sm);
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  color: var(--color-text-secondary);
  font-style: italic;
}

.periods-list {
  margin-bottom: var(--spacing-md);
}

.period-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm);
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  margin-bottom: var(--spacing-xs);
}

.period-time {
  font-weight: var(--font-weight-medium);
  min-width: 120px;
}

.period-reason {
  flex-grow: 1;
  color: var(--color-text-secondary);
}

.add-period-form {
  margin-top: var(--spacing-md);
  padding: var(--spacing-md);
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  border: 1px solid var(--color-border-soft);
}

.form-row {
  display: flex;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-sm);
}

.form-group {
  margin-bottom: var(--spacing-sm);
  flex-grow: 1;
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.form-control {
  width: 100%;
  padding: var(--spacing-xs) var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-sm);
}

.day-detail-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

@media (max-width: 768px) {
  .form-row {
    flex-direction: column;
    gap: var(--spacing-sm);
  }
  
  .calendar-grid {
    font-size: var(--font-size-xs);
  }
  
  .calendar-day {
    min-height: 60px;
  }
}
</style>



================================================
FILE: src/components/ResourceManagementScreen.vue
================================================
<template>
  <div class="resource-management-container">
    <h1>Resource Management</h1>

    <div class="tabs">
      <button
        :class="{ active: activeTab === 'ors' }"
        @click="activeTab = 'ors'"
      >Operating Rooms</button>
      <button
        :class="{ active: activeTab === 'staff' }"
        @click="activeTab = 'staff'"
      >Staff</button>
      <button
        :class="{ active: activeTab === 'equipment' }"
        @click="activeTab = 'equipment'"
      >Equipment</button>
    </div>

    <div class="tab-content">
      <!-- Operating Rooms Section -->
      <div v-if="activeTab === 'ors'" class="resource-section">
        <h2>Operating Rooms List</h2>
        <button class="button-primary" @click="openOrFormForAdd" v-if="!showAddOrForm">Add New OR</button>
        <AddOrForm
          v-if="showAddOrForm"
          :or-to-edit="currentOrToEdit"
          @cancel="handleCancelOrForm"
          @save="handleSaveOr"
        />
        <div v-if="isLoading" class="loading-indicator">
          <div class="spinner"></div>
          <p>Loading operating rooms...</p>
        </div>
        <table v-else>
          <thead>
            <tr>
              <th scope="col">Name/ID</th>
              <th scope="col">Location</th>
              <th scope="col">Status</th>
              <th scope="col">Primary Service</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="or in operatingRooms" :key="or.id">
              <td>{{ or.name }}</td>
              <td>{{ or.location }}</td>
              <td :class="'status-' + or.status.toLowerCase().replace(' ', '-')">{{ or.status }}</td>
              <td>{{ or.primaryService }}</td>
              <td>
                <button class="button-small" @click="openOrFormForEdit(or)">View/Edit</button>
                <button class="button-small button-danger" @click="deleteOr(or)">Delete</button>
              </td>
            </tr>
            <tr v-if="operatingRooms.length === 0">
              <td colspan="5" class="no-items">No operating rooms found.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Staff Section -->
      <div v-if="activeTab === 'staff'" class="resource-section">
        <h2>Staff List</h2>
        <button class="button-primary" @click="openStaffFormForAdd" v-if="!showAddStaffForm">Add New Staff</button>
        <AddStaffForm
          v-if="showAddStaffForm"
          :staff-to-edit="currentStaffToEdit"
          @cancel="handleCancelStaffForm"
          @save="handleSaveStaff"
        />
        <div v-if="isLoading" class="loading-indicator">
          <div class="spinner"></div>
          <p>Loading staff data...</p>
        </div>
        <table v-else>
          <thead>
            <tr>
              <th scope="col">Name</th>
              <th scope="col">Role</th>
              <th scope="col">Specialization(s)</th>
              <th scope="col">Status</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="person in staff" :key="person.id">
              <td>{{ person.name }}</td>
              <td>{{ person.role }}</td>
              <td>{{ person.specializations.join(', ') }}</td>
              <td :class="'status-' + person.status.toLowerCase().replace(' ', '-')">{{ person.status }}</td>
              <td>
                <button class="button-small" @click="openStaffFormForEdit(person)">View/Edit</button>
                <button class="button-small button-danger" @click="deleteStaff(person)">Delete</button>
              </td>
            </tr>
            <tr v-if="staff.length === 0">
              <td colspan="5" class="no-items">No staff found.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Equipment Section -->
      <div v-if="activeTab === 'equipment'" class="resource-section">
        <h2>Equipment List</h2>
        <button class="button-primary" @click="openEquipmentFormForAdd" v-if="!showAddEquipmentForm">Add New Equipment</button>
        <AddEquipmentForm
          v-if="showAddEquipmentForm"
          :equipment-to-edit="currentEquipmentToEdit"
          @cancel="handleCancelEquipmentForm"
          @save="handleSaveEquipment"
        />
        <div v-if="isLoading" class="loading-indicator">
          <div class="spinner"></div>
          <p>Loading equipment data...</p>
        </div>
        <table v-else>
          <thead>
            <tr>
              <th scope="col">Name/ID</th>
              <th scope="col">Type</th>
              <th scope="col">Status</th>
              <th scope="col">Location</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="item in equipment" :key="item.id">
              <td>{{ item.name }}</td>
              <td>{{ item.type }}</td>
              <td :class="'status-' + item.status.toLowerCase().replace(' ', '-')">{{ item.status }}</td>
              <td>{{ item.location }}</td>
              <td>
                <button class="button-small" @click="openEquipmentFormForEdit(item)">View/Edit</button>
                <button class="button-small button-danger" @click="deleteEquipment(item)">Delete</button>
              </td>
            </tr>
            <tr v-if="equipment.length === 0">
              <td colspan="5" class="no-items">No equipment found.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Confirmation Modal -->
    <ConfirmationModal
      v-if="showConfirmationModal"
      :title="confirmationTitle"
      :message="confirmationMessage"
      @confirm="handleConfirmDelete"
      @cancel="handleCancelDelete"
    />

    <!-- Resource Availability Calendar Modal -->
    <div v-if="showAvailabilityModal" class="modal-overlay">
      <div class="modal-content availability-modal">
        <div class="modal-header">
          <h3>Resource Availability</h3>
          <button class="close-button" @click="closeAvailabilityModal">✕</button>
        </div>
        <div class="modal-body">
          <ResourceAvailabilityCalendar
            v-if="selectedResourceForAvailability"
            :resource="selectedResourceForAvailability"
            :resourceType="selectedResourceType"
            @update="handleAvailabilityUpdate"
            @close="closeAvailabilityModal"
          />
        </div>
      </div>
    </div>

  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue';
import { useToast } from 'vue-toastification';
import { useResourceStore } from '@/stores/resourceStore';
import { storeToRefs } from 'pinia';
import AddOrForm from './AddOrForm.vue';
import AddStaffForm from './AddStaffForm.vue';
import AddEquipmentForm from './AddEquipmentForm.vue';
import ConfirmationModal from './ConfirmationModal.vue';
import ResourceAvailabilityCalendar from './ResourceAvailabilityCalendar.vue';

const toast = useToast();
const activeTab = ref('ors'); // Default active tab

// Initialize the resource store
const resourceStore = useResourceStore();
const { isLoading, error, operatingRooms, staff, equipment } = storeToRefs(resourceStore);

// Load resources when component is mounted
onMounted(async () => {
  await resourceStore.loadResources();
});

// --- Resource Availability Calendar State & Logic ---
const showAvailabilityModal = ref(false);
const selectedResourceForAvailability = ref(null);
const selectedResourceType = ref('');

const openAvailabilityCalendar = (resource, type) => {
  selectedResourceForAvailability.value = resource;
  selectedResourceType.value = type;
  showAvailabilityModal.value = true;
};

const closeAvailabilityModal = () => {
  showAvailabilityModal.value = false;
  selectedResourceForAvailability.value = null;
  selectedResourceType.value = '';
};

const handleAvailabilityUpdate = () => {
  toast.success('Resource availability updated successfully!');
  // No need to close the modal here, let the user continue editing if needed
};

// --- Confirmation Modal State & Logic ---
const showConfirmationModal = ref(false);
const itemToDelete = ref(null);
const itemTypeToDelete = ref(''); // 'or', 'staff', 'equipment'
const confirmationTitle = ref('Confirm Deletion');
const confirmationMessage = ref('Are you sure you want to delete this item? This action cannot be undone.');

const openConfirmationModal = (item, type, title, message) => {
  itemToDelete.value = item;
  itemTypeToDelete.value = type;
  confirmationTitle.value = title || 'Confirm Deletion';
  confirmationMessage.value = message || 'Are you sure you want to delete this item? This action cannot be undone.';
  showConfirmationModal.value = true;
};

const handleConfirmDelete = async () => {
  if (!itemToDelete.value || !itemTypeToDelete.value) return;

  const item = itemToDelete.value;
  const type = itemTypeToDelete.value;
  const itemName = item.name;
  const itemTypeDisplay = type.charAt(0).toUpperCase() + type.slice(1);

  try {
    let result;

    // Call the appropriate store method based on the item type
    if (type === 'or') {
      result = await resourceStore.deleteOperatingRoom(item.id);
    } else if (type === 'staff') {
      result = await resourceStore.deleteStaff(item.id);
    } else if (type === 'equipment') {
      result = await resourceStore.deleteEquipment(item.id);
    }

    if (result.success) {
      console.log(`Deleted ${type}:`, item);
      toast.success(`${itemTypeDisplay} '${itemName}' deleted successfully!`);
    } else {
      throw new Error(result.error || 'Unknown error');
    }
  } catch (error) {
    console.error(`Failed to delete ${type}:`, item, error);
    toast.error(`Failed to delete ${itemTypeDisplay} '${itemName}': ${error.message}`);
  }

  handleCancelDelete(); // Close modal and reset state regardless of outcome
};

const handleCancelDelete = () => {
  showConfirmationModal.value = false;
  itemToDelete.value = null;
  itemTypeToDelete.value = '';
  confirmationTitle.value = 'Confirm Deletion'; // Reset to default
  confirmationMessage.value = 'Are you sure you want to delete this item? This action cannot be undone.'; // Reset to default
};

// --- OR Management State & Logic ---
const showAddOrForm = ref(false);
const currentOrToEdit = ref(null);

// Computed property for active operating rooms
const activeOperatingRooms = computed(() => resourceStore.activeOperatingRooms);

const openOrFormForAdd = () => {
  currentOrToEdit.value = null;
  showAddOrForm.value = true;
};

const openOrFormForEdit = (or) => {
  currentOrToEdit.value = { ...or };
  showAddOrForm.value = true;
};

const handleCancelOrForm = () => {
  showAddOrForm.value = false;
  currentOrToEdit.value = null;
};

const handleSaveOr = async (orData) => {
  if (isLoading.value) return; // Prevent multiple submissions

  try {
    if (currentOrToEdit.value) {
      // Editing existing OR
      const result = await resourceStore.updateOperatingRoom(orData.id, orData);
      if (result.success) {
        toast.success(`Operating Room '${orData.name}' updated successfully!`);
      } else {
        toast.error(`Failed to update Operating Room: ${result.error}`);
      }
    } else {
      // Adding new OR
      const result = await resourceStore.addOperatingRoom(orData);
      if (result.success) {
        toast.success(`Operating Room '${orData.name}' added successfully!`);
      } else {
        toast.error(`Failed to add Operating Room: ${result.error}`);
      }
    }
    showAddOrForm.value = false;
    currentOrToEdit.value = null;
  } catch (err) {
    toast.error(`An error occurred: ${err.message}`);
  }
};

const viewOrAvailability = (orItem) => {
  openAvailabilityCalendar(orItem, 'operatingRoom');
};

const deleteOr = (orItem) => {
  openConfirmationModal(
    orItem,
    'or',
    'Delete Operating Room?',
    `Are you sure you want to delete the operating room "${orItem.name}"? This action cannot be undone.`
  );
};

// --- Staff Management State & Logic ---
const showAddStaffForm = ref(false);
const currentStaffToEdit = ref(null);

// Computed property for active staff
const activeStaff = computed(() => resourceStore.activeStaff);

const openStaffFormForAdd = () => {
  currentStaffToEdit.value = null;
  showAddStaffForm.value = true;
};

const openStaffFormForEdit = (staffMember) => {
  currentStaffToEdit.value = { ...staffMember };
  showAddStaffForm.value = true;
};

const handleCancelStaffForm = () => {
  showAddStaffForm.value = false;
  currentStaffToEdit.value = null;
};

const handleSaveStaff = async (staffData) => {
  if (isLoading.value) return; // Prevent multiple submissions

  try {
    if (currentStaffToEdit.value) {
      // Editing existing staff
      const result = await resourceStore.updateStaff(staffData.id, staffData);
      if (result.success) {
        toast.success(`Staff member '${staffData.name}' updated successfully!`);
      } else {
        toast.error(`Failed to update staff member: ${result.error}`);
      }
    } else {
      // Adding new staff
      const result = await resourceStore.addStaff(staffData);
      if (result.success) {
        toast.success(`Staff member '${staffData.name}' added successfully!`);
      } else {
        toast.error(`Failed to add staff member: ${result.error}`);
      }
    }
    showAddStaffForm.value = false;
    currentStaffToEdit.value = null;
  } catch (err) {
    toast.error(`An error occurred: ${err.message}`);
  }
};

const viewStaffAvailability = (staffItem) => {
  openAvailabilityCalendar(staffItem, 'staff');
};

const deleteStaff = (staffItem) => {
  openConfirmationModal(
    staffItem,
    'staff',
    'Delete Staff Member?',
    `Are you sure you want to delete staff member "${staffItem.name}"? This action cannot be undone.`
  );
};

// --- Equipment Management State & Logic ---
const showAddEquipmentForm = ref(false);
const currentEquipmentToEdit = ref(null);

// Computed property for available equipment
const availableEquipment = computed(() => resourceStore.availableEquipment);

const openEquipmentFormForAdd = () => {
  currentEquipmentToEdit.value = null;
  showAddEquipmentForm.value = true;
};

const openEquipmentFormForEdit = (equipmentItem) => {
  currentEquipmentToEdit.value = { ...equipmentItem };
  showAddEquipmentForm.value = true;
};

const handleCancelEquipmentForm = () => {
  showAddEquipmentForm.value = false;
  currentEquipmentToEdit.value = null;
};

const handleSaveEquipment = async (equipmentData) => {
  if (isLoading.value) return; // Prevent multiple submissions

  try {
    if (currentEquipmentToEdit.value) {
      // Editing existing equipment
      const result = await resourceStore.updateEquipment(equipmentData.id, equipmentData);
      if (result.success) {
        toast.success(`Equipment '${equipmentData.name}' updated successfully!`);
      } else {
        toast.error(`Failed to update equipment: ${result.error}`);
      }
    } else {
      // Adding new equipment
      const result = await resourceStore.addEquipment(equipmentData);
      if (result.success) {
        toast.success(`Equipment '${equipmentData.name}' added successfully!`);
      } else {
        toast.error(`Failed to add equipment: ${result.error}`);
      }
    }
    showAddEquipmentForm.value = false;
    currentEquipmentToEdit.value = null;
  } catch (err) {
    toast.error(`An error occurred: ${err.message}`);
  }
};

const viewEquipmentAvailability = (equipmentItem) => {
  openAvailabilityCalendar(equipmentItem, 'equipment');
};

const deleteEquipment = (equipmentItem) => {
  openConfirmationModal(
    equipmentItem,
    'equipment',
    'Delete Equipment?',
    `Are you sure you want to delete equipment "${equipmentItem.name}"? This action cannot be undone.`
  );
};

// Removed duplicate deleteEquipment function

// TODO: Add backend integration for all CRUD operations
// TODO: Add form validation to all forms
// TODO: Improve UI/UX (e.g., loading states, success/error notifications)

</script>

<style scoped>
.resource-management-container {
  padding: 20px;
  font-family: sans-serif;
}

.tabs {
  display: flex;
  margin-bottom: 20px;
  border-bottom: 1px solid #ccc;
}

.tabs button {
  padding: 10px 20px;
  cursor: pointer;
  border: none;
  background-color: transparent;
  font-size: 16px;
  border-bottom: 3px solid transparent; /* For active state */
  margin-bottom: -1px; /* Align with container's border */
}

.tabs button.active {
  border-bottom: 3px solid #007bff;
  color: #007bff;
  font-weight: bold;
}

.tab-content .resource-section {
  margin-bottom: 30px;
}

.resource-section h2 {
  margin-bottom: 15px;
  color: #333;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
}

.button-primary {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  margin-bottom: 15px; /* Space before the table or form */
}

.button-primary:hover {
  background-color: #0056b3;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 15px;
}

tr:nth-child(even) {
    background-color: #f8f9fa;
}

th, td {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: left;
}

th {
  background-color: #e9ecef;
  color: #495057;
  font-weight: bold;
}

.button-small {
  padding: 5px 10px;
  font-size: 12px;
  margin-right: 5px;
  cursor: pointer;
  border-radius: 4px;
  border: 1px solid #ccc;
  background-color: #f8f9fa;
}

.button-small:hover {
  background-color: #e2e6ea;
}

.button-danger {
  background-color: #dc3545;
  color: white;
  border-color: #dc3545;
}

.button-danger:hover {
  background-color: #c82333;
  border-color: #bd2130;
}

.no-items {
    text-align: center;
    color: #6c757d;
    padding: 20px;
    font-style: italic;
}

/* Status-specific styling */
.status-active,
.status-available {
  color: #28a745; /* Green */
  font-weight: bold;
}

.status-under-maintenance {
  color: #ffc107; /* Yellow */
  font-weight: bold;
}

.status-inactive,
.status-on-leave,
.status-retired {
  color: #dc3545; /* Red */
  font-weight: bold;
}

.status-in-use {
    color: #fd7e14; /* Orange */
    font-weight: bold;
}

/* Loading indicator styles */
.loading-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 30px;
  color: var(--color-dark-gray);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(0, 123, 255, 0.1);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
  margin-bottom: 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Modal styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  width: 90%;
  max-width: 800px;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
}

.availability-modal {
  padding: 0;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  border-bottom: 1px solid #eee;
}

.modal-header h3 {
  margin: 0;
  color: #333;
}

.close-button {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #666;
}

.close-button:hover {
  color: #333;
}

.modal-body {
  padding: 0;
}

</style>


================================================
FILE: src/components/SchedulingEfficiencyReports.vue
================================================
<template>
  <div class="efficiency-reports">
    <h1>Scheduling Efficiency Reports</h1>
    
    <!-- Report Controls -->
    <div class="report-controls">
      <div class="filter-section">
        <h3>Filters</h3>
        <div class="filter-group">
          <label for="metric-type">Efficiency Metric</label>
          <select id="metric-type" v-model="selectedMetricType">
            <option value="sdst">SDST Efficiency</option>
            <option value="turnaround">Turnaround Time</option>
            <option value="ontime">On-Time Start Rate</option>
            <option value="overtime">Overtime Analysis</option>
          </select>
        </div>
        
        <div class="filter-group">
          <label for="date-range">Date Range</label>
          <select id="date-range" v-model="selectedDateRange">
            <option value="last7">Last 7 Days</option>
            <option value="last30">Last 30 Days</option>
            <option value="thisMonth">This Month</option>
            <option value="lastMonth">Last Month</option>
            <option value="custom">Custom Range</option>
          </select>
        </div>
        
        <div v-if="selectedDateRange === 'custom'" class="custom-date-range">
          <div class="date-input">
            <label for="start-date">Start Date</label>
            <input 
              type="date" 
              id="start-date" 
              v-model="customDateRange.start"
            >
          </div>
          <div class="date-input">
            <label for="end-date">End Date</label>
            <input 
              type="date" 
              id="end-date" 
              v-model="customDateRange.end"
            >
          </div>
        </div>
        
        <button class="apply-button" @click="applyFilters">Apply Filters</button>
      </div>
    </div>
    
    <!-- Loading Indicator -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="spinner"></div>
      <p>Loading report data...</p>
    </div>
    
    <!-- Report Content -->
    <div v-else class="report-content">
      <h2>{{ reportTitle }}</h2>
      
      <!-- SDST Efficiency Report -->
      <div v-if="selectedMetricType === 'sdst'" class="sdst-efficiency">
        <div class="summary-cards">
          <div class="metric-card">
            <h3>Average SDST</h3>
            <div class="metric-value">{{ sdstData.averageSDST }} min</div>
            <div class="metric-description">Average setup time between surgeries</div>
          </div>
          
          <div class="metric-card">
            <h3>SDST % of OR Time</h3>
            <div class="metric-value">{{ formatPercentage(sdstData.sdstPercentage) }}</div>
            <div class="metric-description">Percentage of total OR time spent on setup</div>
          </div>
          
          <div class="metric-card">
            <h3>Potential Time Savings</h3>
            <div class="metric-value">{{ sdstData.potentialSavings }} min/day</div>
            <div class="metric-description">Estimated time that could be saved with optimal scheduling</div>
          </div>
        </div>
        
        <div class="efficiency-tables">
          <div class="efficiency-table">
            <h3>Most Efficient Transitions</h3>
            <table>
              <thead>
                <tr>
                  <th>From</th>
                  <th>To</th>
                  <th>Avg. Time</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>APPEN</td>
                  <td>KNEE</td>
                  <td>15 min</td>
                </tr>
                <tr>
                  <td>KNEE</td>
                  <td>HIPRE</td>
                  <td>15 min</td>
                </tr>
                <tr>
                  <td>HERNI</td>
                  <td>APPEN</td>
                  <td>15 min</td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <div class="efficiency-table">
            <h3>Least Efficient Transitions</h3>
            <table>
              <thead>
                <tr>
                  <th>From</th>
                  <th>To</th>
                  <th>Avg. Time</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>CABG</td>
                  <td>APPEN</td>
                  <td>45 min</td>
                </tr>
                <tr>
                  <td>CABG</td>
                  <td>CATAR</td>
                  <td>45 min</td>
                </tr>
                <tr>
                  <td>HIPRE</td>
                  <td>CABG</td>
                  <td>45 min</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        
        <div class="recommendations">
          <h3>Recommendations</h3>
          <ul>
            <li>Group similar surgery types together to minimize SDST</li>
            <li>Schedule CABG procedures at the end of the day when possible</li>
            <li>Consider dedicated ORs for specific surgery types to reduce setup times</li>
          </ul>
        </div>
      </div>
      
      <!-- Turnaround Time Report -->
      <div v-else-if="selectedMetricType === 'turnaround'" class="turnaround-time">
        <!-- Turnaround time report content would go here -->
        <p>Turnaround Time Report content will be implemented in the next phase.</p>
      </div>
      
      <!-- On-Time Start Rate Report -->
      <div v-else-if="selectedMetricType === 'ontime'" class="ontime-start">
        <!-- On-time start report content would go here -->
        <p>On-Time Start Rate Report content will be implemented in the next phase.</p>
      </div>
      
      <!-- Overtime Analysis Report -->
      <div v-else-if="selectedMetricType === 'overtime'" class="overtime-analysis">
        <!-- Overtime analysis report content would go here -->
        <p>Overtime Analysis Report content will be implemented in the next phase.</p>
      </div>
      
      <!-- Export Options -->
      <div class="export-options">
        <button @click="exportToPDF">Export to PDF</button>
        <button @click="exportToCSV">Export to CSV</button>
        <button @click="saveAsCustomReport">Save as Custom Report</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useAnalyticsStore } from '@/stores/analyticsStore';
import { storeToRefs } from 'pinia';

const analyticsStore = useAnalyticsStore();
const { isLoading, error } = storeToRefs(analyticsStore);

// Filter state
const selectedMetricType = ref('sdst');
const selectedDateRange = ref('last30');
const customDateRange = ref({
  start: '',
  end: ''
});

// Mock data for SDST efficiency
const sdstData = ref({
  averageSDST: 22.5,
  sdstPercentage: 0.12,
  potentialSavings: 120,
  mostEfficientTransitions: [
    { from: 'APPEN', to: 'KNEE', time: 15 },
    { from: 'KNEE', to: 'HIPRE', time: 15 },
    { from: 'HERNI', to: 'APPEN', time: 15 }
  ],
  leastEfficientTransitions: [
    { from: 'CABG', to: 'APPEN', time: 45 },
    { from: 'CABG', to: 'CATAR', time: 45 },
    { from: 'HIPRE', to: 'CABG', time: 45 }
  ]
});

// Computed properties
const reportTitle = computed(() => {
  switch (selectedMetricType.value) {
    case 'sdst':
      return 'SDST Efficiency Report';
    case 'turnaround':
      return 'Turnaround Time Analysis';
    case 'ontime':
      return 'On-Time Start Rate Analysis';
    case 'overtime':
      return 'Overtime Analysis';
    default:
      return 'Scheduling Efficiency Report';
  }
});

// Methods
const formatPercentage = (value) => {
  return `${Math.round(value * 100)}%`;
};

const applyFilters = async () => {
  // In a real app, this would update the date range in the store and reload the data
  console.log('Applying filters:', {
    metricType: selectedMetricType.value,
    dateRange: selectedDateRange.value,
    customDateRange: customDateRange.value
  });
  
  // Simulate loading
  isLoading.value = true;
  await new Promise(resolve => setTimeout(resolve, 1000));
  isLoading.value = false;
  
  // In a real app, we would update the report data here
};

const exportToPDF = () => {
  console.log('Exporting to PDF...');
  // In a real app, this would generate a PDF of the report
};

const exportToCSV = () => {
  console.log('Exporting to CSV...');
  // In a real app, this would generate a CSV of the report data
};

const saveAsCustomReport = () => {
  console.log('Saving as custom report...');
  // In a real app, this would save the current report configuration to the store
};

// Initialize the component
onMounted(async () => {
  // Set default date range
  const today = new Date();
  const thirtyDaysAgo = new Date(today);
  thirtyDaysAgo.setDate(today.getDate() - 30);
  
  customDateRange.value.start = thirtyDaysAgo.toISOString().split('T')[0];
  customDateRange.value.end = today.toISOString().split('T')[0];
  
  // Load initial data
  await applyFilters();
});
</script>

<style scoped>
.efficiency-reports {
  padding: var(--spacing-md);
  max-width: 1200px;
  margin: 0 auto;
}

h1, h2, h3 {
  margin-top: 0;
  color: var(--color-text);
}

h1 {
  margin-bottom: var(--spacing-lg);
}

h2 {
  margin-bottom: var(--spacing-md);
}

h3 {
  margin-bottom: var(--spacing-sm);
}

/* Report Controls */
.report-controls {
  margin-bottom: var(--spacing-lg);
}

.filter-section {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
}

.filter-group {
  margin-bottom: var(--spacing-sm);
}

.filter-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

select, input {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  background-color: var(--color-background);
}

.custom-date-range {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-sm);
}

.apply-button {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  margin-top: var(--spacing-sm);
}

/* Loading Overlay */
.loading-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(var(--color-primary-rgb), 0.1);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
  margin-bottom: var(--spacing-md);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* SDST Efficiency Report */
.summary-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.metric-card {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  text-align: center;
}

.metric-value {
  font-size: 2rem;
  font-weight: var(--font-weight-bold);
  margin: var(--spacing-sm) 0;
}

.metric-description {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.efficiency-tables {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.efficiency-table {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
}

.efficiency-table table {
  width: 100%;
  border-collapse: collapse;
}

.efficiency-table th, .efficiency-table td {
  padding: var(--spacing-sm);
  text-align: left;
  border-bottom: 1px solid var(--color-border);
}

.efficiency-table th {
  font-weight: var(--font-weight-bold);
  color: var(--color-text-secondary);
}

.recommendations {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  margin-bottom: var(--spacing-lg);
}

.recommendations ul {
  margin: 0;
  padding-left: var(--spacing-lg);
}

.recommendations li {
  margin-bottom: var(--spacing-xs);
}

/* Export Options */
.export-options {
  display: flex;
  gap: var(--spacing-md);
  justify-content: flex-end;
}

.export-options button {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .custom-date-range {
    grid-template-columns: 1fr;
  }
  
  .export-options {
    flex-direction: column;
    align-items: stretch;
  }
}
</style>



================================================
FILE: src/components/SchedulingScreen.vue
================================================
<template>
  <div class="scheduling-container">
    <!-- Toast Notifications and Keyboard Shortcuts Help -->
    <ToastNotification ref="toastRef" />
    <KeyboardShortcutsHelp ref="keyboardShortcutsRef" />

    <h1>Surgery Scheduling</h1>

    <div class="scheduling-layout">
      <!-- Left Panel: Pending Surgeries & Filters -->
      <aside class="left-panel">
        <h2>Pending Surgeries</h2>
        <p>Drag and drop surgeries from this list onto the schedule.</p>

        <div class="filters-section">
             <div class="filters-header">
                <h3>Filters</h3>
                <button
                  @click="filters.showAdvancedFilters = !filters.showAdvancedFilters"
                  class="btn btn-sm btn-link"
                >
                  {{ filters.showAdvancedFilters ? 'Hide Advanced' : 'Show Advanced' }}
                </button>
             </div>

             <!-- Basic Filters -->
             <div class="filter-group">
                <label for="filter-priority">Priority:</label>
                <select id="filter-priority" v-model="filters.priority" @change="applyFilters" class="form-control">
                    <option value="">All</option>
                    <option value="High">High</option>
                    <option value="Medium">Medium</option>
                    <option value="Low">Low</option>
                </select>
             </div>
             <div class="filter-group">
                <label for="filter-specialty">Specialty:</label>
                <input type="text" id="filter-specialty" v-model="filters.specialty" placeholder="e.g., Cardiac" @input="applyFilters" class="form-control">
             </div>
             <div class="filter-group">
                <label for="filter-status">Status:</label>
                <select id="filter-status" v-model="filters.status" @change="applyFilters" class="form-control">
                    <option value="">All</option>
                    <option value="Pending">Pending</option>
                    <option value="Scheduled">Scheduled</option>
                    <option value="Cancelled">Cancelled</option>
                </select>
             </div>

             <!-- Advanced Filters -->
             <div v-if="filters.showAdvancedFilters" class="advanced-filters">
                <div class="filter-group">
                   <label for="filter-surgeon">Surgeon:</label>
                   <input type="text" id="filter-surgeon" v-model="filters.surgeon" placeholder="e.g., Dr. Smith" @input="applyFilters" class="form-control">
                </div>
                <div class="filter-group">
                   <label for="filter-equipment">Equipment:</label>
                   <input type="text" id="filter-equipment" v-model="filters.equipment" placeholder="e.g., Heart-Lung Machine" @input="applyFilters" class="form-control">
                </div>
                <div class="filter-group">
                   <label>Date Range:</label>
                   <div class="date-range-inputs">
                      <input
                        type="date"
                        v-model="filters.dateRange.start"
                        class="form-control"
                        @change="applyFilters"
                      >
                      <span class="date-range-separator">to</span>
                      <input
                        type="date"
                        v-model="filters.dateRange.end"
                        class="form-control"
                        @change="applyFilters"
                      >
                   </div>
                </div>
             </div>

             <div class="filter-actions">
                <button @click="applyFilters" class="btn btn-sm btn-primary">Apply Filters</button>
                <button @click="resetFilters" class="btn btn-sm btn-secondary">Reset</button>
             </div>
         </div>

         <div class="sort-section">
             <h3>Sort By</h3>
             <div class="sort-controls">
                <select v-model="sortOptions.field" class="form-control">
                    <option value="priority">Priority</option>
                    <option value="patientName">Patient Name</option>
                    <option value="type">Surgery Type</option>
                    <option value="estimatedDuration">Duration</option>
                </select>
                <div class="sort-direction">
                    <button
                        @click="sortOptions.direction = 'asc'"
                        class="btn btn-sm"
                        :class="{'btn-primary': sortOptions.direction === 'asc', 'btn-secondary': sortOptions.direction !== 'asc'}"
                    >
                        ↑ Asc
                    </button>
                    <button
                        @click="sortOptions.direction = 'desc'"
                        class="btn btn-sm"
                        :class="{'btn-primary': sortOptions.direction === 'desc', 'btn-secondary': sortOptions.direction !== 'desc'}"
                    >
                        ↓ Desc
                    </button>
                </div>
             </div>
         </div>

        <!-- TODO: Implement drag functionality for these items -->
        <div class="pending-surgeries-list">
            <ul>
                <li
                    v-for="surgery in filteredPendingSurgeries"
                    :key="surgery.id"
                    class="pending-surgery-item"
                    :class="{
                      'selected': selectedSurgery && selectedSurgery.id === surgery.id,
                      [`priority-${surgery.priority.toLowerCase()}`]: true
                    }"
                    draggable="true"
                    @dragstart="handleDragStart(surgery, $event)"
                    @dragend="handleDragEnd($event)"
                    @click="selectSurgeryForDetails(surgery, 'pending')"
                >
                    <div class="item-header">
                      <div class="patient-info">
                        <span class="patient-name">{{ surgery.patientName || surgery.patientId }}</span>
                        <span class="patient-id" v-if="surgery.patientName">({{ surgery.patientId }})</span>
                      </div>
                      <span class="priority-badge" :class="`priority-${surgery.priority.toLowerCase()}`">
                        {{ surgery.priority }}
                      </span>
                    </div>

                    <div class="item-details">
                      <div class="surgery-type">
                        <span class="label">Type:</span>
                        <span class="value">{{ surgery.type }}</span>
                      </div>
                      <div class="surgery-full-type">
                        <span class="value">{{ surgery.fullType }}</span>
                      </div>
                      <div class="surgery-duration">
                        <span class="label">Duration:</span>
                        <span class="value">{{ surgery.estimatedDuration }} min</span>
                      </div>
                    </div>

                    <div class="item-status">
                      <span class="status-indicator" :class="`status-${surgery.status?.toLowerCase() || 'pending'}`"></span>
                      <span>{{ surgery.status || 'Pending' }}</span>
                    </div>

                    <div class="item-actions">
                        <button class="btn btn-sm btn-secondary" @click.stop="selectSurgeryForDetails(surgery, 'pending')">
                          <span class="icon">👁️</span> View
                        </button>
                        <button class="btn btn-sm btn-primary" @click.stop="scheduleSelectedSurgery(surgery)">
                          <span class="icon">📅</span> Schedule
                        </button>
                    </div>
                </li>
                <li v-if="filteredPendingSurgeries.length === 0" class="no-items">No pending surgeries matching filters.</li>
            </ul>
        </div>
      </aside>

      <!-- Main Panel: Master Schedule View (Gantt Chart) -->
      <main class="main-panel">
        <div class="schedule-header">
            <h2>Master Schedule View</h2>
            <div class="schedule-controls">
                <button @click="ganttNavigate('prev')" class="btn btn-sm btn-secondary">◀ Previous</button>
                <span class="current-date-range">{{ currentGanttViewDateRange }}</span>
                <button @click="ganttNavigate('next')" class="btn btn-sm btn-secondary">Next ▶</button>
                <button @click="ganttZoom('in')" class="btn btn-sm btn-secondary">Day View</button>
                <button @click="ganttZoom('out')" class="btn btn-sm btn-secondary">Week View</button>
                <button @click="showCreateNewSurgeryForm" class="btn btn-sm btn-primary">Create New Surgery</button>
            </div>
        </div>

        <!--
          Gantt Chart Integration Point
          This div will host the Gantt chart component.
          Consider creating a dedicated child component (e.g., <GanttChartComponent />)
          to encapsulate the Gantt library's logic and pass data via props.
        -->
        <div
          id="gantt-chart-container"
          class="gantt-chart-container"
          :class="{
            'drag-over': draggedSurgery && dropTarget.orId,
            'invalid': draggedSurgery && !dropTarget.isValid
          }"
          :data-drop-message="dropTarget.message"
          @drop="handleDropOnGantt($event)"
          @dragover="handleDragOver($event, 'OR1')"
        >
          <div v-if="isLoading" class="loading-overlay">
            <div class="spinner"></div>
            <p>Loading schedule data...</p>
          </div>
          <div v-else-if="!isGanttInitialized" class="gantt-placeholder-text">
            Gantt Chart Area - Awaiting Library Integration
            <br>
            (Drop pending surgeries here to schedule)
          </div>
          <div v-else>
            <!-- Actual Gantt Chart Component -->
            <GanttChart />

            <div class="gantt-drop-message">
              Drag pending surgeries here to schedule them.
            </div>
          </div>
        </div>

        <div class="gantt-info-panel">
            <p><strong>SDST (Setup, Disinfection, Sterilization Time):</strong> Not yet calculated. Will be factored into scheduling.</p>
            <p><strong>Resource Conflicts:</strong> Conflict detection pending Gantt integration.</p>
        </div>
      </main>

      <!-- Right Panel: Surgery Details / Create New -->
      <aside class="right-panel">
        <div v-if="selectedSurgery">
          <h2>Surgery Details ({{ selectedSurgerySource === 'pending' ? 'Pending' : 'Scheduled' }})</h2>
          <form @submit.prevent="saveSurgeryDetails">
            <div v-if="formErrors.general" class="form-error-message general-error">
              {{ formErrors.general }}
            </div>

            <div class="form-group" :class="{'has-error': formSubmitted && formErrors.patientId}">
              <label for="patientId">Patient ID: <span class="required">*</span></label>
              <input
                type="text"
                id="patientId"
                v-model="selectedSurgery.patientId"
                :disabled="formMode === 'view'"
                class="form-control"
                :class="{'is-invalid': formSubmitted && formErrors.patientId}"
              >
              <div v-if="formSubmitted && formErrors.patientId" class="form-error-message">
                {{ formErrors.patientId }}
              </div>
            </div>

            <div class="form-group" :class="{'has-error': formSubmitted && formErrors.patientName}">
              <label for="patientName">Patient Name: <span class="required">*</span></label>
              <input
                type="text"
                id="patientName"
                v-model="selectedSurgery.patientName"
                :disabled="formMode === 'view'"
                class="form-control"
                :class="{'is-invalid': formSubmitted && formErrors.patientName}"
              >
              <div v-if="formSubmitted && formErrors.patientName" class="form-error-message">
                {{ formErrors.patientName }}
              </div>
            </div>

            <div class="form-group" :class="{'has-error': formSubmitted && formErrors.type}">
              <label for="surgeryType">Surgery Type: <span class="required">*</span></label>
              <select
                id="surgeryType"
                v-model="selectedSurgery.type"
                :disabled="formMode === 'view'"
                class="form-control"
                :class="{'is-invalid': formSubmitted && formErrors.type}"
                @change="updateFullType"
              >
                <option value="">Select a surgery type</option>
                <option value="CABG">CABG</option>
                <option value="KNEE">Knee Replacement</option>
                <option value="APPEN">Appendectomy</option>
                <option value="HERNI">Hernia Repair</option>
                <option value="CATAR">Cataract Surgery</option>
                <option value="HIPRE">Hip Replacement</option>
              </select>
              <div v-if="formSubmitted && formErrors.type" class="form-error-message">
                {{ formErrors.type }}
              </div>
            </div>

            <div class="form-group" :class="{'has-error': formSubmitted && formErrors.fullType}">
              <label for="fullType">Full Type: <span class="required">*</span></label>
              <input
                type="text"
                id="fullType"
                v-model="selectedSurgery.fullType"
                :disabled="formMode === 'view'"
                class="form-control"
                :class="{'is-invalid': formSubmitted && formErrors.fullType}"
              >
              <div v-if="formSubmitted && formErrors.fullType" class="form-error-message">
                {{ formErrors.fullType }}
              </div>
            </div>

            <div class="form-group" :class="{'has-error': formSubmitted && formErrors.estimatedDuration}">
              <label for="estimatedDuration">Estimated Duration (min): <span class="required">*</span></label>
              <input
                type="number"
                id="estimatedDuration"
                v-model.number="selectedSurgery.estimatedDuration"
                :disabled="formMode === 'view'"
                class="form-control"
                :class="{'is-invalid': formSubmitted && formErrors.estimatedDuration}"
                min="1"
              >
              <div v-if="formSubmitted && formErrors.estimatedDuration" class="form-error-message">
                {{ formErrors.estimatedDuration }}
              </div>
            </div>
            <div class="form-group">
              <label for="priority">Priority Level:</label>
              <select id="priority" v-model="selectedSurgery.priority" :disabled="formMode === 'view'" class="form-control">
                <option value="High">High</option>
                <option value="Medium">Medium</option>
                <option value="Low">Low</option>
              </select>
            </div>
            <div class="form-group" v-if="selectedSurgerySource === 'scheduled'">
              <label for="scheduledTime">Scheduled Time:</label>
              <input type="datetime-local" id="scheduledTime" v-model="selectedSurgery.scheduledTime" :disabled="formMode === 'view'" class="form-control">
            </div>
            <div class="form-group">
              <label for="status">Status:</label>
              <select id="status" v-model="selectedSurgery.status" :disabled="formMode === 'view'" class="form-control">
                <option value="Pending">Pending</option>
                <option value="Scheduled">Scheduled</option>
                <option value="In Progress">In Progress</option>
                <option value="Completed">Completed</option>
                <option value="Cancelled">Cancelled</option>
              </select>
            </div>

            <div class="form-group">
              <label for="requiredSurgeons">Required Surgeons:</label>
              <input type="text" id="requiredSurgeons" v-model="selectedSurgery.requiredSurgeons" :disabled="formMode === 'view'" class="form-control">
              <small class="form-text text-muted">Enter surgeon names separated by commas</small>
            </div>

            <div class="form-group">
              <label for="requiredStaffRoles">Required Staff Roles:</label>
              <input type="text" id="requiredStaffRoles" v-model="selectedSurgery.requiredStaffRoles" :disabled="formMode === 'view'" class="form-control">
              <small class="form-text text-muted">Enter staff roles separated by commas</small>
            </div>

            <div class="form-group">
              <label for="requiredEquipment">Required Equipment:</label>
              <input type="text" id="requiredEquipment" v-model="selectedSurgery.requiredEquipment" :disabled="formMode === 'view'" class="form-control">
              <small class="form-text text-muted">Enter equipment names separated by commas</small>
            </div>

            <div class="form-actions">
              <button type="button" v-if="formMode === 'view'" @click="formMode = 'edit'" class="btn btn-primary">Edit</button>
              <button type="submit" v-if="formMode !== 'view'" class="btn btn-primary">Save Changes</button>
              <button type="button" @click="clearSelectionOrCancel" class="btn btn-secondary">{{ formMode === 'new' ? 'Cancel' : 'Close' }}</button>
              <button type="button" v-if="selectedSurgerySource === 'pending' && formMode !== 'new'" @click="scheduleSelectedSurgery" class="btn btn-primary">Schedule This Surgery</button>
            </div>
          </form>
        </div>
        <div v-else>
          <h2>Surgery Details</h2>
          <p>Select a pending surgery to view its details, or drag it to the schedule. Click "Create New Surgery" to add a new entry.</p>

          <!-- Show form fields for reference/testing -->
          <div class="form-preview">
            <h3>Surgery Form Fields</h3>
            <div class="form-group">
              <label>Patient ID:</label>
              <input type="text" class="form-control" disabled placeholder="Enter Patient ID">
            </div>
            <div class="form-group">
              <label>Patient Name:</label>
              <input type="text" class="form-control" disabled placeholder="Enter Patient Name">
            </div>
            <div class="form-group">
              <label>Surgery Type:</label>
              <select class="form-control" disabled>
                <option>Select a surgery type</option>
              </select>
            </div>
            <div class="form-group">
              <label>Estimated Duration (min):</label>
              <input type="number" class="form-control" disabled placeholder="Enter duration">
            </div>
            <div class="form-group">
              <label>Priority Level:</label>
              <select class="form-control" disabled>
                <option>Select priority</option>
              </select>
            </div>
          </div>
        </div>
      </aside>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch, nextTick } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';
import { useNotificationStore } from '@/stores/notificationStore';
import { storeToRefs } from 'pinia';
import GanttChart from './GanttChart.vue';
import ToastNotification from './ToastNotification.vue';
import KeyboardShortcutsHelp from './KeyboardShortcutsHelp.vue';
import keyboardShortcuts from '@/services/keyboardShortcuts';

// Initialize the stores
const scheduleStore = useScheduleStore();
const notificationStore = useNotificationStore();
const {
  pendingSurgeries: storePendingSurgeries,
  scheduledSurgeries: storeScheduledSurgeries,
  selectedSurgeryId,
  isLoading
} = storeToRefs(scheduleStore);

// Component refs
const toastRef = ref(null);
const keyboardShortcutsRef = ref(null);

// --- State ---
const selectedSurgery = ref(null);
const selectedSurgerySource = ref(''); // 'pending' or 'scheduled'
const formMode = ref('view'); // 'view', 'edit', 'new'
const formErrors = ref({}); // To store validation errors
const formSubmitted = ref(false); // To track if form was submitted (for validation display)

const filters = ref({
  priority: '',
  specialty: '',
  status: '',
  surgeon: '',
  equipment: '',
  dateRange: {
    start: null,
    end: null
  },
  showAdvancedFilters: false
});

// Sorting options for pending surgeries list
const sortOptions = ref({
  field: 'priority', // Default sort field
  direction: 'desc' // 'asc' or 'desc'
});

const currentScheduleDateRange = ref('Today'); // Placeholder for date range display
const isGanttInitialized = ref(false); // To track if the Gantt library is loaded

// --- Data for Gantt Chart (to be passed as props or managed by the Gantt library wrapper) ---
const ganttTasks = ref([]); // Holds tasks formatted for the Gantt library
const ganttResources = ref([]); // Holds resources (ORs, Surgeons, Staff, Equipment)

// --- Computed Properties ---
const filteredPendingSurgeries = computed(() => {
  if (!storePendingSurgeries.value) return []; // Ensure pendingSurgeries is not null or undefined

  // First filter the surgeries
  const filtered = storePendingSurgeries.value.filter(surgery => {
    // Basic filters
    const matchesPriority = !filters.value.priority || surgery.priority === filters.value.priority;
    const matchesSpecialty = !filters.value.specialty ||
      (surgery.fullType && surgery.fullType.toLowerCase().includes(filters.value.specialty.toLowerCase()));
    const matchesStatus = !filters.value.status || surgery.status === filters.value.status;

    // Advanced filters
    const matchesSurgeon = !filters.value.surgeon ||
      (surgery.requiredSurgeons &&
        (Array.isArray(surgery.requiredSurgeons)
          ? surgery.requiredSurgeons.some(s => s.toLowerCase().includes(filters.value.surgeon.toLowerCase()))
          : surgery.requiredSurgeons.toLowerCase().includes(filters.value.surgeon.toLowerCase())));

    const matchesEquipment = !filters.value.equipment ||
      (surgery.requiredEquipment &&
        (Array.isArray(surgery.requiredEquipment)
          ? surgery.requiredEquipment.some(e => e.toLowerCase().includes(filters.value.equipment.toLowerCase()))
          : surgery.requiredEquipment.toLowerCase().includes(filters.value.equipment.toLowerCase())));

    // Date range filter
    let matchesDateRange = true;
    if (filters.value.dateRange.start && filters.value.dateRange.end) {
      const requestedDate = surgery.requestedDate ? new Date(surgery.requestedDate) : null;
      if (requestedDate) {
        const startDate = new Date(filters.value.dateRange.start);
        const endDate = new Date(filters.value.dateRange.end);
        // Set time to 00:00:00 for start and 23:59:59 for end to include the entire day
        startDate.setHours(0, 0, 0, 0);
        endDate.setHours(23, 59, 59, 999);
        matchesDateRange = requestedDate >= startDate && requestedDate <= endDate;
      }
    }

    return matchesPriority && matchesSpecialty && matchesStatus &&
           matchesSurgeon && matchesEquipment && matchesDateRange;
  });

  // Then sort the filtered surgeries
  return sortSurgeries(filtered, sortOptions.value.field, sortOptions.value.direction);
});

// Helper function to sort surgeries
const sortSurgeries = (surgeries, field, direction) => {
  return [...surgeries].sort((a, b) => {
    let comparison = 0;

    // Handle different field types
    switch (field) {
      case 'priority':
        // Convert priority to numeric value for sorting
        const priorityValues = { 'High': 3, 'Medium': 2, 'Low': 1 };
        comparison = priorityValues[a.priority] - priorityValues[b.priority];
        break;
      case 'estimatedDuration':
        comparison = a.estimatedDuration - b.estimatedDuration;
        break;
      case 'patientName':
        comparison = (a.patientName || a.patientId).localeCompare(b.patientName || b.patientId);
        break;
      case 'type':
        comparison = a.type.localeCompare(b.type);
        break;
      default:
        comparison = 0;
    }

    // Apply sort direction
    return direction === 'asc' ? comparison : -comparison;
  });
};

// Format the current date range for display
const currentGanttViewDateRange = computed(() => {
  const { currentDateRange, ganttViewMode } = scheduleStore;

  if (ganttViewMode === 'Day') {
    return currentDateRange.start.toLocaleDateString(undefined, {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  } else if (ganttViewMode === 'Week') {
    return `${currentDateRange.start.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} -
            ${currentDateRange.end.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}`;
  }

  return 'Today';
});

// --- Methods ---

// Initialize data from the store
const initializeData = () => {
  // Load data from the store
  if (!scheduleStore.dataInitialized) {
    scheduleStore.loadInitialData();
  }

  // Set isGanttInitialized to true since we're using the actual GanttChart component
  // For testing purposes, we'll keep it false initially to show the placeholder
  // isGanttInitialized.value = true;
};

// Helper to transform surgery data to Gantt task format (example)
const transformSurgeryToGanttTask = (surgery, scheduledTime) => {
  // This is highly dependent on the chosen Gantt library's expected format
  return {
    id: surgery.id,
    text: `${surgery.patientId} - ${surgery.type}`,
    startDate: scheduledTime, // Ensure this is a valid date/time format for the library
    duration: surgery.estimatedDuration,
    durationUnit: 'minute', // Or 'hour', 'day' depending on library
    priority: surgery.priority,
    status: surgery.status,
    // Add other relevant fields: resourceId (OR, surgeon), dependencies, color, etc.
    ...surgery // Spread other surgery details that might be useful
  };
};

// Helper to transform scheduled surgeries (if fetched separately) to Gantt tasks
const transformScheduledSurgeriesToGanttTasks = () => {
  ganttTasks.value = storeScheduledSurgeries.value.map(surgery => {
    // Assuming surgery objects in scheduledSurgeries have a 'scheduledTime' and 'id'
    return transformSurgeryToGanttTask(surgery, surgery.startTime);
  });
  // TODO: Notify Gantt chart to refresh/load new tasks
};

// Watch for changes in storeScheduledSurgeries to update Gantt tasks
// This is a basic example; a real Gantt integration might handle this internally or via its API
watch(storeScheduledSurgeries, (newScheduledList) => {
  // transformScheduledSurgeriesToGanttTasks();
  console.log('Scheduled surgeries updated, Gantt tasks should refresh:', newScheduledList);
}, { deep: true });

const applyFilters = () => {
  // The computed property `filteredPendingSurgeries` will update automatically.
  // This function is here if any imperative logic is needed on filter change.
  console.log('Filters applied:', filters.value);
};

// Reset all filters to their default values
const resetFilters = () => {
  filters.value = {
    priority: '',
    specialty: '',
    status: '',
    surgeon: '',
    equipment: '',
    dateRange: {
      start: null,
      end: null
    },
    showAdvancedFilters: filters.value.showAdvancedFilters // Keep the advanced filters visibility state
  };
  console.log('Filters reset');
};

const selectSurgeryForDetails = (surgery, source) => {
  selectedSurgery.value = { ...surgery }; // Clone to avoid direct mutation if editing
  selectedSurgerySource.value = source;
  formMode.value = 'view';
  console.log(`Viewing ${source} surgery:`, surgery.id);

  // Also update the store's selected surgery
  if (source === 'scheduled') {
    scheduleStore.selectSurgery(surgery.id);
  }
};

const showCreateNewSurgeryForm = () => {
  // Reset form state
  formSubmitted.value = false;
  formErrors.value = {};

  selectedSurgery.value = {
    patientId: '',
    patientName: '',
    type: '',
    fullType: '',
    estimatedDuration: 60,
    duration: 60,
    priority: 'Medium',
    status: 'Pending',
    requiredSurgeons: [],
    requiredStaffRoles: [],
    requiredEquipment: []
  };
  selectedSurgerySource.value = 'new';
  formMode.value = 'new';
  console.log('Showing form to create new surgery');
};

// Validate the surgery form
const validateSurgeryForm = () => {
  formSubmitted.value = true;
  const errors = {};
  const surgery = selectedSurgery.value;

  // Required fields validation
  if (!surgery.patientId?.trim()) {
    errors.patientId = 'Patient ID is required';
  }

  if (!surgery.patientName?.trim()) {
    errors.patientName = 'Patient Name is required';
  }

  if (!surgery.type?.trim()) {
    errors.type = 'Surgery Type is required';
  }

  if (!surgery.fullType?.trim()) {
    errors.fullType = 'Full Type is required';
  }

  // Numeric validation
  if (!surgery.estimatedDuration || surgery.estimatedDuration <= 0) {
    errors.estimatedDuration = 'Duration must be greater than 0';
  }

  // Array fields validation (convert string to array if needed)
  if (typeof surgery.requiredSurgeons === 'string') {
    surgery.requiredSurgeons = surgery.requiredSurgeons.split(',').map(s => s.trim()).filter(Boolean);
  }

  if (typeof surgery.requiredStaffRoles === 'string') {
    surgery.requiredStaffRoles = surgery.requiredStaffRoles.split(',').map(s => s.trim()).filter(Boolean);
  }

  if (typeof surgery.requiredEquipment === 'string') {
    surgery.requiredEquipment = surgery.requiredEquipment.split(',').map(s => s.trim()).filter(Boolean);
  }

  formErrors.value = errors;
  return Object.keys(errors).length === 0;
};

const saveSurgeryDetails = async () => {
  if (!selectedSurgery.value) return;

  // Validate the form
  if (!validateSurgeryForm()) {
    console.error('Form validation failed:', formErrors.value);
    notificationStore.error('Please fix the validation errors before saving.');
    return;
  }

  console.log('Saving surgery details:', selectedSurgery.value);

  try {
    if (formMode.value === 'new') {
      // Add to pending list
      await scheduleStore.addPendingSurgery(selectedSurgery.value);
      notificationStore.success('New surgery added to pending list.', {
        title: 'Surgery Added',
        action: {
          label: 'Schedule Now',
          callback: () => scheduleSelectedSurgery(selectedSurgery.value)
        }
      });
    } else if (selectedSurgerySource.value === 'pending') {
      // Update pending surgery
      await scheduleStore.updatePendingSurgery(selectedSurgery.value);
      notificationStore.success('Pending surgery details updated.', {
        title: 'Surgery Updated'
      });
    } else if (selectedSurgerySource.value === 'scheduled') {
      // Update scheduled surgery
      await scheduleStore.updateScheduledSurgery(selectedSurgery.value);
      notificationStore.success('Scheduled surgery details updated.', {
        title: 'Surgery Updated'
      });
    }

    // Reset form state
    formMode.value = 'view';
    formSubmitted.value = false;
    formErrors.value = {};
  } catch (error) {
    console.error(`Error saving surgery: ${error.message}`);
    formErrors.value.general = `Error saving surgery: ${error.message}`;
    notificationStore.error(`Error saving surgery: ${error.message}`, {
      title: 'Save Failed'
    });
  }
};

// Helper to update the full type based on the selected surgery type
const updateFullType = () => {
  if (!selectedSurgery.value) return;

  const typeMap = {
    'CABG': 'Coronary Artery Bypass Graft',
    'KNEE': 'Total Knee Replacement',
    'APPEN': 'Appendectomy',
    'HERNI': 'Hernia Repair',
    'CATAR': 'Cataract Surgery',
    'HIPRE': 'Total Hip Replacement'
  };

  if (selectedSurgery.value.type && typeMap[selectedSurgery.value.type]) {
    selectedSurgery.value.fullType = typeMap[selectedSurgery.value.type];
  }
};

const clearSelectionOrCancel = () => {
  selectedSurgery.value = null;
  selectedSurgerySource.value = '';
  formMode.value = 'view';
  formSubmitted.value = false;
  formErrors.value = {};

  // Clear the store's selected surgery
  scheduleStore.clearSelectedSurgery();

  console.log('Selection cleared or form cancelled');
};

const scheduleSelectedSurgery = async () => {
  if (!selectedSurgery.value || selectedSurgerySource.value !== 'pending') return;

  try {
    // Schedule the surgery using the store
    const scheduledSurgery = await scheduleStore.schedulePendingSurgery(
      selectedSurgery.value.id,
      'OR1', // Default OR - in a real app, this would be selected by the user
      new Date() // Default time - in a real app, this would be selected by the user
    );

    notificationStore.success(`Surgery ${selectedSurgery.value.patientName || selectedSurgery.value.patientId} scheduled.`, {
      title: 'Surgery Scheduled',
      action: {
        label: 'View Schedule',
        callback: () => {
          // Scroll to the Gantt chart
          document.getElementById('gantt-chart-container')?.scrollIntoView({ behavior: 'smooth' });
        }
      }
    });

    // View the newly scheduled surgery
    if (scheduledSurgery) {
      selectSurgeryForDetails(scheduledSurgery, 'scheduled');
    } else {
      clearSelectionOrCancel();
    }
  } catch (error) {
    notificationStore.error(`Error scheduling surgery: ${error.message}`, {
      title: 'Scheduling Failed'
    });
  }
};

// --- Drag and Drop Handlers ---
const draggedSurgery = ref(null);
const dragGhost = ref(null);
const dropTarget = ref({
  orId: null,
  time: null,
  isValid: true,
  message: ''
});

const handleDragStart = (surgery, event) => {
  console.log('Dragging surgery:', surgery.id);

  // Store the dragged surgery for reference
  draggedSurgery.value = surgery;

  // Set data for drop handling
  event.dataTransfer.setData('application/json', JSON.stringify(surgery));
  event.dataTransfer.effectAllowed = 'move';

  // Add visual feedback for dragging
  event.target.classList.add('dragging');

  // Create a custom drag image/ghost element
  const ghostElement = document.createElement('div');
  ghostElement.classList.add('surgery-drag-ghost');
  ghostElement.innerHTML = `
    <div class="ghost-priority ${surgery.priority.toLowerCase()}"></div>
    <div class="ghost-content">
      <div class="ghost-title">${surgery.patientName || surgery.patientId}</div>
      <div class="ghost-type">${surgery.type} - ${surgery.estimatedDuration} min</div>
    </div>
  `;

  // Add the ghost element to the document temporarily
  document.body.appendChild(ghostElement);
  dragGhost.value = ghostElement;

  // Set the custom drag image
  event.dataTransfer.setDragImage(ghostElement, 20, 20);

  // Hide the ghost element (it will still be used as drag image)
  setTimeout(() => {
    ghostElement.style.position = 'absolute';
    ghostElement.style.left = '-9999px';
  }, 0);
};

const handleDragEnd = (event) => {
  // Remove the dragging class
  event.target.classList.remove('dragging');

  // Clean up the ghost element
  if (dragGhost.value && dragGhost.value.parentNode) {
    dragGhost.value.parentNode.removeChild(dragGhost.value);
    dragGhost.value = null;
  }

  // Reset the dragged surgery
  draggedSurgery.value = null;

  // Reset drop target
  dropTarget.value = {
    orId: null,
    time: null,
    isValid: true,
    message: ''
  };
};

const handleDragOver = (event, orId) => {
  event.preventDefault();

  if (!draggedSurgery.value) return;

  // Calculate the time based on the mouse position
  // This is a simplified example - in a real app, you would calculate the exact time
  // based on the Gantt chart's time scale and the mouse position
  const rect = event.currentTarget.getBoundingClientRect();
  const relativeX = event.clientX - rect.left;
  const percentageX = relativeX / rect.width;

  // Get the current date range from the store
  const { start, end } = scheduleStore.currentDateRange;
  const totalMinutes = (end.getTime() - start.getTime()) / (60 * 1000);
  const minutesFromStart = totalMinutes * percentageX;

  // Calculate the target time
  const targetTime = new Date(start.getTime() + minutesFromStart * 60 * 1000);

  // Round to nearest 15 minutes for better UX
  const roundedMinutes = Math.round(targetTime.getMinutes() / 15) * 15;
  targetTime.setMinutes(roundedMinutes);
  targetTime.setSeconds(0);
  targetTime.setMilliseconds(0);

  // Update the drop target
  dropTarget.value = {
    orId,
    time: targetTime,
    isValid: true, // In a real app, you would check for conflicts here
    message: `Schedule in ${orId} at ${targetTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
  };

  // Check for conflicts (simplified example)
  const conflictingSurgeries = scheduleStore.scheduledSurgeries.filter(s => {
    if (s.orId !== orId) return false;

    const surgeryStart = new Date(s.startTime);
    const surgeryEnd = new Date(s.endTime);
    const newSurgeryStart = targetTime;
    const newSurgeryEnd = new Date(targetTime.getTime() + draggedSurgery.value.estimatedDuration * 60 * 1000);

    return (newSurgeryStart < surgeryEnd && newSurgeryEnd > surgeryStart);
  });

  if (conflictingSurgeries.length > 0) {
    dropTarget.value.isValid = false;
    dropTarget.value.message = `Conflict with ${conflictingSurgeries[0].patientName}'s surgery`;
  }
};

const handleDropOnGantt = (event) => {
  event.preventDefault();
  const surgeryDataString = event.dataTransfer.getData('application/json');
  if (!surgeryDataString) return;

  const droppedSurgery = JSON.parse(surgeryDataString);
  console.log('Dropped pending surgery on Gantt chart:', droppedSurgery.id);

  // Check if we have a valid drop target
  if (!dropTarget.value.orId || !dropTarget.value.time) {
    console.warn('No valid drop target');
    return;
  }

  // Check if the drop target is valid (no conflicts)
  if (!dropTarget.value.isValid) {
    notificationStore.warning(`Cannot schedule surgery: ${dropTarget.value.message}`, {
      title: 'Scheduling Conflict'
    });
    return;
  }

  // Schedule the surgery using the store with the calculated OR and time
  scheduleStore.schedulePendingSurgery(
    droppedSurgery.id,
    dropTarget.value.orId,
    dropTarget.value.time
  ).then(scheduledSurgery => {
    if (scheduledSurgery) {
      const scheduledTime = dropTarget.value.time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      notificationStore.success(
        `Surgery ${droppedSurgery.patientName || droppedSurgery.patientId} scheduled in ${dropTarget.value.orId} at ${scheduledTime}`,
        {
          title: 'Surgery Scheduled',
          duration: 3000
        }
      );
      selectSurgeryForDetails(scheduledSurgery, 'scheduled');
    }
  }).catch(error => {
    notificationStore.error(`Error scheduling surgery: ${error.message}`, {
      title: 'Scheduling Failed'
    });
  });

  // Reset the drop target
  dropTarget.value = {
    orId: null,
    time: null,
    isValid: true,
    message: ''
  };
};

// Gantt Chart Navigation and Controls
const ganttNavigate = (direction) => {
  scheduleStore.navigateGanttDate(direction);
};

const ganttZoom = (level) => {
  // Adjust the zoom level
  if (level === 'in') {
    // Switch to day view
    scheduleStore.updateGanttViewMode('Day');
  } else if (level === 'out') {
    // Switch to week view
    scheduleStore.updateGanttViewMode('Week');
  }
};

// Initialize data on component mount
onMounted(() => {
  initializeData();

  // Set up the toast notification ref
  nextTick(() => {
    if (toastRef.value) {
      notificationStore.setToastRef(toastRef.value);
    }
  });

  // Register keyboard shortcuts
  registerKeyboardShortcuts();

  // Watch for changes in the store's selected surgery
  watch(() => selectedSurgeryId.value, (newId) => {
    if (newId) {
      // Find the surgery in the scheduled surgeries
      const surgery = storeScheduledSurgeries.value.find(s => s.id === newId);
      if (surgery) {
        selectSurgeryForDetails(surgery, 'scheduled');
      }
    }
  });
});

// Register keyboard shortcuts for the scheduling screen
const registerKeyboardShortcuts = () => {
  // Create new surgery (N)
  keyboardShortcuts.register('n', () => {
    showCreateNewSurgeryForm();
  }, {
    description: 'Create new surgery',
    scope: 'scheduling'
  });

  // Save surgery details (Ctrl+S)
  keyboardShortcuts.register('s', () => {
    if (selectedSurgery.value && formMode.value !== 'view') {
      saveSurgeryDetails();
    }
  }, {
    ctrlKey: true,
    description: 'Save surgery details',
    scope: 'scheduling'
  });

  // Cancel/close form (Escape)
  keyboardShortcuts.register('escape', () => {
    if (selectedSurgery.value) {
      clearSelectionOrCancel();
    }
  }, {
    description: 'Cancel/close form',
    scope: 'scheduling'
  });

  // Schedule selected surgery (Ctrl+Enter)
  keyboardShortcuts.register('enter', () => {
    if (selectedSurgery.value && selectedSurgerySource.value === 'pending') {
      scheduleSelectedSurgery();
    }
  }, {
    ctrlKey: true,
    description: 'Schedule selected surgery',
    scope: 'scheduling'
  });

  // Navigate Gantt chart (Arrow keys)
  keyboardShortcuts.register('arrowleft', () => {
    ganttNavigate('prev');
  }, {
    description: 'Previous day/week in schedule',
    scope: 'scheduling'
  });

  keyboardShortcuts.register('arrowright', () => {
    ganttNavigate('next');
  }, {
    description: 'Next day/week in schedule',
    scope: 'scheduling'
  });

  // Toggle advanced filters (F)
  keyboardShortcuts.register('f', () => {
    filters.value.showAdvancedFilters = !filters.value.showAdvancedFilters;
  }, {
    description: 'Toggle advanced filters',
    scope: 'scheduling'
  });

  // Show keyboard shortcuts help (?)
  keyboardShortcuts.register('?', () => {
    keyboardShortcutsRef.value?.toggle();
  }, {
    description: 'Show keyboard shortcuts help',
    scope: 'scheduling'
  });
};

</script>

<style scoped>
.scheduling-container {
  padding: var(--spacing-md);
  background-color: var(--color-background);
  color: var(--color-text);
  height: calc(100vh - 60px); /* Assuming header is 60px */
  display: flex;
  flex-direction: column;
}

h1 {
  color: var(--color-primary);
  margin-bottom: var(--spacing-md);
  text-align: center;
}

.scheduling-layout {
  display: flex;
  flex-grow: 1;
  gap: var(--spacing-md);
  overflow: hidden; /* Prevent layout from exceeding container height */
}

.left-panel, .right-panel {
  width: 25%;
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  overflow-y: auto; /* Allow scrolling within panels */
}

.main-panel {
  flex-grow: 1;
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  overflow: hidden; /* Important for Gantt chart layout */
}

.left-panel h2, .main-panel h2, .right-panel h2 {
  color: var(--color-text);
  margin-top: 0;
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--spacing-sm);
}

.filters-section, .sort-section {
  margin-bottom: var(--spacing-md);
  padding-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
}

.filters-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.filters-section h3, .sort-section h3 {
  margin-top: 0;
  margin-bottom: 0;
  color: var(--color-text-secondary);
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
}

.filter-group {
  margin-bottom: var(--spacing-sm);
}

.filter-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.filter-group select,
.filter-group input[type="text"],
.filter-group input[type="date"] {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  background-color: var(--color-background);
  color: var(--color-text);
}

.advanced-filters {
  margin-top: var(--spacing-md);
  padding: var(--spacing-sm);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-sm);
  border-left: 3px solid var(--color-primary);
}

.date-range-inputs {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.date-range-separator {
  color: var(--color-text-secondary);
  font-size: var(--font-size-sm);
}

.filter-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

.btn-link {
  background: none;
  border: none;
  color: var(--color-primary);
  text-decoration: underline;
  padding: 0;
  font-size: var(--font-size-sm);
  cursor: pointer;
}

.btn-link:hover {
  color: var(--color-primary-dark, #0056b3);
  text-decoration: none;
}

.sort-controls {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.sort-direction {
  display: flex;
  gap: var(--spacing-xs);
}

.sort-direction button {
  flex: 1;
}

.pending-surgeries-list {
  flex-grow: 1;
  overflow-y: auto;
}

.pending-surgeries-list ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.pending-surgery-item {
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  cursor: grab;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.pending-surgery-item:hover {
  background-color: var(--color-background-hover);
  transform: translateY(-2px);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.pending-surgery-item.selected {
  border-color: var(--color-primary);
  background-color: var(--color-background-active);
}

.pending-surgery-item.priority-high {
  border-left: 4px solid var(--color-error);
}

.pending-surgery-item.priority-medium {
  border-left: 4px solid var(--color-warning, #f59e0b);
}

.pending-surgery-item.priority-low {
  border-left: 4px solid var(--color-success, #10b981);
}

.pending-surgery-item.dragging {
  opacity: 0.4;
  transform: scale(1.02);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
  border-style: dashed;
}

/* Drag ghost element */
.surgery-drag-ghost {
  display: flex;
  background-color: var(--color-background);
  border: 2px solid var(--color-primary);
  border-radius: var(--border-radius-sm);
  padding: var(--spacing-sm);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  width: 250px;
  pointer-events: none;
  z-index: 1000;
}

.ghost-priority {
  width: 8px;
  margin-right: var(--spacing-sm);
  border-radius: var(--border-radius-sm);
}

.ghost-priority.high {
  background-color: var(--color-error);
}

.ghost-priority.medium {
  background-color: var(--color-warning, #f59e0b);
}

.ghost-priority.low {
  background-color: var(--color-success, #10b981);
}

.ghost-content {
  flex: 1;
}

.ghost-title {
  font-weight: var(--font-weight-bold);
  margin-bottom: var(--spacing-xs);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.ghost-type {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

.pending-surgery-item.dragging {
  opacity: 0.4;
  transform: scale(1.02);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
  border-style: dashed;
}

/* Drag ghost element */
.surgery-drag-ghost {
  display: flex;
  background-color: var(--color-background);
  border: 2px solid var(--color-primary);
  border-radius: var(--border-radius-sm);
  padding: var(--spacing-sm);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  width: 250px;
  pointer-events: none;
  z-index: 1000;
}

.ghost-priority {
  width: 8px;
  margin-right: var(--spacing-sm);
  border-radius: var(--border-radius-sm);
}

.ghost-priority.high {
  background-color: var(--color-error);
}

.ghost-priority.medium {
  background-color: var(--color-warning, #f59e0b);
}

.ghost-priority.low {
  background-color: var(--color-success, #10b981);
}

.ghost-content {
  flex: 1;
}

.ghost-title {
  font-weight: var(--font-weight-bold);
  margin-bottom: var(--spacing-xs);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.ghost-type {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

/* Drop target indicator */
.gantt-chart-container::after {
  content: attr(data-drop-message);
  display: none;
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: var(--color-background);
  color: var(--color-text);
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 100;
  font-size: var(--font-size-sm);
  pointer-events: none;
}

.gantt-chart-container.drag-over::after {
  display: block;
}

.gantt-chart-container.drag-over.invalid::after {
  background-color: var(--color-error-bg, rgba(255, 0, 0, 0.1));
  color: var(--color-error);
  border: 1px solid var(--color-error);
}

.item-header {
  font-weight: var(--font-weight-bold);
  margin-bottom: var(--spacing-sm);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.patient-info {
  display: flex;
  flex-direction: column;
}

.patient-name {
  font-size: var(--font-size-md);
  color: var(--color-text);
}

.patient-id {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
  font-weight: var(--font-weight-normal);
}

.priority-badge {
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-bold);
  color: white;
}

.priority-badge.priority-high {
  background-color: var(--color-error);
}

.priority-badge.priority-medium {
  background-color: var(--color-warning, #f59e0b);
}

.priority-badge.priority-low {
  background-color: var(--color-success, #10b981);
}

.item-details {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin-bottom: var(--spacing-sm);
  padding: var(--spacing-sm);
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-sm);
}

.surgery-type, .surgery-duration {
  display: flex;
  justify-content: space-between;
  margin-bottom: var(--spacing-xs);
}

.surgery-full-type {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
  margin-bottom: var(--spacing-sm);
}

.label {
  color: var(--color-text-secondary);
  font-weight: var(--font-weight-medium);
}

.value {
  font-weight: var(--font-weight-medium);
}

.item-status {
  display: flex;
  align-items: center;
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
  margin-bottom: var(--spacing-sm);
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: var(--spacing-xs);
}

.status-indicator.status-pending {
  background-color: var(--color-warning, #f59e0b);
}

.status-indicator.status-scheduled {
  background-color: var(--color-primary);
}

.status-indicator.status-completed {
  background-color: var(--color-success, #10b981);
}

.status-indicator.status-cancelled {
  background-color: var(--color-error);
}

.item-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
}

.item-actions .icon {
  margin-right: var(--spacing-xs);
}

.no-items, .no-scheduled-items {
    padding: 10px;
    text-align: center;
    color: var(--text-color-secondary);
    font-style: italic;
}

.schedule-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.schedule-controls button {
  margin-left: 10px;
  padding: 8px 12px;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.schedule-controls button:hover {
  background-color: var(--primary-color-dark);
}

.schedule-controls span {
    margin: 0 10px;
    font-weight: bold;
}

.gantt-chart-placeholder {
  flex-grow: 1;
  border: 2px dashed var(--border-color);
  display: flex;
  flex-direction: column; /* To stack p and ul */
  align-items: center;
  justify-content: center;
  text-align: center;
  color: var(--text-color-secondary);
  border-radius: 4px;
  background-color: var(--background-color-light);
  min-height: 300px; /* Ensure it has some height */
  overflow-y: auto; /* If debug list gets long */
}

.gantt-chart-container {
  position: relative;
}

/* Drop target indicator */
.gantt-chart-container::after {
  content: attr(data-drop-message);
  display: none;
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: var(--color-background);
  color: var(--color-text);
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 100;
  font-size: var(--font-size-sm);
  pointer-events: none;
}

.gantt-chart-container.drag-over::after {
  display: block;
}

.gantt-chart-container.drag-over.invalid::after {
  background-color: var(--color-error-bg, rgba(255, 0, 0, 0.1));
  color: var(--color-error);
  border: 1px solid var(--color-error);
}

.scheduled-surgery-list-debug {
    list-style: none;
    padding: 0;
    margin-top: 10px;
    font-size: 0.9em;
}
.scheduled-surgery-list-debug li {
    padding: 5px;
    border-bottom: 1px solid var(--border-color-light);
    cursor: pointer;
}
.scheduled-surgery-list-debug li:hover {
    background-color: var(--hover-color);
}


.right-panel form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.form-group {
  display: flex;
  flex-direction: column;
  margin-bottom: var(--spacing-md);
}

.form-group label {
  margin-bottom: var(--spacing-xs);
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
}

.form-group .required {
  color: var(--color-error);
  margin-left: var(--spacing-xs);
}

.form-group input[type="text"],
.form-group input[type="number"],
.form-group input[type="datetime-local"],
.form-group select,
.form-group textarea {
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  background-color: var(--color-background);
  color: var(--color-text);
  font-size: var(--font-size-base);
  transition: border-color 0.2s ease;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 2px rgba(var(--color-primary-rgb, 0, 120, 212), 0.25);
}

.form-group input:disabled,
.form-group select:disabled,
.form-group textarea:disabled {
  background-color: var(--color-background-mute);
  color: var(--color-text-secondary);
  cursor: not-allowed;
}

.form-group.has-error input,
.form-group.has-error select,
.form-group.has-error textarea,
.form-group input.is-invalid,
.form-group select.is-invalid,
.form-group textarea.is-invalid {
  border-color: var(--color-error);
}

.form-error-message {
  color: var(--color-error);
  font-size: var(--font-size-xs);
  margin-top: var(--spacing-xs);
}

.form-error-message.general-error {
  background-color: rgba(var(--color-error-rgb, 255, 0, 0), 0.1);
  padding: var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  margin-bottom: var(--spacing-md);
}

.form-text {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
  margin-top: var(--spacing-xs);
}

.form-actions {
  margin-top: var(--spacing-lg);
  display: flex;
  gap: var(--spacing-sm);
  flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
}

.btn {
  padding: var(--spacing-sm) var(--spacing-md);
  border: none;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-weight: var(--font-weight-medium);
  transition: background-color 0.2s ease;
}

.btn-sm {
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: var(--font-size-sm);
}

.btn-primary {
  background-color: var(--color-primary);
  color: white;
}

.btn-primary:hover {
  background-color: var(--color-primary-dark, #0056b3);
}

.btn-secondary {
  background-color: var(--color-background-mute);
  color: var(--color-text);
}

.btn-secondary:hover {
  background-color: var(--color-background-active);
}

/* Responsive adjustments if needed */
@media (max-width: 1200px) {
  .scheduling-layout {
    flex-direction: column; /* Stack panels on smaller screens */
    overflow: visible;
  }
  .left-panel, .right-panel, .main-panel {
    width: 100%;
    margin-bottom: 20px;
    max-height: 50vh; /* Limit height when stacked */
    overflow-y: auto;
  }
  .main-panel {
      min-height: 400px; /* Ensure Gantt area is usable */
  }
}

</style>


================================================
FILE: src/components/SDSTDataManagementScreen.vue
================================================
<template>
  <div class="sdst-management-container">
    <h1>SDST Data Management</h1>

    <div class="tabs">
      <button
        :class="{ active: activeTab === 'surgeryTypes' }"
        @click="activeTab = 'surgeryTypes'"
      >
        Manage Surgery Types
      </button>
      <button
        :class="{ active: activeTab === 'sdstMatrix' }"
        @click="activeTab = 'sdstMatrix'"
      >
        Manage SDST Matrix
      </button>
      <button
        :class="{ active: activeTab === 'initialSetup' }"
        @click="activeTab = 'initialSetup'"
      >
        Manage Initial Setup Times
      </button>
      <!-- Optional Tab for OR-Specific SDST could be added here -->
    </div>

    <div class="tab-content">
      <div v-if="activeTab === 'surgeryTypes'">
        <h2>Manage Surgery Types</h2>
        <p>Manage the distinct types of surgeries used for SDST calculations.</p>

        <button class="add-button" @click="addSurgeryType">Add New Surgery Type</button>

        <table class="data-table">
          <thead>
            <tr>
              <th>Surgery Type Name</th>
              <th>Code</th>
              <th>Description</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            <!-- Bind to surgeryTypes data -->
            <tr v-for="type in surgeryTypes" :key="type.id">
              <td>{{ type.name }}</td>
              <td>{{ type.code }}</td>
              <td>{{ type.description }}</td>
              <td>
                <button class="action-button edit-button" @click="editSurgeryType(type)">Edit</button>
                <button class="action-button delete-button" @click="deleteSurgeryType(type.id)">Delete</button>
              </td>
            </tr>
             <tr v-if="surgeryTypes.length === 0">
                <td colspan="4" class="no-items">No surgery types defined.</td>
            </tr>
          </tbody>
        </table>

      </div>

      <div v-if="activeTab === 'sdstMatrix'">
        <h2>Manage SDST Matrix</h2>
        <p>Define the setup time required when transitioning between different surgery types in an OR. Times are in minutes.</p>
         <p>Needs input validation and potentially color-coding for durations.</p>
         <!-- Placeholder for SDST Matrix Grid/Input -->
         <div class="sdst-matrix-container">
            <table class="sdst-matrix-table data-table">
                <thead>
                    <tr>
                        <th>From \ To</th>
                         <th v-for="toType in surgeryTypes" :key="'to-'+toType.id">{{ toType.name }}</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="fromType in surgeryTypes" :key="'from-'+fromType.id">
                         <th>{{ fromType.name }}</th>
                         <td v-for="toType in surgeryTypes" :key="'sdst-'+fromType.id+'-'+toType.id">
                             <!-- Bind input to sdstMatrix data -->
                             <input type="number" v-model.number="sdstMatrix[fromType.id][toType.id]" min="0">
                         </td>
                    </tr>
                    <tr v-if="surgeryTypes.length === 0">
                        <td :colspan="surgeryTypes.length + 1" class="no-items">Define Surgery Types first to manage the matrix.</td>
                    </tr>
                </tbody>
            </table>
         </div>
          <button class="save-matrix-button action-button edit-button" @click="saveMatrixChanges">Save Matrix Changes</button>

      </div>

      <div v-if="activeTab === 'initialSetup'">
        <h2>Manage Initial Setup Times</h2>
        <p>Define the initial setup time for the first surgery of a specific type in an OR for the day.</p>
         <table class="data-table">
          <thead>
            <tr>
              <th>Surgery Type Name</th>
              <th>Initial Setup Time (minutes)</th>
               <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            <!-- Bind to initialSetupTimes data -->
            <tr v-for="setupTime in initialSetupTimes" :key="'initial-'+setupTime.typeId">
              <td>{{ getSurgeryTypeName(setupTime.typeId) }}</td>
              <td><input type="number" v-model.number="setupTime.time" min="0"></td>
               <td>
                <button class="action-button edit-button" @click="editInitialSetup(setupTime)">Edit</button>
                <button class="action-button delete-button" @click="deleteInitialSetup(setupTime.typeId)">Delete</button>
              </td>
            </tr>
             <tr v-if="initialSetupTimes.length === 0">
                <td colspan="3" class="no-items">No initial setup times defined.</td>
            </tr>
          </tbody>
        </table>
        <button class="add-button" @click="addInitialSetup">Add Initial Setup Time</button>
      </div>
    </div>

     <div class="action-buttons">
      <!-- Placeholder data management actions - may move into tabs later -->
      <button>Import Data</button>
      <button>Export Data</button>
      <button>Settings</button>
       <button @click="validateDataIntegrity">Validate Data Integrity</button> <!-- Based on FR-SDSTDATA-006 -->
    </div>

    <!-- Add/Edit Surgery Type Modal -->
    <AddEditSurgeryTypeModal
      v-if="showSurgeryTypeModal"
      :initialData="surgeryTypeToEdit"
      :isEditing="!!surgeryTypeToEdit"
      @save="handleSaveSurgeryType"
      @cancel="handleCancelSurgeryType"
    />

    <!-- Add/Edit Initial Setup Time Modal -->
     <AddEditInitialSetupModal
        v-if="showInitialSetupModal"
        :initialData="initialSetupToEdit"
        :isEditing="!!initialSetupToEdit"
        :surgeryTypes="surgeryTypes"
        @save="handleSaveInitialSetup"
        @cancel="handleCancelInitialSetup"
     />

  </div>
</template>

<script setup>
import { ref, watch } from 'vue';
import AddEditSurgeryTypeModal from './AddEditSurgeryTypeModal.vue';
import AddEditInitialSetupModal from './AddEditInitialSetupModal.vue';

const activeTab = ref('surgeryTypes'); // Default active tab

// --- State for Add/Edit Surgery Type Modal ---
const showSurgeryTypeModal = ref(false);
const surgeryTypeToEdit = ref(null); // Holds data of the type being edited, null for adding
// ---------------------------------------------

// --- State for Add/Edit Initial Setup Time Modal ---
const showInitialSetupModal = ref(false);
const initialSetupToEdit = ref(null); // Holds data of the initial setup time being edited, null for adding
// ---------------------------------------------------

// --- Simulated Data for Surgery Types ---
const surgeryTypes = ref([
    { id: 1, name: 'Cardiac - CABG', code: 'CABG', description: 'Coronary Artery Bypass Grafting' },
    { id: 2, name: 'Orthopedic - Knee Replacement', code: 'TKR', description: 'Total Knee Replacement' },
    { id: 3, name: 'General - Appendectomy', code: 'APP', description: 'Surgical removal of the appendix' },
]);
// ----------------------------------------

// --- Simulated Data for Initial Setup Times ---
// In a real app, this data would link to surgery types by ID
const initialSetupTimes = ref([
    { typeId: 1, time: 60 }, // CABG
    { typeId: 2, time: 45 }, // TKR
    { typeId: 3, time: 30 }, // Appendectomy
]);
// ----------------------------------------------

// --- Simulated Data for SDST Matrix ---
// Represent as a nested object: { fromTypeId: { toTypeId: setupTime, ... }, ...}
const sdstMatrix = ref({});

// Initialize matrix when surgery types change (or on component mount)
watch(surgeryTypes, (newTypes) => {
    console.log('Surgery types changed. Initializing/updating SDST matrix.');
    const newMatrix = {};
    const oldMatrix = sdstMatrix.value; // Preserve old matrix data

    newTypes.forEach(fromType => {
        newMatrix[fromType.id] = {};
        newTypes.forEach(toType => {
            // Preserve existing value if available, otherwise use a default
            const existingTime = oldMatrix[fromType.id]?.[toType.id];
             newMatrix[fromType.id][toType.id] = existingTime !== undefined ? existingTime : (fromType.id === toType.id) ? 0 : 15; // Preserve existing or set default
        });
    });
    sdstMatrix.value = newMatrix;
    console.log('SDST matrix initialized/updated:', sdstMatrix.value);
}, { immediate: true, deep: true }); // Run immediately and watch deeply for nested changes
// -------------------------------------


// --- Helper to get Surgery Type Name by ID ---
const getSurgeryTypeName = (typeId) => {
    const type = surgeryTypes.value.find(t => t.id === typeId);
    return type ? type.name : 'Unknown Type';
};
// ---------------------------------------------

// --- Surgery Type Management Logic ---
const addSurgeryType = () => {
    console.log('Add New Surgery Type clicked');
    surgeryTypeToEdit.value = null; // Clear any previous data
    showSurgeryTypeModal.value = true; // Show the modal for adding
};

const editSurgeryType = (type) => {
    console.log('Edit Surgery Type clicked:', type);
    surgeryTypeToEdit.value = { ...type }; // Set the data to be edited (create a copy)
    showSurgeryTypeModal.value = true; // Show the modal for editing
};

const deleteSurgeryType = (typeId) => {
    console.log('Attempting to delete Surgery Type with ID:', typeId);
    // In a real app, show a confirmation dialog first (e.g., using a confirmation modal)
    const confirmDelete = confirm('Are you sure you want to delete this Surgery Type? This will also remove associated SDST matrix entries and initial setup times.');

    if (confirmDelete) {
         // Simulate deletion from the list
         surgeryTypes.value = surgeryTypes.value.filter(type => type.id !== typeId);
         // Note: Deleting a surgery type would also require updating the SDST matrix and initial setup times
         // The watch effect on surgeryTypes will handle matrix update logic (re-initializes with remaining types)
         initialSetupTimes.value = initialSetupTimes.value.filter(item => item.typeId !== typeId);
         console.log('Surgery Type deleted.');
         // Show a success message
    } else {
         console.log('Surgery Type deletion cancelled.');
    }
};

const handleSaveSurgeryType = (savedType) => {
    console.log('Saving Surgery Type:', savedType);
    if (savedType.id) {
        // Editing existing type
        const index = surgeryTypes.value.findIndex(type => type.id === savedType.id);
        if (index !== -1) {
            surgeryTypes.value[index] = savedType;
             console.log('Surgery Type updated.', savedType);
            // Show a success message
        }
    } else {
        // Adding new type
        const newId = surgeryTypes.value.length > 0 ? Math.max(...surgeryTypes.value.map(type => type.id)) + 1 : 1;
        surgeryTypes.value.push({ ...savedType, id: newId });
         console.log('New Surgery Type added.', { ...savedType, id: newId });
        // Show a success message
    }
    handleCancelSurgeryType(); // Close modal after save
};

const handleCancelSurgeryType = () => {
    console.log('Cancelling Surgery Type modal');
    showSurgeryTypeModal.value = false;
    surgeryTypeToEdit.value = null; // Clear editing data
};
// -----------------------------------------------------

// --- Initial Setup Time Management Logic ---
const addInitialSetup = () => {
    console.log('Add Initial Setup Time clicked');
    initialSetupToEdit.value = null; // Clear any previous data
    showInitialSetupModal.value = true; // Show the modal for adding
};

const editInitialSetup = (setupTime) => {
    console.log('Edit Initial Setup Time clicked:', setupTime);
    initialSetupToEdit.value = { ...setupTime }; // Set the data to be edited (create a copy)
    showInitialSetupModal.value = true; // Show the modal for editing
};

const deleteInitialSetup = (typeId) => {
    console.log('Attempting to delete Initial Setup Time for type ID:', typeId);
    // In a real app, show a confirmation dialog first
    const confirmDelete = confirm('Are you sure you want to delete this Initial Setup Time entry?');

    if (confirmDelete) {
         // Simulate deletion from the list
         initialSetupTimes.value = initialSetupTimes.value.filter(item => item.typeId !== typeId);
         console.log('Initial Setup Time deleted for type ID:', typeId);
         // Show a success message
    } else {
         console.log('Initial Setup Time deletion cancelled.');
    }
};

const handleSaveInitialSetup = (savedSetupTime) => {
     console.log('Saving Initial Setup Time:', savedSetupTime);
     const index = initialSetupTimes.value.findIndex(item => item.typeId === savedSetupTime.typeId);

    if (index !== -1) {
        // Editing existing initial setup time
        initialSetupTimes.value[index] = savedSetupTime;
         console.log('Initial Setup Time updated.', savedSetupTime);
        // Show a success message
    } else {
        // Adding new initial setup time
        // Check if a setup time for this type already exists
        const existing = initialSetupTimes.value.find(item => item.typeId === savedSetupTime.typeId);
        if (existing) {
             console.warn('Initial Setup Time for this Surgery Type already exists. Updating instead of adding.');
            existing.time = savedSetupTime.time;
             console.log('Initial Setup Time updated (via add form).', existing);
            // Show a success message
        } else {
            // Ensure the surgery type exists before adding setup time
            const typeExists = surgeryTypes.value.some(type => type.id === savedSetupTime.typeId);
            if (typeExists) {
                 initialSetupTimes.value.push({ ...savedSetupTime });
                 console.log('New Initial Setup Time added.', { ...savedSetupTime });
                // Show a success message
            } else {
                 console.error('Cannot add Initial Setup Time: Surgery Type not found.', savedSetupTime.typeId);
                // In a real app, show an error message to the user
            }
        }
    }
     handleCancelInitialSetup(); // Close modal after save
};

const handleCancelInitialSetup = () => {
    console.log('Cancelling Initial Setup Time modal');
    showInitialSetupModal.value = false;
    initialSetupToEdit.value = null; // Clear editing data
};
// ----------------------------------------------------------

// --- SDST Matrix Management Logic ---
const saveMatrixChanges = () => {
    console.log('Attempting to save SDST Matrix changes.');

    // First, validate the data integrity (e.g., check for negative values, required entries)
    const validationResult = validateDataIntegrity(); // Call the validation method, it returns object

    if (validationResult.isValid) {
         console.log('SDST Matrix data is valid.', sdstMatrix.value);
         // Confirmation step before saving significant changes (Section 4.4)
         const confirmSave = confirm('Are you sure you want to save changes to the SDST Matrix? This affects all future scheduling.');

         if (confirmSave) {
             console.log('User confirmed save. Simulating save:', sdstMatrix.value);
            // Placeholder for sending the updated matrix data to the backend (FR-SDSTDATA-005)
            // In a real app, you would send sdstMatrix.value to your API
            // Show a success message (e.g., using a notification system)
         } else {
              console.log('SDST Matrix save cancelled by user.');
             // Show a cancelled message
         }

    } else {
         console.warn('SDST Matrix data is invalid. Cannot save. Errors:', validationResult.errors);
        // Show validation error messages to the user (implementation needed using a notification system or inline errors)
    }

};

// --- Data Integrity Validation (Placeholder) ---
// Returns an object { isValid: boolean, errors: string[] }
const validateDataIntegrity = () => {
     console.log('Running Data Integrity Validation for SDST Data...');

     let isValid = true;
     let validationErrors = [];

    // Validation: Check for negative setup times in the matrix
    console.log('Validating SDST Matrix values...');
    for (const fromTypeId in sdstMatrix.value) {
        for (const toTypeId in sdstMatrix.value[fromTypeId]) {
            const time = sdstMatrix.value[fromTypeId][toTypeId];
            // Check if time is a number, not null/undefined, and is negative
            if (typeof time === 'number' && time !== null && time !== undefined && time < 0) {
                validationErrors.push(`SDST from ${getSurgeryTypeName(parseInt(fromTypeId))} to ${getSurgeryTypeName(parseInt(toTypeId))} cannot be negative.`);
                isValid = false;
            }
             // Add other matrix validation rules here (e.g., check if all combinations are filled if required)
        }
    }

     // Validation: Check if all current surgery types have a corresponding initial setup time entry
     console.log('Validating Initial Setup Times presence for all Surgery Types...');
     const definedInitialSetupTypes = initialSetupTimes.value.map(item => item.typeId);
     surgeryTypes.value.forEach(type => {
         if (!definedInitialSetupTypes.includes(type.id)) {
             validationErrors.push(`Initial Setup Time is missing for Surgery Type: ${type.name}`);
             isValid = false;
         }
     });

    // Add other data integrity validation rules here (e.g., check for duplicate surgery codes, ensure type IDs in setupTimes/matrix match existing surgeryTypes)
    console.log('Validation complete.');

     return { isValid, errors: validationErrors };
};
// -----------------------------------------------

</script>

<style scoped>
.sdst-management-container {
  padding: 20px;
  background-color: var(--color-white); /* Match layout background */
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

h1 {
    color: var(--color-very-dark-gray);
    margin-bottom: 20px;
}

.tabs {
  margin-bottom: 20px;
  border-bottom: 1px solid var(--color-gray);
}

.tabs button {
  background-color: transparent;
  border: none;
  padding: 10px 15px;
  cursor: pointer;
  font-size: 1em;
  color: var(--color-dark-gray);
  transition: color 0.25s ease, border-bottom-color 0.25s ease;
  margin-right: 5px; /* Space between buttons */
  border-bottom: 2px solid transparent; /* Underline effect */
}

.tabs button.active {
  color: var(--color-primary);
  font-weight: 600;
  border-bottom-color: var(--color-primary); /* Highlight active tab */
}

.tabs button:hover:not(.active) {
    color: var(--color-primary-dark); /* Darker on hover */
}

.tab-content {
  padding: 20px 0;
}

.tab-content h2 {
    color: var(--color-very-dark-gray);
    margin-bottom: 15px;
    font-size: 1.4em;
}

/* --- Table Styles --- */
.data-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
}

.data-table th,
.data-table td {
  border: 1px solid var(--color-mid-light-gray);
  padding: 10px 12px;
  text-align: left;
}

.data-table th {
  background-color: var(--color-light-gray);
  font-weight: 600;
  color: var(--color-very-dark-gray);
}

.data-table tbody tr:nth-child(even) {
  background-color: var(--color-background); /* Zebrabar-striping */
}

.data-table tbody tr:hover {
  background-color: var(--color-hover-gray); /* Highlight row on hover */
}

.action-button {
    padding: 5px 10px;
    margin-right: 5px;
    border: 1px solid;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
}

.edit-button {
    background-color: var(--color-primary-light);
    color: var(--color-primary-dark);
    border-color: var(--color-primary);
}

.edit-button:hover {
    background-color: var(--color-primary);
    color: var(--color-white);
}

.delete-button {
    background-color: var(--color-danger-light);
    color: var(--color-danger-dark);
    border-color: var(--color-danger);
}

.delete-button:hover {
    background-color: var(--color-danger);
    color: var(--color-white);
}

.add-button {
   padding: 8px 15px;
   background-color: var(--color-success);
   color: var(--color-white);
   border: none;
   border-radius: 4px;
   cursor: pointer;
   margin-bottom: 15px; /* Space below add button */
   transition: background-color 0.25s ease;
}

.add-button:hover {
    background-color: var(--color-success-dark);
}
/* --- End Table Styles --- */

/* --- SDST Matrix Styles --- */
.sdst-matrix-container {
    overflow-x: auto; /* Add horizontal scroll for wide matrices */
    margin-bottom: 20px;
}

.sdst-matrix-table {
    min-width: 600px; /* Ensure some minimum width */
}

.sdst-matrix-table th:first-child {
    position: sticky;
    left: 0;
    background-color: var(--color-light-gray); /* Sticky header background */
    z-index: 2; /* Ensure it's above scrolling cells */
}

.sdst-matrix-table tbody tr th {
     position: sticky;
    left: 0;
     background-color: var(--color-light-gray); /* Sticky header background */
     z-index: 1; /* Ensure it's above scrolling cells */
}

.sdst-matrix-table td input[type="number"] {
    width: 80px; /* Fixed width for input cells */
    padding: 5px;
    border: 1px solid var(--color-gray);
    border-radius: 4px;
    text-align: center; /* Center numbers */
}

.save-matrix-button {
    margin-top: 10px; /* Space above save button */
}

/* --- End SDST Matrix Styles --- */


.action-buttons button {
    padding: 8px 15px;
    margin-left: 10px; /* Space between buttons */
    border: 1px solid var(--color-primary);
    border-radius: 4px;
    background-color: var(--color-primary);
    color: var(--color-white);
    cursor: pointer;
    transition: background-color 0.25s ease, color 0.25s ease, border-color 0.25s ease;
}

.action-buttons button:hover {
    background-color: var(--color-primary-dark);
     border-color: var(--color-primary-dark);
}

/* Style for secondary buttons if needed, e.g., Import/Export */
.action-buttons button:nth-child(-n+2) { /* Apply to first two buttons */
   background-color: var(--color-light-gray);
   color: var(--color-very-dark-gray);
   border-color: var(--color-gray);
}

.action-buttons button:nth-child(-n+2):hover {
    background-color: var(--color-gray);
     color: var(--color-very-dark-gray);
}

/* Specific style for Validate Data Integrity button */
.action-buttons button:last-child {
    background-color: var(--color-secondary);
     border-color: var(--color-secondary);
     color: var(--color-white);
}

.action-buttons button:last-child:hover {
    background-color: #5a6268;
     border-color: #5a6268;
}

</style>


================================================
FILE: src/components/SDSTManagement.vue
================================================
<template>
  <div class="sdst-management-container">
    <h1>SDST Data Management</h1>
    <p class="description">
      Manage Sequence-Dependent Setup Times (SDST) data, including surgery types, 
      setup time matrix, and initial setup times.
    </p>

    <!-- Tab Navigation -->
    <div class="tabs-container">
      <div class="tabs">
        <button 
          v-for="tab in tabs" 
          :key="tab.id"
          class="tab-button" 
          :class="{ 'active': activeTab === tab.id }"
          @click="activeTab = tab.id"
        >
          {{ tab.label }}
        </button>
      </div>
    </div>

    <!-- Tab Content -->
    <div class="tab-content">
      <!-- Surgery Types Tab -->
      <div v-if="activeTab === 'surgeryTypes'" class="tab-pane">
        <h2>Surgery Types</h2>
        <p>Define and manage surgery types used for SDST calculations.</p>
        <p class="placeholder-message">Surgery Types management will be implemented in the next iteration.</p>
      </div>

      <!-- SDST Matrix Tab -->
      <div v-if="activeTab === 'sdstMatrix'" class="tab-pane">
        <h2>SDST Matrix</h2>
        <p>Define setup times between pairs of surgery types.</p>
        <p class="placeholder-message">SDST Matrix management will be implemented in the next iteration.</p>
      </div>

      <!-- Initial Setup Times Tab -->
      <div v-if="activeTab === 'initialSetupTimes'" class="tab-pane">
        <h2>Initial Setup Times</h2>
        <p>Define setup times for the first surgery of the day in an OR.</p>
        <p class="placeholder-message">Initial Setup Times management will be implemented in the next iteration.</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';

// Define tabs
const tabs = [
  { id: 'surgeryTypes', label: 'Surgery Types' },
  { id: 'sdstMatrix', label: 'SDST Matrix' },
  { id: 'initialSetupTimes', label: 'Initial Setup Times' }
];

// Active tab state
const activeTab = ref('surgeryTypes');
</script>

<style scoped>
.sdst-management-container {
  padding: var(--spacing-md);
  background-color: var(--color-background);
  color: var(--color-text);
  height: calc(100vh - 60px); /* Assuming header is 60px */
  display: flex;
  flex-direction: column;
}

h1 {
  color: var(--color-primary);
  margin-bottom: var(--spacing-sm);
}

.description {
  margin-bottom: var(--spacing-md);
  color: var(--color-text-secondary);
}

.tabs-container {
  margin-bottom: var(--spacing-md);
  border-bottom: 1px solid var(--color-border);
}

.tabs {
  display: flex;
  gap: var(--spacing-xs);
}

.tab-button {
  padding: var(--spacing-sm) var(--spacing-md);
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: var(--color-text-secondary);
  cursor: pointer;
  font-weight: var(--font-weight-medium);
  transition: all 0.2s ease;
}

.tab-button:hover {
  color: var(--color-primary);
  background-color: var(--color-background-hover);
}

.tab-button.active {
  color: var(--color-primary);
  border-bottom-color: var(--color-primary);
  background-color: var(--color-background-active);
}

.tab-content {
  flex-grow: 1;
  overflow-y: auto;
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-md);
  padding: var(--spacing-md);
}

.tab-pane {
  height: 100%;
}

h2 {
  margin-top: 0;
  margin-bottom: var(--spacing-md);
  color: var(--color-text);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--spacing-sm);
}

.placeholder-message {
  padding: var(--spacing-md);
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
  border-left: 4px solid var(--color-primary);
  margin-top: var(--spacing-lg);
  color: var(--color-text-secondary);
  font-style: italic;
}
</style>



================================================
FILE: src/components/SDSTManagementScreen.vue
================================================
<template>
  <div class="sdst-management-screen">
    <h2>SDST Management</h2>
    <p class="description">
      Manage Sequence-Dependent Setup Times (SDST) between different surgery types.
      SDST represents the time needed to prepare the OR when transitioning from one surgery type to another.
    </p>

    <!-- Controls Section -->
    <div class="controls-section">
      <div class="search-filter">
        <input
          type="text"
          v-model="searchQuery"
          placeholder="Search surgery types..."
          class="search-input"
          aria-label="Search surgery types"
        />
      </div>
      <div class="action-buttons">
        <button class="btn btn-secondary" @click="showBulkEditModal = true">
          Bulk Edit SDST Values
        </button>
        <button class="btn btn-primary" @click="showAddSurgeryTypeModal = true">
          Add New Surgery Type
        </button>
      </div>
    </div>

    <!-- SDST Matrix -->
    <div class="sdst-matrix-container">
      <div v-if="isLoading" class="loading-overlay">
        <div class="loading-spinner"></div>
        <span>Loading SDST data...</span>
      </div>

      <table class="sdst-matrix" aria-label="SDST Matrix">
        <caption>SDST Matrix (minutes)</caption>
        <thead>
          <tr>
            <th scope="col">From \ To</th>
            <th v-for="toType in filteredSurgeryTypes" :key="`to-${toType}`" scope="col">
              <div class="surgery-type-header">
                <span>{{ toType }}</span>
                <button
                  class="delete-type-btn"
                  @click.stop="confirmDeleteSurgeryType(toType)"
                  title="Delete surgery type"
                >
                  ✕
                </button>
              </div>
              <div class="surgery-type-label">{{ getSurgeryTypeFullName(toType) }}</div>
            </th>
            <th scope="col">Initial Setup</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="fromType in filteredSurgeryTypes" :key="`from-${fromType}`">
            <th scope="row">
              <div class="surgery-type-header">
                <span>{{ fromType }}</span>
                <button
                  class="delete-type-btn"
                  @click.stop="confirmDeleteSurgeryType(fromType)"
                  title="Delete surgery type"
                >
                  ✕
                </button>
              </div>
              <div class="surgery-type-label">{{ getSurgeryTypeFullName(fromType) }}</div>
            </th>
            <td
              v-for="toType in filteredSurgeryTypes"
              :key="`${fromType}-to-${toType}`"
              :class="{
                'same-type': fromType === toType,
                'editable': fromType !== toType,
                'sdst-low': fromType !== toType && getSDSTValueNumber(fromType, toType) <= 15,
                'sdst-medium': fromType !== toType && getSDSTValueNumber(fromType, toType) > 15 && getSDSTValueNumber(fromType, toType) <= 30,
                'sdst-high': fromType !== toType && getSDSTValueNumber(fromType, toType) > 30
              }"
              @click="fromType !== toType && openEditModal(fromType, toType)"
            >
              <span v-if="fromType === toType">-</span>
              <span v-else>{{ getSDSTValue(fromType, toType) }}</span>
            </td>
            <td class="initial-setup">
              <!-- Not applicable for "from" types -->
              -
            </td>
          </tr>
          <tr>
            <th scope="row">Initial Setup</th>
            <td
              v-for="toType in filteredSurgeryTypes"
              :key="`initial-to-${toType}`"
              class="editable"
              @click="openEditInitialSetupModal(toType)"
            >
              {{ getInitialSetupTime(toType) }}
            </td>
            <td>-</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Legend -->
    <div class="legend">
      <div class="legend-item">
        <span class="legend-color" style="background-color: var(--color-background-mute);"></span>
        <span>Not applicable (same surgery type)</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: rgba(40, 167, 69, 0.1);"></span>
        <span>Short setup time (≤ 15 min)</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: rgba(255, 193, 7, 0.1);"></span>
        <span>Medium setup time (16-30 min)</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: rgba(220, 53, 69, 0.1);"></span>
        <span>Long setup time (> 30 min)</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: var(--color-background);"></span>
        <span>Click on a cell to edit SDST value</span>
      </div>
    </div>

    <!-- Edit SDST Modal -->
    <div v-if="showEditModal" class="modal-overlay">
      <div class="modal-content" role="dialog" aria-labelledby="edit-sdst-title">
        <h3 id="edit-sdst-title">Edit SDST Value</h3>
        <p>
          Set the setup time required when transitioning from
          <strong>{{ editingFromType }}</strong> to <strong>{{ editingToType }}</strong>
        </p>
        <div class="form-group">
          <label for="sdst-value">Setup Time (minutes):</label>
          <input
            type="number"
            id="sdst-value"
            v-model.number="editingValue"
            min="0"
            max="180"
            class="form-control"
          />
        </div>
        <div class="modal-actions">
          <button class="btn btn-secondary" @click="closeEditModal">Cancel</button>
          <button class="btn btn-primary" @click="saveSDSTValue">Save</button>
        </div>
      </div>
    </div>

    <!-- Add Surgery Type Modal -->
    <div v-if="showAddSurgeryTypeModal" class="modal-overlay">
      <div class="modal-content" role="dialog" aria-labelledby="add-surgery-type-title">
        <h3 id="add-surgery-type-title">Add New Surgery Type</h3>
        <div class="form-group">
          <label for="surgery-code">Surgery Code (e.g., CABG):</label>
          <input
            type="text"
            id="surgery-code"
            v-model="newSurgeryType.code"
            class="form-control"
            maxlength="5"
            placeholder="Enter code (max 5 chars)"
          />
        </div>
        <div class="form-group">
          <label for="surgery-name">Full Name:</label>
          <input
            type="text"
            id="surgery-name"
            v-model="newSurgeryType.fullName"
            class="form-control"
            placeholder="e.g., Cardiac - Coronary Artery Bypass Graft"
          />
        </div>
        <div class="form-group">
          <label for="initial-setup">Initial Setup Time (minutes):</label>
          <input
            type="number"
            id="initial-setup"
            v-model.number="newSurgeryType.initialSetupTime"
            min="0"
            max="180"
            class="form-control"
          />
        </div>
        <div class="modal-actions">
          <button class="btn btn-secondary" @click="showAddSurgeryTypeModal = false">Cancel</button>
          <button class="btn btn-primary" @click="addNewSurgeryType" :disabled="!isNewSurgeryTypeValid">Add</button>
        </div>
      </div>
    </div>

    <!-- Delete Surgery Type Confirmation Modal -->
    <div v-if="showDeleteConfirmModal" class="modal-overlay">
      <div class="modal-content" role="dialog" aria-labelledby="delete-surgery-type-title">
        <h3 id="delete-surgery-type-title" class="danger-text">Delete Surgery Type</h3>
        <p>
          Are you sure you want to delete the surgery type <strong>{{ typeToDelete }}</strong>?
        </p>
        <p class="warning-text">
          This will remove all SDST rules associated with this surgery type. This action cannot be undone.
        </p>
        <div class="modal-actions">
          <button class="btn btn-secondary" @click="showDeleteConfirmModal = false">Cancel</button>
          <button class="btn btn-danger" @click="deleteSurgeryType">Delete</button>
        </div>
      </div>
    </div>

    <!-- Bulk SDST Editor Modal -->
    <BulkSDSTEditor
      v-if="showBulkEditModal"
      :show="showBulkEditModal"
      @close="showBulkEditModal = false"
      @update="handleBulkUpdate"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';
import BulkSDSTEditor from './BulkSDSTEditor.vue';

const store = useScheduleStore();
const isLoading = ref(false);
const searchQuery = ref('');

// Edit modal state
const showEditModal = ref(false);
const editingFromType = ref('');
const editingToType = ref('');
const editingValue = ref(0);
const isInitialSetup = ref(false);

// Add surgery type modal state
const showAddSurgeryTypeModal = ref(false);
const newSurgeryType = ref({
  code: '',
  fullName: '',
  initialSetupTime: 30
});

// Delete surgery type modal state
const showDeleteConfirmModal = ref(false);
const typeToDelete = ref('');

// Bulk edit modal state
const showBulkEditModal = ref(false);

// Get surgery type full names from the store
const getSurgeryTypeFullName = (type) => {
  return store.surgeryTypes[type]?.fullName || type;
};

// Get all surgery types from the store
const surgeryTypes = computed(() => {
  // Get surgery types directly from the surgeryTypes object
  return Object.keys(store.surgeryTypes).sort();
});

// Filter surgery types based on search query
const filteredSurgeryTypes = computed(() => {
  if (!searchQuery.value) return surgeryTypes.value;

  return surgeryTypes.value.filter(type =>
    type.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
    getSurgeryTypeFullName(type).toLowerCase().includes(searchQuery.value.toLowerCase())
  );
});

// Validate new surgery type
const isNewSurgeryTypeValid = computed(() => {
  const code = newSurgeryType.value.code.trim();
  const fullName = newSurgeryType.value.fullName.trim();

  return (
    code.length > 0 &&
    code.length <= 5 &&
    fullName.length > 0 &&
    !surgeryTypes.value.includes(code.toUpperCase())
  );
});

// This function is now defined above as a const arrow function

// Get SDST value between two surgery types
function getSDSTValue(fromType, toType) {
  if (fromType === toType) return '-';

  if (store.sdsRules[fromType] && store.sdsRules[fromType][toType] !== undefined) {
    return store.sdsRules[fromType][toType];
  }

  return 'N/A';
}

// Get SDST value as a number for color coding
function getSDSTValueNumber(fromType, toType) {
  if (fromType === toType) return 0;

  if (store.sdsRules[fromType] && store.sdsRules[fromType][toType] !== undefined) {
    return store.sdsRules[fromType][toType];
  }

  return 0; // Default for N/A
}

// Get initial setup time for a surgery type
function getInitialSetupTime(type) {
  return store.initialSetupTimes[type] !== undefined ? store.initialSetupTimes[type] : 'N/A';
}

// Open edit modal for SDST value
function openEditModal(fromType, toType) {
  editingFromType.value = fromType;
  editingToType.value = toType;
  editingValue.value = store.sdsRules[fromType]?.[toType] || 0;
  isInitialSetup.value = false;
  showEditModal.value = true;
}

// Open edit modal for initial setup time
function openEditInitialSetupModal(toType) {
  editingFromType.value = 'Initial';
  editingToType.value = toType;
  editingValue.value = store.initialSetupTimes[toType] || 0;
  isInitialSetup.value = true;
  showEditModal.value = true;
}

// Close edit modal
function closeEditModal() {
  showEditModal.value = false;
}

// Save SDST value
function saveSDSTValue() {
  if (isInitialSetup.value) {
    // Update initial setup time
    store.updateInitialSetupTime(editingToType.value, editingValue.value);
  } else {
    // Update SDST value
    store.updateSDSTValue(editingFromType.value, editingToType.value, editingValue.value);
  }

  closeEditModal();
}

// Add new surgery type
function addNewSurgeryType() {
  if (!isNewSurgeryTypeValid.value) return;

  const code = newSurgeryType.value.code.trim().toUpperCase();

  // Add to store (which now handles adding to surgeryTypes)
  store.addNewSurgeryType(
    code,
    newSurgeryType.value.fullName.trim(),
    newSurgeryType.value.initialSetupTime
  );

  // Reset form
  newSurgeryType.value = {
    code: '',
    fullName: '',
    initialSetupTime: 30
  };

  showAddSurgeryTypeModal.value = false;
}

// Confirm delete surgery type
function confirmDeleteSurgeryType(type) {
  typeToDelete.value = type;
  showDeleteConfirmModal.value = true;
}

// Delete surgery type
function deleteSurgeryType() {
  if (!typeToDelete.value) return;

  // Call store method to delete the surgery type
  store.deleteSurgeryType(typeToDelete.value);

  // Close the modal
  showDeleteConfirmModal.value = false;
  typeToDelete.value = '';
}

// Handle bulk update from the bulk editor
function handleBulkUpdate() {
  console.log('Bulk update completed');
  // No need to do anything here as the store is already updated by the bulk editor
}

// Load data
onMounted(async () => {
  isLoading.value = true;
  try {
    // In a real app, this would fetch SDST data from the backend
    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API call
  } catch (error) {
    console.error('Failed to load SDST data:', error);
  } finally {
    isLoading.value = false;
  }
});
</script>

<style scoped>
.sdst-management-screen {
  padding: var(--spacing-md);
  max-width: 1200px;
  margin: 0 auto;
}

.description {
  margin-bottom: var(--spacing-lg);
  color: var(--color-text-secondary);
}

.controls-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-md);
}

.action-buttons {
  display: flex;
  gap: var(--spacing-sm);
}

.search-input {
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  width: 300px;
}

.sdst-matrix-container {
  position: relative;
  overflow-x: auto;
  margin-bottom: var(--spacing-lg);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-md);
  background-color: var(--color-background);
}

.sdst-matrix {
  width: 100%;
  border-collapse: collapse;
}

.sdst-matrix caption {
  padding: var(--spacing-sm);
  font-weight: var(--font-weight-bold);
  text-align: left;
  background-color: var(--color-background-soft);
  border-bottom: 1px solid var(--color-border);
}

.sdst-matrix th,
.sdst-matrix td {
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border-soft);
  text-align: center;
  position: relative;
}

.sdst-matrix th {
  background-color: var(--color-background-soft);
  font-weight: var(--font-weight-bold);
  position: sticky;
  top: 0;
  z-index: 1;
}

.sdst-matrix th:first-child {
  left: 0;
  z-index: 2;
}

.surgery-type-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.delete-type-btn {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background-color: transparent;
  border: none;
  color: var(--color-text-secondary);
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: 0.5;
  transition: all 0.2s ease;
}

.delete-type-btn:hover {
  background-color: var(--color-danger, #dc3545);
  color: white;
  opacity: 1;
}

.surgery-type-label {
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-normal);
  color: var(--color-text-secondary);
  white-space: nowrap;
}

.same-type {
  background-color: var(--color-background-mute);
}

.editable {
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.editable:hover {
  background-color: var(--color-background-hover);
}

/* SDST value color coding */
.sdst-low {
  background-color: rgba(40, 167, 69, 0.1); /* Green with low opacity */
  color: #28a745;
}

.sdst-medium {
  background-color: rgba(255, 193, 7, 0.1); /* Yellow with low opacity */
  color: #d39e00;
}

.sdst-high {
  background-color: rgba(220, 53, 69, 0.1); /* Red with low opacity */
  color: #dc3545;
}

.sdst-low:hover, .sdst-medium:hover, .sdst-high:hover {
  opacity: 0.8;
}

.legend {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--color-border);
}

.legend-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  min-width: 200px;
  margin-bottom: var(--spacing-xs);
}

.legend-color {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
}

/* Modal styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: var(--z-index-modal);
}

.modal-content {
  background-color: var(--color-background);
  border-radius: var(--border-radius-md);
  padding: var(--spacing-lg);
  width: 400px;
  max-width: 90%;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: var(--spacing-md);
}

.form-group {
  margin-bottom: var(--spacing-md);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: var(--font-weight-medium);
}

.form-control {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-lg);
}

/* Loading overlay */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: var(--spacing-md);
  z-index: 10;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(var(--color-primary-rgb, 0, 120, 212), 0.2);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.danger-text {
  color: var(--color-danger, #dc3545);
}

.warning-text {
  color: var(--color-warning, #ffc107);
  font-weight: var(--font-weight-medium);
  background-color: rgba(255, 193, 7, 0.1);
  padding: var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  border-left: 3px solid var(--color-warning, #ffc107);
}

.btn-danger {
  background-color: var(--color-danger, #dc3545);
  color: white;
  border: none;
}

.btn-danger:hover {
  background-color: var(--color-danger-dark, #bd2130);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .controls-section {
    flex-direction: column;
    align-items: stretch;
    gap: var(--spacing-sm);
  }

  .search-input {
    width: 100%;
  }

  .action-buttons {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-sm);
  }

  .legend {
    flex-direction: column;
    gap: var(--spacing-xs);
    padding: var(--spacing-sm);
  }

  .legend-item {
    min-width: 100%;
  }
}
</style>



================================================
FILE: src/components/SurgeryDetailsPanel.vue
================================================

<template>
  <aside class="details-panel" v-if="selectedSurgery">
    <h3>Surgery Details</h3>
    <div class="detail-section">
      <h4>Patient Information</h4>
      <p><strong>Patient ID:</strong> {{ selectedSurgery.patientId }}</p>
      <p><strong>Patient Name:</strong> {{ selectedSurgery.patientName }}</p>
      <!-- Add EHR integration link/info here if applicable -->
      <!-- As per guide.txt 8.1.1: Link to patient's EHR record -->
      <!-- <p v-if="selectedSurgery.ehrLink"><a :href="selectedSurgery.ehrLink" target="_blank">View in EHR</a></p> -->
    </div>

    <div class="detail-section">
      <h4>Surgery Information</h4>
      <p><strong>Surgery Type:</strong> {{ selectedSurgery.fullType }}</p>
      <p><strong>Estimated Duration:</strong> {{ selectedSurgery.estimatedDuration }} minutes</p>
      <p><strong>Priority:</strong> {{ selectedSurgery.priority }}</p>
      <p><strong>Scheduled Time:</strong> {{ formatDateTime(selectedSurgery.startTime) }}</p>
      <p><strong>Operating Room:</strong> {{ selectedSurgery.orName }}</p>
       <!-- Display actual duration if different from estimated -->
       <p v-if="selectedSurgery.duration !== selectedSurgery.estimatedDuration">
           <strong>Actual Duration:</strong> {{ selectedSurgery.duration }} minutes
       </p>
       <p v-if="selectedSurgery.status"><strong>Status:</strong> {{ selectedSurgery.status }}</p>
    </div>

    <div class="detail-section">
      <h4>Required Resources</h4>
      <p><strong>Surgeon(s):</strong> {{ selectedSurgery.requiredSurgeons.join(', ') }}</p>
      <p><strong>Staff Roles:</strong> {{ selectedSurgery.requiredStaffRoles.join(', ') }}</p>
      <p><strong>Equipment:</strong> {{ selectedSurgery.requiredEquipment.join(', ') }}</p>
       <!-- Display resource availability status for the scheduled time -->
       <!-- This would require fetching/calculating resource availability for the surgery's time slot -->
       <!-- <div v-if="selectedSurgery.resourceStatus">
         <p><strong>Resource Status:</strong></p>
          <div v-for="(status, resource) in selectedSurgery.resourceStatus" :key="resource">
              <span :class="{'status-available': status === 'Available', 'status-unavailable': status !== 'Available'}">●</span>
              {{ resource }}: {{ status }}
          </div>
       </div> -->
    </div>

    <div class="detail-section">
      <h4>Sequence-Dependent Setup Time (SDST)</h4>
      <p>
         <strong>Calculated SDST:</strong>
         <span class="sdst-value">{{ selectedSurgery.sdsTime }}</span> minutes
      </p>
      <p class="sdst-explanation">
         (Required between <strong>{{ selectedSurgery.precedingType }}</strong> and <strong>{{ selectedSurgery.type }}</strong>)
      </p>
       <!-- Link to SDST matrix entry if needed (guide.txt 7.1) -->
       <!-- <p><a href="#">View SDST Rule Details</a></p> -->
    </div>

    <!-- Display Conflict Alerts (guide.txt 7.2) -->
    <div class="detail-section conflicts" v-if="selectedSurgery.conflicts && selectedSurgery.conflicts.length">
        <h4>Alerts / Conflicts</h4>
        <ul>
            <li v-for="(conflict, index) in selectedSurgery.conflicts" :key="index" class="conflict-alert">
                <span class="alert-icon" aria-hidden="true">⚠️</span> {{ conflict }}
            </li>
        </ul>
    </div>


    <!-- Action buttons (Edit, Cancel) -->
    <div class="action-buttons">
      <!-- Disable buttons if surgery is cancelled or in progress -->
      <button class="btn btn-secondary" @click="handleEditSurgery" :disabled="!isEditable">Edit Surgery</button>
      <button class="btn btn-danger" @click="handleCancelSurgery" :disabled="!isCancellable">Cancel Surgery</button>
    </div>

     <!-- Placeholder Confirmation Modal (visually hidden or handled by a global component) -->
     <!-- In a real app, this would be a dedicated modal component -->
     <div v-if="showCancelConfirmation" class="confirmation-modal-placeholder">
         <p>Are you sure you want to cancel the surgery for {{ selectedSurgery.patientName }}?</p>
         <button @click="confirmCancel">Yes, Cancel</button>
         <button @click="cancelCancel">No, Keep Surgery</button>
     </div>

  </aside>
  <aside class="details-panel empty" v-else>
      <p>Select a surgery from the schedule or pending list to view details.</p>
  </aside>
</template>

<script setup>
import { computed, ref } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';
import { storeToRefs } from 'pinia';

const store = useScheduleStore();
// Use the getter from the store to get the full selected surgery object
const { selectedSurgery } = storeToRefs(store);

const showCancelConfirmation = ref(false); // State to control confirmation modal

// Computed property to determine if the surgery is editable
const isEditable = computed(() => {
    // A surgery is editable if it exists and its status is not 'Completed' or 'Cancelled'
    return selectedSurgery.value && selectedSurgery.value.status !== 'Completed' && selectedSurgery.value.status !== 'Cancelled';
});

// Computed property to determine if the surgery is cancellable
const isCancellable = computed(() => {
     // A surgery is cancellable if it exists and its status is not 'Completed' or 'Cancelled'
    return selectedSurgery.value && selectedSurgery.value.status !== 'Completed' && selectedSurgery.value.status !== 'Cancelled';
});


const formatDateTime = (dateString) => {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    // Format date and time clearly
    return date.toLocaleString([], { dateStyle: 'short', timeStyle: 'short' });
};

// --- Action Handlers ---

const handleEditSurgery = () => {
    console.log('Details Panel: Edit Surgery clicked for', selectedSurgery.value.id);
    // In a real app, this would typically emit an event to the parent
    // to open a modal or navigate to a surgery edit form,
    // passing the selectedSurgery.value as data.
    // Example: emit('edit-surgery', selectedSurgery.value);

    // Placeholder: Log the action
    alert(`Simulating Edit for Surgery: ${selectedSurgery.value.patientName}`);
    // After editing and saving (in modal/form), you would dispatch store.editSurgery(surgeryId, updatedData)
};

const handleCancelSurgery = () => {
    console.log('Details Panel: Cancel Surgery clicked for', selectedSurgery.value.id);
    // Show confirmation modal before canceling
    showCancelConfirmation.value = true;
};

const confirmCancel = async () => {
    console.log('Details Panel: Confirm Cancel clicked for', selectedSurgery.value.id);
    showCancelConfirmation.value = false; // Close modal
    if (selectedSurgery.value) {
        // Dispatch the cancel action to the store
        await store.cancelSurgery(selectedSurgery.value.id);
        // The store will handle updating the state and showing loading/error if needed
        // After successful cancellation, you might want to clear the selected surgery
         if (!store.error) { // Check for error in store state after action
             store.clearSelectedSurgery();
         }
    }
};

const cancelCancel = () => {
    console.log('Details Panel: Cancel action aborted.');
    showCancelConfirmation.value = false; // Close modal without canceling
};

</script>

<style scoped>
.details-panel {
  width: 300px; /* Fixed width for the panel */
  border-left: 1px solid var(--color-border);
  padding: var(--spacing-md);
  overflow-y: auto; /* Allow scrolling if content overflows */
  background-color: var(--color-background-soft);
  flex-shrink: 0;
  height: 100%; /* Ensure panel takes full height of its container */
  display: flex;
  flex-direction: column;
}

.details-panel.empty {
    align-items: center;
    justify-content: center;
    color: var(--color-text-secondary);
    text-align: center;
}

.details-panel h3 {
  margin-top: 0;
  margin-bottom: var(--spacing-md);
  color: var(--color-text);
}

.details-panel h4 {
  margin-top: var(--spacing-md);
  margin-bottom: var(--spacing-sm);
  color: var(--color-text-secondary);
  border-bottom: 1px solid var(--color-border-soft);
  padding-bottom: var(--spacing-xs);
}

.detail-section {
  margin-bottom: var(--spacing-md);
}

.detail-section p {
  margin-bottom: var(--spacing-xs);
  line-height: 1.4;
  font-size: var(--font-size-base);
   color: var(--color-text);
}

.detail-section p strong {
    color: var(--color-text);
}


.sdst-value {
    font-weight: bold;
    color: var(--color-accent); /* Highlight SDST value */
}

.sdst-explanation {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
  margin-top: var(--spacing-xs);
  font-style: italic;
}

.conflicts h4 {
    color: var(--color-error); /* Red color for conflict header */
    border-color: var(--color-error); /* Red border */
}

.conflict-alert {
    color: var(--color-error); /* Red color for conflict text */
    font-size: var(--font-size-base);
    margin-bottom: var(--spacing-xs);
    list-style: none; /* Remove default list styling */
    padding-left: 0;
    display: flex;
    align-items: center;
    font-weight: var(--font-weight-medium); /* Make alerts slightly bolder */
}

.alert-icon {
    margin-right: var(--spacing-xs);
    font-size: var(--font-size-lg); /* Slightly larger icon */
     /* Color is inherited from parent .conflict-alert */
}


.action-buttons {
  margin-top: auto; /* Push buttons to the bottom */
  display: flex;
  gap: var(--spacing-sm);
  padding-top: var(--spacing-md); /* Add some space above buttons */
  border-top: 1px solid var(--color-border-soft); /* Separator line */
}

.btn {
    padding: var(--spacing-sm) var(--spacing-md);
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: var(--font-size-base);
    transition: background-color 0.2s ease, opacity 0.2s ease;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.btn-secondary {
    background-color: var(--color-background-mute);
    color: var(--color-text);
    border: 1px solid var(--color-border);
}

.btn-secondary:hover:not(:disabled) {
    background-color: rgba(0, 0, 0, 0.05); /* Use rgba for darkening effect */
}

.btn-danger {
    background-color: var(--color-error);
    color: var(--color-text-inverted);
}

.btn-danger:hover:not(:disabled) {
    background-color: rgba(0, 0, 0, 0.1); /* Use rgba for darkening effect */
}

/* Placeholder Confirmation Modal Styling */
.confirmation-modal-placeholder {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--color-white);
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    z-index: var(--z-index-modal);
    text-align: center;
    max-width: 400px;
    width: 90%;
    border: 1px solid var(--color-border);
}

.confirmation-modal-placeholder button {
    margin: var(--spacing-sm);
}

</style>



================================================
FILE: src/components/SurgeryFormScreen.vue
================================================
<template>
  <div class="surgery-form-container">
    <!-- Change text based on isEditMode -->
    <form>
 <div class="form-group">
        <label for="patient">Patient:</label>
        <!-- TODO: Replace with a patient search/select component (e.g., dropdown with search) -->
 <input type="text" id="patient" placeholder="Select Patient">
 <!-- TODO: Add v-model="newSurgery.patient" when component is ready -->
      </div>

 <div class="form-group">
        <label for="procedure">Procedure:</label>
 <input type="text" id="procedure" v-model="newSurgery.procedure">
      </div>

 <div class="form-group">
        <label for="date">Date:</label>
 <input type="date" id="date" v-model="newSurgery.date">
      </div>

      <div class="form-group">
        <label for="startTime">Start Time:</label>
 <input type="time" id="startTime" v-model="newSurgery.startTime">
      </div>

      <div class="form-group">
        <label for="endTime">End Time:</label>
 <input type="time" id="endTime" v-model="newSurgery.endTime">
      </div>

      <div class="form-group">
        <label for="requiredOr">Required OR:</label>
        <!-- TODO: Replace with an OR select component (e.g., dropdown) -->
        <input type="text" id="requiredOr" placeholder="Select OR">
        <!-- TODO: Add v-model="newSurgery.requiredOR" when component is ready -->
      </div>

      <div class="form-group">
        <label for="requiredStaff">Required Staff:</label>
        <!-- TODO: Replace with a staff multi-select component (e.g., searchable dropdown) -->
        <input type="text" id="requiredStaff" placeholder="Select Staff">
        <!-- TODO: Add v-model="newSurgery.requiredStaff" when component is ready -->
      </div>

      <div class="form-group">
        <label for="requiredEquipment">Required Equipment:</label>
        <!-- TODO: Replace with an equipment multi-select component (e.g., searchable dropdown) -->
        <input type="text" id="requiredEquipment" placeholder="Select Equipment">
        <!-- TODO: Add v-model="newSurgery.requiredEquipment" when component is ready -->
      </div>
      <button type="submit" class="button-primary" @click.prevent="submitSurgery">Create Surgery</button>

    </form>
  </div>
</template>

<template>
  <div class="surgery-form-container">
    <h1 v-if="isEditMode">Edit Surgery</h1>
 <h1 v-else>Create New Surgery</h1>
 <form>
      <!-- ... (form content remains the same) ... -->
      <button type="submit" class="button-primary" @click.prevent="submitSurgery">{{ isEditMode ? 'Save Changes' : 'Create Surgery' }}</button>
    </form>
    <!-- TODO: Add v-if="isLoading" to show a loading state while initial data is fetched (e.g., lists for dropdowns) -->
  </div>
</template>

<script setup>
// TODO: Manage colors using CSS variables or a color palette for consistency across the application.import { ref, computed, onMounted } from 'vue';

const props = defineProps({
  surgeryId: { type: Number, default: null }
});

const isEditMode = computed(() => props.surgeryId !== null);

const newSurgery = ref({
 // Use null or appropriate default for relationship IDs
  patient: null, // Or an empty object {} if selecting an object
  // Assuming simple text input for now based on template placeholders.
  // This would likely change to an ID or object when using a select component.
 patient: '',

 // TODO: Add v-model="newSurgery.patient" when component is ready
 // patient: '', // Placeholder for simple text input before component

 procedure: '',
 date: '',
 startTime: '',
 endTime: '',
 requiredOR: null, // Or an empty object {}
 requiredStaff: [],
 requiredEquipment: []
});

// In edit mode, fetch existing data
onMounted(async () => {
  if (isEditMode.value && props.surgeryId) {
    isLoading.value = true;
    // Simulate fetching existing surgery data
    const existingSurgeryData = await fetchSurgeryData(props.surgeryId);
    if (existingSurgeryData) {
      // Populate the form with fetched data
      Object.assign(newSurgery.value, existingSurgeryData);
    }
    isLoading.value = false;
  }
});

// Simulate fetching existing surgery data (placeholder)
const fetchSurgeryData = async (id) => {
  console.log(`Simulating fetching surgery data for ID: ${id}`);
  await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay
  // Return a hardcoded object for now
  return {
    patient: 'Jane Doe',
    procedure: 'Appendectomy',
    date: '2023-10-27',
    startTime: '09:00',
    endTime: '10:30',
    requiredOR: 1,
    requiredStaff: [101, 102],
    requiredEquipment: [201],
  };
};

const isLoading = ref(false);

const submitSurgery = () => {
  if (isEditMode.value) {
    console.log('Saving changes for surgery ID:', props.surgeryId);
    // TODO: Send update request for newSurgery.value to the backend API.
    // On success, potentially navigate back or show a success message.
    // On failure, show an error message.
  } else {
    console.log('Attempting to submit new surgery:', newSurgery.value);
    // TODO: Send newSurgery.value to the backend API to save the surgery record.
    // On success, potentially navigate to the master schedule or show a success message.
    // On failure, show an error message.
  }
};

// Placeholder method for deleting a surgery
const deleteSurgery = () => {
  console.log('Delete Surgery button clicked for ID:', props.surgeryId);
  // TODO: Send delete request to the backend API for props.surgeryId.
  // On success, navigate away from the form (e.g., to the Master Schedule) or show a success message.
  // On failure, show an error message.
};
</script>
<!-- TODO: Add v-if="isLoading" to show a loading state while initial data is fetched (e.g., lists for dropdowns) -->
<!-- TODO: Wrap form in v-else -->
<style scoped>
/* TODO: Add v-model="newSurgery.requiredEquipment" when component is ready */
</style>


================================================
FILE: src/components/SurgerySchedulingScreen.vue
================================================

<template>
  <div class="surgery-scheduling-screen">
    <!-- Assuming a header/layout component is outside this -->
    <div class="surgery-scheduling-layout">

      <!-- Left Panel: Pending Surgeries List -->
      <div class="pending-surgeries-panel">
        <PendingSurgeriesList />
      </div>

      <!-- Main Content Area: Gantt Chart -->
      <div class="main-schedule-area">
        <!-- Add Filters/Controls row here later if needed -->
        <GanttChart />
      </div>

      <!-- Right Panel: Surgery Details -->
      <div class="details-panel-container">
         <!-- SurgeryDetailsPanel is inside this container -->
        <SurgeryDetailsPanel />
      </div>

    </div>
     <!-- Optional: Loading indicator for the whole screen -->
    <div v-if="store.isLoading" class="loading-overlay">Loading...</div>

  </div>
</template>

<script setup>
import { onMounted } from 'vue';
import { useScheduleStore } from '@/stores/scheduleStore';
import PendingSurgeriesList from './PendingSurgeriesList.vue';
import GanttChart from './GanttChart.vue';
import SurgeryDetailsPanel from './SurgeryDetailsPanel.vue';

const store = useScheduleStore();

// Load initial data when the screen component is mounted
onMounted(() => {
    store.loadInitialData();
});

</script>

<style scoped>
/* Styles for the main screen layout */
.surgery-scheduling-screen {
    display: flex;
    flex-direction: column;
    height: 100vh; /* Full viewport height */
    overflow: hidden; /* Prevent scrollbars on the screen itself */
    position: relative; /* For positioning loading overlay */
}

.surgery-scheduling-layout {
  display: flex;
  /* Use calc for height if there's a fixed header/footer */
  /* height: calc(100vh - var(--header-height, 0) - var(--footer-height, 0)); */
  height: 100%; /* Take full height of parent */
  overflow: hidden; /* Ensure child panels manage their own scrolling */
}

.pending-surgeries-panel {
  /* Styles are mostly in PendingSurgeriesList.vue, but can add layout overrides here if necessary */
  /* width: 250px; */ /* Defined in component for encapsulation */
  /* flex-shrink: 0; */
}

.main-schedule-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* GanttChart handles its own scrolling */
}

.details-panel-container {
  /* Styles are mostly in SurgeryDetailsPanel.vue */
  /* width: 300px; */ /* Defined in component for encapsulation */
  /* flex-shrink: 0; */
}

/* Loading overlay for the entire screen */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: var(--font-size-lg);
    color: var(--color-primary);
    z-index: var(--z-index-modal); /* Above all other screen content */
}
</style>



================================================
FILE: src/components/ToastNotification.vue
================================================
<template>
  <Teleport to="body">
    <div class="toast-container" data-testid="toast-notification">
      <TransitionGroup name="toast">
        <div
          v-for="toast in toasts"
          :key="toast.id"
          class="toast"
          :class="[`toast-${toast.type}`, { 'with-action': toast.action }]"
          role="alert"
          aria-live="assertive"
        >
          <div class="toast-icon" aria-hidden="true">
            <span v-if="toast.type === 'success'">✓</span>
            <span v-else-if="toast.type === 'error'">✕</span>
            <span v-else-if="toast.type === 'warning'">⚠</span>
            <span v-else>ℹ</span>
          </div>
          <div class="toast-content">
            <div v-if="toast.title" class="toast-title">{{ toast.title }}</div>
            <div class="toast-message">{{ toast.message }}</div>
          </div>
          <button
            v-if="toast.action"
            class="toast-action"
            @click="toast.action.callback"
            :aria-label="toast.action.label"
          >
            {{ toast.action.label }}
          </button>
          <button
            class="toast-close"
            @click="dismissToast(toast.id)"
            aria-label="Close notification"
          >
            ✕
          </button>
        </div>
      </TransitionGroup>
    </div>
  </Teleport>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';

// Toast data structure
// {
//   id: string,
//   type: 'success' | 'error' | 'warning' | 'info',
//   message: string,
//   title?: string,
//   duration?: number,
//   action?: { label: string, callback: Function }
// }

const toasts = ref([]);
const toastTimeouts = ref({});

// Add a new toast notification
const addToast = (toast) => {
  const id = `toast-${Date.now()}`;
  const newToast = {
    id,
    type: toast.type || 'info',
    message: toast.message,
    title: toast.title || null,
    duration: toast.duration !== undefined ? toast.duration : 5000, // Default 5 seconds
    action: toast.action || null
  };

  toasts.value.push(newToast);

  // Auto-dismiss after duration
  if (newToast.duration > 0) {
    toastTimeouts.value[id] = setTimeout(() => {
      dismissToast(id);
    }, newToast.duration);
  }

  return id;
};

// Dismiss a toast by ID
const dismissToast = (id) => {
  const index = toasts.value.findIndex(t => t.id === id);
  if (index !== -1) {
    toasts.value.splice(index, 1);

    // Clear the timeout
    if (toastTimeouts.value[id]) {
      clearTimeout(toastTimeouts.value[id]);
      delete toastTimeouts.value[id];
    }
  }
};

// Expose methods to parent components
defineExpose({
  addToast,
  dismissToast
});

// Clean up timeouts on component unmount
onUnmounted(() => {
  Object.values(toastTimeouts.value).forEach(timeout => {
    clearTimeout(timeout);
  });
});
</script>

<style scoped>
.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
  max-width: 400px;
  width: calc(100% - 40px);
}

.toast {
  display: flex;
  align-items: flex-start;
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  background-color: var(--color-background);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  margin-bottom: var(--spacing-sm);
  animation: slide-in 0.3s ease-out;
  border-left: 4px solid var(--color-primary);
}

.toast-success {
  border-left-color: var(--color-success, #10b981);
}

.toast-error {
  border-left-color: var(--color-error, #ef4444);
}

.toast-warning {
  border-left-color: var(--color-warning, #f59e0b);
}

.toast-info {
  border-left-color: var(--color-primary);
}

.toast-icon {
  margin-right: var(--spacing-sm);
  font-size: 1.2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  flex-shrink: 0;
}

.toast-success .toast-icon {
  color: var(--color-success, #10b981);
}

.toast-error .toast-icon {
  color: var(--color-error, #ef4444);
}

.toast-warning .toast-icon {
  color: var(--color-warning, #f59e0b);
}

.toast-info .toast-icon {
  color: var(--color-primary);
}

.toast-content {
  flex-grow: 1;
  margin-right: var(--spacing-sm);
}

.toast-title {
  font-weight: var(--font-weight-bold);
  margin-bottom: var(--spacing-xs);
}

.toast-message {
  font-size: var(--font-size-sm);
  color: var(--color-text);
}

.toast-close {
  background: none;
  border: none;
  color: var(--color-text-secondary);
  cursor: pointer;
  font-size: var(--font-size-sm);
  padding: var(--spacing-xs);
  margin: calc(-1 * var(--spacing-xs));
  border-radius: var(--border-radius-sm);
}

.toast-close:hover {
  color: var(--color-text);
  background-color: var(--color-background-mute);
}

.toast-action {
  margin-right: var(--spacing-sm);
  background-color: transparent;
  border: 1px solid currentColor;
  border-radius: var(--border-radius-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: var(--font-size-sm);
  cursor: pointer;
  color: inherit;
}

.toast-success .toast-action {
  color: var(--color-success, #10b981);
}

.toast-error .toast-action {
  color: var(--color-error, #ef4444);
}

.toast-warning .toast-action {
  color: var(--color-warning, #f59e0b);
}

.toast-info .toast-action {
  color: var(--color-primary);
}

/* Transitions */
.toast-enter-active,
.toast-leave-active {
  transition: all 0.3s ease;
}

.toast-enter-from {
  opacity: 0;
  transform: translateX(30px);
}

.toast-leave-to {
  opacity: 0;
  transform: translateX(30px);
}

@keyframes slide-in {
  from {
    transform: translateX(30px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .toast-container {
    top: auto;
    bottom: 20px;
    left: 20px;
    right: 20px;
    max-width: none;
    width: calc(100% - 40px);
  }
}
</style>



================================================
FILE: src/components/UtilizationReports.vue
================================================
<template>
  <div class="utilization-reports">
    <h1>Utilization Reports</h1>
    
    <!-- Report Controls -->
    <div class="report-controls">
      <div class="filter-section">
        <h3>Filters</h3>
        <div class="filter-group">
          <label for="resource-type">Resource Type</label>
          <select id="resource-type" v-model="selectedResourceType">
            <option value="or">Operating Rooms</option>
            <option value="surgeon">Surgeons</option>
            <option value="equipment">Equipment</option>
          </select>
        </div>
        
        <div class="filter-group">
          <label for="date-range">Date Range</label>
          <select id="date-range" v-model="selectedDateRange">
            <option value="last7">Last 7 Days</option>
            <option value="last30">Last 30 Days</option>
            <option value="thisMonth">This Month</option>
            <option value="lastMonth">Last Month</option>
            <option value="custom">Custom Range</option>
          </select>
        </div>
        
        <div v-if="selectedDateRange === 'custom'" class="custom-date-range">
          <div class="date-input">
            <label for="start-date">Start Date</label>
            <input 
              type="date" 
              id="start-date" 
              v-model="customDateRange.start"
            >
          </div>
          <div class="date-input">
            <label for="end-date">End Date</label>
            <input 
              type="date" 
              id="end-date" 
              v-model="customDateRange.end"
            >
          </div>
        </div>
        
        <button class="apply-button" @click="applyFilters">Apply Filters</button>
      </div>
      
      <div class="view-options">
        <h3>View Options</h3>
        <div class="view-option-group">
          <label for="chart-type">Chart Type</label>
          <select id="chart-type" v-model="selectedChartType">
            <option value="bar">Bar Chart</option>
            <option value="line">Line Chart</option>
            <option value="pie">Pie Chart</option>
          </select>
        </div>
        
        <div class="view-option-group">
          <label for="metric">Primary Metric</label>
          <select id="metric" v-model="selectedMetric">
            <option value="utilizationRate">Utilization Rate</option>
            <option value="idleTime">Idle Time</option>
            <option value="overtimeRate">Overtime Rate</option>
            <option value="surgeryCount">Surgery Count</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Loading Indicator -->
    <div v-if="isLoading" class="loading-overlay">
      <div class="spinner"></div>
      <p>Loading report data...</p>
    </div>
    
    <!-- Report Content -->
    <div v-else class="report-content">
      <h2>{{ reportTitle }}</h2>
      
      <!-- Chart Area -->
      <div class="chart-area">
        <div class="chart-container">
          <!-- Chart would be rendered here using a charting library -->
          <div class="chart-placeholder">
            <div class="chart-mock" :class="selectedChartType">
              <!-- Mock chart content based on selectedChartType -->
              <template v-if="selectedChartType === 'bar'">
                <div 
                  v-for="(item, index) in chartData" 
                  :key="index" 
                  class="chart-bar" 
                  :style="{ height: `${item.value * 100}%` }"
                >
                  <div class="bar-label">{{ item.label }}</div>
                </div>
              </template>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Data Table -->
      <div class="data-table-container">
        <h3>Detailed Data</h3>
        <table class="data-table">
          <thead>
            <tr>
              <th>Resource</th>
              <th>Utilization Rate</th>
              <th>Idle Time (hrs)</th>
              <th>Overtime Rate</th>
              <th>Surgery Count</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(item, index) in tableData" :key="index">
              <td>{{ item.name }}</td>
              <td>{{ formatPercentage(item.utilizationRate) }}</td>
              <td>{{ item.idleTime.toFixed(1) }}</td>
              <td>{{ formatPercentage(item.overtimeRate) }}</td>
              <td>{{ item.surgeryCount }}</td>
            </tr>
          </tbody>
          <tfoot>
            <tr>
              <td><strong>Average</strong></td>
              <td>{{ formatPercentage(averageUtilization) }}</td>
              <td>{{ averageIdleTime.toFixed(1) }}</td>
              <td>{{ formatPercentage(averageOvertimeRate) }}</td>
              <td>{{ totalSurgeryCount }}</td>
            </tr>
          </tfoot>
        </table>
      </div>
      
      <!-- Export Options -->
      <div class="export-options">
        <button @click="exportToPDF">Export to PDF</button>
        <button @click="exportToCSV">Export to CSV</button>
        <button @click="saveAsCustomReport">Save as Custom Report</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue';
import { useAnalyticsStore } from '@/stores/analyticsStore';
import { storeToRefs } from 'pinia';

const analyticsStore = useAnalyticsStore();
const { isLoading, error } = storeToRefs(analyticsStore);

// Filter state
const selectedResourceType = ref('or');
const selectedDateRange = ref('last30');
const customDateRange = ref({
  start: '',
  end: ''
});
const selectedChartType = ref('bar');
const selectedMetric = ref('utilizationRate');

// Mock data for demonstration
const chartData = ref([
  { label: 'OR 1', value: 0.85 },
  { label: 'OR 2', value: 0.72 },
  { label: 'OR 3', value: 0.65 },
  { label: 'OR 4', value: 0.91 },
  { label: 'OR 5', value: 0.78 },
]);

const tableData = ref([
  { name: 'OR 1', utilizationRate: 0.85, idleTime: 1.2, overtimeRate: 0.0, surgeryCount: 12 },
  { name: 'OR 2', utilizationRate: 0.72, idleTime: 2.2, overtimeRate: 0.0, surgeryCount: 8 },
  { name: 'OR 3', utilizationRate: 0.65, idleTime: 2.8, overtimeRate: 0.0, surgeryCount: 6 },
  { name: 'OR 4', utilizationRate: 0.91, idleTime: 0.7, overtimeRate: 0.0, surgeryCount: 14 },
  { name: 'OR 5', utilizationRate: 0.78, idleTime: 1.8, overtimeRate: 0.0, surgeryCount: 10 },
]);

// Computed properties
const reportTitle = computed(() => {
  const resourceTypeText = selectedResourceType.value === 'or' 
    ? 'Operating Room' 
    : selectedResourceType.value === 'surgeon' 
      ? 'Surgeon' 
      : 'Equipment';
  
  const metricText = selectedMetric.value === 'utilizationRate' 
    ? 'Utilization Rate' 
    : selectedMetric.value === 'idleTime' 
      ? 'Idle Time' 
      : selectedMetric.value === 'overtimeRate' 
        ? 'Overtime Rate' 
        : 'Surgery Count';
  
  return `${resourceTypeText} ${metricText} Report`;
});

const averageUtilization = computed(() => {
  return tableData.value.reduce((sum, item) => sum + item.utilizationRate, 0) / tableData.value.length;
});

const averageIdleTime = computed(() => {
  return tableData.value.reduce((sum, item) => sum + item.idleTime, 0) / tableData.value.length;
});

const averageOvertimeRate = computed(() => {
  return tableData.value.reduce((sum, item) => sum + item.overtimeRate, 0) / tableData.value.length;
});

const totalSurgeryCount = computed(() => {
  return tableData.value.reduce((sum, item) => sum + item.surgeryCount, 0);
});

// Methods
const formatPercentage = (value) => {
  return `${Math.round(value * 100)}%`;
};

const applyFilters = async () => {
  // In a real app, this would update the date range in the store and reload the data
  console.log('Applying filters:', {
    resourceType: selectedResourceType.value,
    dateRange: selectedDateRange.value,
    customDateRange: customDateRange.value,
    chartType: selectedChartType.value,
    metric: selectedMetric.value
  });
  
  // Simulate loading
  isLoading.value = true;
  await new Promise(resolve => setTimeout(resolve, 1000));
  isLoading.value = false;
  
  // In a real app, we would update the chart and table data here
};

const exportToPDF = () => {
  console.log('Exporting to PDF...');
  // In a real app, this would generate a PDF of the report
};

const exportToCSV = () => {
  console.log('Exporting to CSV...');
  // In a real app, this would generate a CSV of the report data
};

const saveAsCustomReport = () => {
  console.log('Saving as custom report...');
  // In a real app, this would save the current report configuration to the store
};

// Initialize the component
onMounted(async () => {
  // Set default date range
  const today = new Date();
  const thirtyDaysAgo = new Date(today);
  thirtyDaysAgo.setDate(today.getDate() - 30);
  
  customDateRange.value.start = thirtyDaysAgo.toISOString().split('T')[0];
  customDateRange.value.end = today.toISOString().split('T')[0];
  
  // Load initial data
  await applyFilters();
});

// Watch for changes in resource type to update the chart and table data
watch(selectedResourceType, async () => {
  await applyFilters();
});
</script>

<style scoped>
.utilization-reports {
  padding: var(--spacing-md);
  max-width: 1200px;
  margin: 0 auto;
}

h1, h2, h3 {
  margin-top: 0;
  color: var(--color-text);
}

h1 {
  margin-bottom: var(--spacing-lg);
}

h2 {
  margin-bottom: var(--spacing-md);
}

h3 {
  margin-bottom: var(--spacing-sm);
}

/* Report Controls */
.report-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.filter-section, .view-options {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
}

.filter-group, .view-option-group {
  margin-bottom: var(--spacing-sm);
}

.filter-group label, .view-option-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}

select, input {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-sm);
  background-color: var(--color-background);
}

.custom-date-range {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-sm);
}

.apply-button {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  margin-top: var(--spacing-sm);
}

/* Loading Overlay */
.loading-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(var(--color-primary-rgb), 0.1);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
  margin-bottom: var(--spacing-md);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Chart Area */
.chart-area {
  margin-bottom: var(--spacing-lg);
}

.chart-container {
  background-color: var(--color-background-soft);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  height: 400px;
}

.chart-placeholder {
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--color-background);
  border-radius: var(--border-radius-sm);
}

/* Mock charts for demonstration */
.chart-mock {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: flex-end;
  justify-content: space-around;
  padding: var(--spacing-md);
}

.chart-bar {
  background-color: var(--color-primary);
  width: 60px;
  border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
  position: relative;
}

.bar-label {
  position: absolute;
  bottom: -25px;
  left: 0;
  right: 0;
  text-align: center;
  font-size: var(--font-size-sm);
}

/* Data Table */
.data-table-container {
  margin-bottom: var(--spacing-lg);
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  background-color: var(--color-background-soft);
  border-radius: var(--border-radius-md);
  overflow: hidden;
}

.data-table th, .data-table td {
  padding: var(--spacing-sm);
  text-align: left;
  border-bottom: 1px solid var(--color-border);
}

.data-table th {
  background-color: var(--color-background-mute);
  font-weight: var(--font-weight-bold);
}

.data-table tbody tr:hover {
  background-color: var(--color-background-hover);
}

.data-table tfoot {
  background-color: var(--color-background-mute);
  font-weight: var(--font-weight-medium);
}

/* Export Options */
.export-options {
  display: flex;
  gap: var(--spacing-md);
  justify-content: flex-end;
}

.export-options button {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .report-controls {
    grid-template-columns: 1fr;
  }
  
  .custom-date-range {
    grid-template-columns: 1fr;
  }
  
  .export-options {
    flex-direction: column;
    align-items: stretch;
  }
}
</style>



================================================
FILE: src/components/__snapshots__/AddEditInitialSetupModal.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddEditInitialSetupModal > matches snapshot in add mode 1`] = `
"<div data-v-60ea9dff="" class="modal-overlay">
  <div data-v-60ea9dff="" class="modal-content">
    <h3 data-v-60ea9dff="">Add New Initial Setup Time</h3>
    <form data-v-60ea9dff="">
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-type">Surgery Type</label><!-- Dropdown to select surgery type -->
        <!-- This dropdown should be populated by surgery types passed from the parent --><select data-v-60ea9dff="" id="setup-type" required="">
          <!-- Disable type selection when editing -->
          <option data-v-60ea9dff="" value="">Select Surgery Type</option><!-- Options will be populated via v-for on a prop -->
          <option data-v-60ea9dff="" value="1">Surgery Type A</option>
          <option data-v-60ea9dff="" value="2">Surgery Type B</option>
        </select>
        <!--v-if-->
      </div>
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-time">Initial Setup Time (minutes)</label><input data-v-60ea9dff="" type="number" id="setup-time" required="" min="0"></div>
      <div data-v-60ea9dff="" class="form-actions"><button data-v-60ea9dff="" type="submit" class="button-primary">Add Setup Time</button><button data-v-60ea9dff="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;

exports[`AddEditInitialSetupModal > matches snapshot in edit mode 1`] = `
"<div data-v-60ea9dff="" class="modal-overlay">
  <div data-v-60ea9dff="" class="modal-content">
    <h3 data-v-60ea9dff="">Edit Initial Setup Time</h3>
    <form data-v-60ea9dff="">
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-type">Surgery Type</label><!-- Dropdown to select surgery type -->
        <!-- This dropdown should be populated by surgery types passed from the parent --><select data-v-60ea9dff="" id="setup-type" required="" disabled="">
          <!-- Disable type selection when editing -->
          <option data-v-60ea9dff="" value="">Select Surgery Type</option><!-- Options will be populated via v-for on a prop -->
          <option data-v-60ea9dff="" value="1">Surgery Type A</option>
          <option data-v-60ea9dff="" value="2">Surgery Type B</option>
        </select><small data-v-60ea9dff="">Cannot change Surgery Type when editing.</small>
      </div>
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-time">Initial Setup Time (minutes)</label><input data-v-60ea9dff="" type="number" id="setup-time" required="" min="0"></div>
      <div data-v-60ea9dff="" class="form-actions"><button data-v-60ea9dff="" type="submit" class="button-primary">Save Changes</button><button data-v-60ea9dff="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;



================================================
FILE: src/components/__snapshots__/AddEditSurgeryTypeModal.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddEditSurgeryTypeModal > matches snapshot in add mode 1`] = `
"<div data-v-09ed78bd="" class="modal-overlay">
  <div data-v-09ed78bd="" class="modal-content">
    <h3 data-v-09ed78bd="">Add New Surgery Type</h3>
    <form data-v-09ed78bd="">
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-name">Name</label><input data-v-09ed78bd="" type="text" id="type-name" required=""></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-code">Code (e.g., CABG, TKR)</label><input data-v-09ed78bd="" type="text" id="type-code"></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-description">Description</label><textarea data-v-09ed78bd="" id="type-description"></textarea></div>
      <div data-v-09ed78bd="" class="form-actions"><button data-v-09ed78bd="" type="submit" class="button-primary">Add Type</button><button data-v-09ed78bd="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;

exports[`AddEditSurgeryTypeModal > matches snapshot in edit mode 1`] = `
"<div data-v-09ed78bd="" class="modal-overlay">
  <div data-v-09ed78bd="" class="modal-content">
    <h3 data-v-09ed78bd="">Edit Surgery Type</h3>
    <form data-v-09ed78bd="">
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-name">Name</label><input data-v-09ed78bd="" type="text" id="type-name" required=""></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-code">Code (e.g., CABG, TKR)</label><input data-v-09ed78bd="" type="text" id="type-code"></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-description">Description</label><textarea data-v-09ed78bd="" id="type-description"></textarea></div>
      <div data-v-09ed78bd="" class="form-actions"><button data-v-09ed78bd="" type="submit" class="button-primary">Save Changes</button><button data-v-09ed78bd="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;



================================================
FILE: src/components/__snapshots__/AddEquipmentForm.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddEquipmentForm > matches snapshot in add mode 1`] = `
"<div data-v-509ecb30="" class="add-equipment-form">
  <h3 data-v-509ecb30="">Add New Equipment</h3>
  <form data-v-509ecb30="">
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-name">Name/ID</label><input data-v-509ecb30="" type="text" id="equipment-name">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-type">Type</label><input data-v-509ecb30="" type="text" id="equipment-type">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-status">Status</label><select data-v-509ecb30="" id="equipment-status">
        <option value="" data-v-509ecb30="">Select Status</option>
        <option value="Available" data-v-509ecb30="">Available</option>
        <option value="In Use" data-v-509ecb30="">In Use</option>
        <option value="Maintenance" data-v-509ecb30="">Maintenance</option>
        <option value="Retired" data-v-509ecb30="">Retired</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-location">Location</label><input data-v-509ecb30="" type="text" id="equipment-location"><small data-v-509ecb30="">E.g., OR 5, Storage Room B</small><!-- Location is optional, so no specific validation message for being empty -->
    </div>
    <div data-v-509ecb30="" class="form-actions"><button data-v-509ecb30="" type="submit" class="button-primary">Save Equipment</button><button data-v-509ecb30="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;

exports[`AddEquipmentForm > matches snapshot in edit mode 1`] = `
"<div data-v-509ecb30="" class="add-equipment-form">
  <h3 data-v-509ecb30="">Edit Equipment</h3>
  <form data-v-509ecb30="">
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-name">Name/ID</label><input data-v-509ecb30="" type="text" id="equipment-name">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-type">Type</label><input data-v-509ecb30="" type="text" id="equipment-type">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-status">Status</label><select data-v-509ecb30="" id="equipment-status">
        <option value="" data-v-509ecb30="">Select Status</option>
        <option value="Available" data-v-509ecb30="">Available</option>
        <option value="In Use" data-v-509ecb30="">In Use</option>
        <option value="Maintenance" data-v-509ecb30="">Maintenance</option>
        <option value="Retired" data-v-509ecb30="">Retired</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-location">Location</label><input data-v-509ecb30="" type="text" id="equipment-location"><small data-v-509ecb30="">E.g., OR 5, Storage Room B</small><!-- Location is optional, so no specific validation message for being empty -->
    </div>
    <div data-v-509ecb30="" class="form-actions"><button data-v-509ecb30="" type="submit" class="button-primary">Update Equipment</button><button data-v-509ecb30="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;



================================================
FILE: src/components/__snapshots__/AddOrForm.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddOrForm > matches snapshot in add mode 1`] = `
"<div data-v-4b031d55="" class="add-or-form">
  <h3 data-v-4b031d55="">Add New Operating Room</h3>
  <form data-v-4b031d55="">
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-name">Name/ID</label><input data-v-4b031d55="" type="text" id="or-name">
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-location">Location</label><input data-v-4b031d55="" type="text" id="or-location"><!-- No validation for location in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-status">Status</label><select data-v-4b031d55="" id="or-status">
        <option data-v-4b031d55="" value="">Select Status</option>
        <option data-v-4b031d55="" value="Active">Active</option>
        <option data-v-4b031d55="" value="Under Maintenance">Under Maintenance</option>
        <option data-v-4b031d55="" value="Inactive">Inactive</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-service">Primary Service</label><input data-v-4b031d55="" type="text" id="or-service"><!-- No validation for primary service in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="form-actions"><button data-v-4b031d55="" type="submit" class="button-primary">Save OR</button><button data-v-4b031d55="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;

exports[`AddOrForm > matches snapshot in edit mode 1`] = `
"<div data-v-4b031d55="" class="add-or-form">
  <h3 data-v-4b031d55="">Edit Operating Room</h3>
  <form data-v-4b031d55="">
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-name">Name/ID</label><input data-v-4b031d55="" type="text" id="or-name">
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-location">Location</label><input data-v-4b031d55="" type="text" id="or-location"><!-- No validation for location in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-status">Status</label><select data-v-4b031d55="" id="or-status">
        <option data-v-4b031d55="" value="">Select Status</option>
        <option data-v-4b031d55="" value="Active">Active</option>
        <option data-v-4b031d55="" value="Under Maintenance">Under Maintenance</option>
        <option data-v-4b031d55="" value="Inactive">Inactive</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-service">Primary Service</label><input data-v-4b031d55="" type="text" id="or-service"><!-- No validation for primary service in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="form-actions"><button data-v-4b031d55="" type="submit" class="button-primary">Update OR</button><button data-v-4b031d55="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;



================================================
FILE: src/components/__snapshots__/ConfirmationModal.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ConfirmationModal > matches snapshot when shown 1`] = `
"<div data-v-67e05d21="" class="modal-overlay">
  <div data-v-67e05d21="" class="modal-content">
    <h3 data-v-67e05d21="">Test Title</h3>
    <div data-v-67e05d21="" class="modal-body">
      <p data-v-67e05d21="">Test Message</p>
    </div>
    <div data-v-67e05d21="" class="form-actions"><button data-v-67e05d21="" type="button" class="button-danger">Confirm</button><button data-v-67e05d21="" type="button" class="button-secondary">Cancel</button></div>
  </div>
</div>"
`;



================================================
FILE: src/components/__tests__/AddEditInitialSetupModal.test.js
================================================
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import AddEditInitialSetupModal from '../AddEditInitialSetupModal.vue';

describe('AddEditInitialSetupModal', () => {
  const mockSurgeryTypes = [
    { id: 1, name: 'Surgery Type A' },
    { id: 2, name: 'Surgery Type B' },
  ];

  // Test case for adding a new initial setup time
  it('renders correctly in add mode', () => {
    const wrapper = mount(AddEditInitialSetupModal, {
      props: {
        show: true,
        isEditing: false,
        surgeryTypes: mockSurgeryTypes,
      },
    });

    expect(wrapper.find('.modal-overlay').exists()).toBe(true);
    expect(wrapper.text()).toContain('Add New Initial Setup Time');
    expect(wrapper.find('select#setup-type').exists()).toBe(true);
    expect(wrapper.find('select#setup-type').attributes('disabled')).toBeUndefined();
    expect(wrapper.find('input#setup-time').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Add Setup Time');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
  });

  // Test case for editing an existing initial setup time
  it('renders correctly in edit mode', () => {
    const initialData = { typeId: 1, time: 30 };
    const wrapper = mount(AddEditInitialSetupModal, {
      props: {
        show: true,
        isEditing: true,
        initialData: initialData,
        surgeryTypes: mockSurgeryTypes,
      },
    });

    expect(wrapper.find('.modal-overlay').exists()).toBe(true);
    expect(wrapper.text()).toContain('Edit Initial Setup Time');
    expect(wrapper.find('select#setup-type').exists()).toBe(true);
    expect(wrapper.find('select#setup-type').attributes('disabled')).toBe(''); // Check for disabled attribute presence
    expect(wrapper.find('select#setup-type').element.value).toBe(initialData.typeId.toString()); // Select value is string
    expect(wrapper.find('input#setup-time').exists()).toBe(true);
    expect(wrapper.find('input#setup-time').element.value).toBe(initialData.time.toString()); // Input value is string
    expect(wrapper.find('button[type="submit"]').text()).toBe('Save Changes');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
  });

  // Test case for submitting the form in add mode
  it('emits save event with form data when submitting in add mode', async () => {
    const wrapper = mount(AddEditInitialSetupModal, {
      props: {
        show: true,
        isEditing: false,
        surgeryTypes: mockSurgeryTypes,
      },
    });

    const typeSelect = wrapper.find('select#setup-type');
    const timeInput = wrapper.find('input#setup-time');
    const form = wrapper.find('form');

    await typeSelect.setValue(mockSurgeryTypes[0].id);
    await timeInput.setValue(45);
    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      typeId: mockSurgeryTypes[0].id,
      time: 45,
    });
  });

  // Test case for submitting the form in edit mode
  it('emits save event with updated form data when submitting in edit mode', async () => {
    const initialData = { typeId: 1, time: 30, id: 123 }; // Include an ID for editing scenario
    const wrapper = mount(AddEditInitialSetupModal, {
      props: {
        show: true,
        isEditing: true,
        initialData: initialData,
        surgeryTypes: mockSurgeryTypes,
      },
    });

    const timeInput = wrapper.find('input#setup-time');
    const form = wrapper.find('form');

    await timeInput.setValue(60);
    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      typeId: initialData.typeId,
      time: 60,
      id: initialData.id, // Ensure ID is included in edited data
    });
  });

  // Test case for emitting cancel event
  it('emits cancel event when cancel button is clicked', async () => {
    const wrapper = mount(AddEditInitialSetupModal, {
      props: {
         show: true,
         surgeryTypes: mockSurgeryTypes,
      },
    });
    await wrapper.find('button.button-secondary').trigger('click');
    expect(wrapper.emitted('cancel')).toBeTruthy();
  });

  // Test case for clicking outside the modal
   it('emits cancel event when clicking on modal overlay', async () => {
       const wrapper = mount(AddEditInitialSetupModal, {
           props: {
               show: true,
               surgeryTypes: mockSurgeryTypes,
           },
       });
       await wrapper.find('.modal-overlay').trigger('click.self');
       expect(wrapper.emitted('cancel')).toBeTruthy();
   });

  // Test case for not rendering when show is false
  it('does not render when show prop is false', () => {
    const wrapper = mount(AddEditInitialSetupModal, { props: { show: false, surgeryTypes: mockSurgeryTypes } });
    expect(wrapper.find('.modal-overlay').exists()).toBe(false);
  });

  // Snapshot test
  it('matches snapshot in add mode', () => {
    const wrapper = mount(AddEditInitialSetupModal, {
      props: {
        show: true,
        isEditing: false,
        surgeryTypes: mockSurgeryTypes,
      },
    });
    expect(wrapper.html()).toMatchSnapshot();
  });

   it('matches snapshot in edit mode', () => {
     const initialData = { typeId: 1, time: 30 };
       const wrapper = mount(AddEditInitialSetupModal, {
         props: {
           show: true,
           isEditing: true,
           initialData: initialData,
           surgeryTypes: mockSurgeryTypes,
         },
       });
       expect(wrapper.html()).toMatchSnapshot();
   });

    // Basic validation tests (can be expanded)
    it('shows alert if surgery type is not selected in add mode', async () => {
        const alertSpy = vi.spyOn(window, 'alert').mockImplementation(() => {}); // Mock alert
        const wrapper = mount(AddEditInitialSetupModal, {
            props: {
                show: true,
                isEditing: false,
                surgeryTypes: mockSurgeryTypes,
            },
        });

        const timeInput = wrapper.find('input#setup-time');
        const form = wrapper.find('form');

        await timeInput.setValue(45);
        await form.trigger('submit.prevent');

        expect(alertSpy).toHaveBeenCalledWith('Please select a Surgery Type.');
        expect(wrapper.emitted('save')).toBeUndefined(); // Ensure save was NOT emitted

        alertSpy.mockRestore(); // Restore original alert
    });

     it('shows alert if time is negative', async () => {
         const alertSpy = vi.spyOn(window, 'alert').mockImplementation(() => {}); // Mock alert
         const wrapper = mount(AddEditInitialSetupModal, {
             props: {
                 show: true,
                 isEditing: false,
                 surgeryTypes: mockSurgeryTypes,
             },
         });

         const typeSelect = wrapper.find('select#setup-type');
         const timeInput = wrapper.find('input#setup-time');
         const form = wrapper.find('form');

         await typeSelect.setValue(mockSurgeryTypes[0].id);
         await timeInput.setValue(-10);
         await form.trigger('submit.prevent');

         expect(alertSpy).toHaveBeenCalledWith('Setup time cannot be negative.');
         expect(wrapper.emitted('save')).toBeUndefined(); // Ensure save was NOT emitted

         alertSpy.mockRestore(); // Restore original alert
     });
});


================================================
FILE: src/components/__tests__/AddEditSurgeryTypeModal.test.js
================================================
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import AddEditSurgeryTypeModal from '../AddEditSurgeryTypeModal.vue';

describe('AddEditSurgeryTypeModal', () => {
  // Test case for adding a new surgery type
  it('renders correctly in add mode', () => {
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true, // Assume show prop is added and controls visibility
        isEditing: false,
      },
    });

    expect(wrapper.find('.modal-overlay').exists()).toBe(true);
    expect(wrapper.text()).toContain('Add New Surgery Type');
    expect(wrapper.find('input#type-name').exists()).toBe(true);
    expect(wrapper.find('input#type-code').exists()).toBe(true);
    expect(wrapper.find('textarea#type-description').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Add Type');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
  });

  // Test case for editing an existing surgery type
  it('renders correctly in edit mode with initial data', () => {
    const initialData = {
      id: 123,
      name: 'Existing Type',
      code: 'EXT',
      description: 'Existing Description',
    };
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true, // Assume show prop is added and controls visibility
        isEditing: true,
        initialData: initialData,
      },
    });

    expect(wrapper.find('.modal-overlay').exists()).toBe(true);
    expect(wrapper.text()).toContain('Edit Surgery Type');
    expect(wrapper.find('input#type-name').element.value).toBe(initialData.name);
    expect(wrapper.find('input#type-code').element.value).toBe(initialData.code);
    expect(wrapper.find('textarea#type-description').element.value).toBe(initialData.description);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Save Changes');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
  });

  // Test case for submitting the form in add mode
  it('emits save event with form data when submitting in add mode', async () => {
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true,
        isEditing: false,
      },
    });

    const nameInput = wrapper.find('input#type-name');
    const codeInput = wrapper.find('input#type-code');
    const descriptionInput = wrapper.find('textarea#type-description');
    const form = wrapper.find('form');

    await nameInput.setValue('New Type');
    await codeInput.setValue('NT');
    await descriptionInput.setValue('New Description');
    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: null, // ID should be null in add mode
      name: 'New Type',
      code: 'NT',
      description: 'New Description',
    });
  });

  // Test case for submitting the form in edit mode
  it('emits save event with updated form data when submitting in edit mode', async () => {
    const initialData = {
      id: 123,
      name: 'Existing Type',
      code: 'EXT',
      description: 'Existing Description',
    };
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true,
        isEditing: true,
        initialData: initialData,
      },
    });

    const nameInput = wrapper.find('input#type-name');
    // code and description are not changed in this test
    const form = wrapper.find('form');

    await nameInput.setValue('Updated Type');
    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: 123,
      name: 'Updated Type',
      code: 'EXT',
      description: 'Existing Description',
    });
  });

  // Test case for emitting cancel event from button
  it('emits cancel event when cancel button is clicked', async () => {
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true,
      },
    });
    await wrapper.find('button.button-secondary').trigger('click');
    expect(wrapper.emitted('cancel')).toBeTruthy();
  });

   // Test case for emitting cancel event from overlay click
   it('emits cancel event when clicking on modal overlay', async () => {
       const wrapper = mount(AddEditSurgeryTypeModal, {
           props: {
               show: true,
           },
       });
       await wrapper.find('.modal-overlay').trigger('click.self');
       expect(wrapper.emitted('cancel')).toBeTruthy();
   });

  // Test case for not rendering when show is false
  it('does not render when show prop is false', () => {
    const wrapper = mount(AddEditSurgeryTypeModal, { props: { show: false } });
    expect(wrapper.find('.modal-overlay').exists()).toBe(false);
  });

  // Snapshot tests
  it('matches snapshot in add mode', () => {
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true,
        isEditing: false,
      },
    });
    expect(wrapper.html()).toMatchSnapshot();
  });

  it('matches snapshot in edit mode', () => {
    const initialData = {
      id: 456,
      name: 'Another Existing Type',
      code: 'AET',
      description: 'Another Description',
    };
    const wrapper = mount(AddEditSurgeryTypeModal, {
      props: {
        show: true,
        isEditing: true,
        initialData: initialData,
      },
    });
    expect(wrapper.html()).toMatchSnapshot();
  });
});


================================================
FILE: src/components/__tests__/AddEquipmentForm.test.js
================================================
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import AddEquipmentForm from '../AddEquipmentForm.vue';

describe('AddEquipmentForm', () => {
  // Test case for rendering in add mode
  it('renders correctly in add mode', () => {
    const wrapper = mount(AddEquipmentForm, {
      props: { equipmentToEdit: null },
    });

    expect(wrapper.text()).toContain('Add New Equipment');
    expect(wrapper.find('input#equipment-name').exists()).toBe(true);
    expect(wrapper.find('input#equipment-type').exists()).toBe(true);
    expect(wrapper.find('select#equipment-status').exists()).toBe(true);
    expect(wrapper.find('input#equipment-location').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Save Equipment');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
    expect(wrapper.find('.error-message').exists()).toBe(false); // No errors initially
  });

  // Test case for rendering in edit mode with initial data
  it('renders correctly in edit mode with initial data', () => {
    const initialData = {
      id: 1,
      name: 'OR Table 1',
      type: 'Operating Table',
      status: 'Available',
      location: 'OR 1',
    };
    const wrapper = mount(AddEquipmentForm, {
      props: { equipmentToEdit: initialData },
    });

    expect(wrapper.text()).toContain('Edit Equipment');
    expect(wrapper.find('input#equipment-name').element.value).toBe(initialData.name);
    expect(wrapper.find('input#equipment-type').element.value).toBe(initialData.type);
    expect(wrapper.find('select#equipment-status').element.value).toBe(initialData.status);
    expect(wrapper.find('input#equipment-location').element.value).toBe(initialData.location);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Update Equipment');
  });

  // Test case for form input and data binding
  it('updates form data on input', async () => {
    const wrapper = mount(AddEquipmentForm);
    const nameInput = wrapper.find('input#equipment-name');
    const typeInput = wrapper.find('input#equipment-type');
    const statusSelect = wrapper.find('select#equipment-status');
    const locationInput = wrapper.find('input#equipment-location');

    await nameInput.setValue('New Ventilator');
    await typeInput.setValue('Ventilator');
    await statusSelect.setValue('In Use');
    await locationInput.setValue('OR 3');

    // Check if component's internal data reflects the input
    // This requires accessing the component instance, which is not standard Vue Test Utils practice
    // We will rely on the submit test to verify data correctness.

    // However, we can check the element values still
    expect(nameInput.element.value).toBe('New Ventilator');
    expect(typeInput.element.value).toBe('Ventilator');
    expect(statusSelect.element.value).toBe('In Use');
    expect(locationInput.element.value).toBe('OR 3');
  });

  // Test case for submitting the form in add mode
  it('emits save event with form data when submitting in add mode', async () => {
    const wrapper = mount(AddEquipmentForm);
    const nameInput = wrapper.find('input#equipment-name');
    const typeInput = wrapper.find('input#equipment-type');
    const statusSelect = wrapper.find('select#equipment-status');
    const locationInput = wrapper.find('input#equipment-location');
    const form = wrapper.find('form');

    await nameInput.setValue('New Infusion Pump');
    await typeInput.setValue('Infusion Pump');
    await statusSelect.setValue('Available');
    await locationInput.setValue('Storage');

    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: null,
      name: 'New Infusion Pump',
      type: 'Infusion Pump',
      status: 'Available',
      location: 'Storage',
    });
  });

  // Test case for submitting the form in edit mode
  it('emits save event with updated form data and isUpdate flag when submitting in edit mode', async () => {
    const initialData = {
      id: 2,
      name: 'Laser Machine',
      type: 'Laser',
      status: 'Maintenance',
      location: 'Laser Room',
    };
    const wrapper = mount(AddEquipmentForm, { props: { equipmentToEdit: initialData } });

    const nameInput = wrapper.find('input#equipment-name');
    const statusSelect = wrapper.find('select#equipment-status');
    const form = wrapper.find('form');

    await nameInput.setValue('Updated Laser Machine');
    await statusSelect.setValue('Available');

    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: 2,
      name: 'Updated Laser Machine',
      type: 'Laser', // Type should remain unchanged as per edit mode behavior logic (though not disabled in template)
      status: 'Available',
      location: 'Laser Room', // Location should remain unchanged
      isUpdate: true, // Flag should be true in edit mode
    });
  });

  // Test case for emitting cancel event
  it('emits cancel event when cancel button is clicked', async () => {
    const wrapper = mount(AddEquipmentForm);
    await wrapper.find('button.button-secondary').trigger('click');
    expect(wrapper.emitted('cancel')).toBeTruthy();
  });

  // Test case for validation - missing required fields
  it('shows validation errors for missing required fields on submit', async () => {
    const wrapper = mount(AddEquipmentForm);
    const form = wrapper.find('form');

    await form.trigger('submit.prevent');

    expect(wrapper.find('span.error-message').exists()).toBe(true); // At least one error message should be shown
    expect(wrapper.text()).toContain('Name/ID is required.');
    expect(wrapper.text()).toContain('Type is required.');
    expect(wrapper.text()).toContain('Status is required.');
    expect(wrapper.emitted('save')).toBeUndefined(); // Save should not be emitted
  });

  // Test case for clearing validation errors on input
  it('clears validation errors on input', async () => {
    const wrapper = mount(AddEquipmentForm);
    const nameInput = wrapper.find('input#equipment-name');
    const form = wrapper.find('form');

    // Submit once to show errors
    await form.trigger('submit.prevent');
    expect(wrapper.find('span.error-message').exists()).toBe(true);

    // Enter value and check if error clears
    await nameInput.setValue('Some Name');
    expect(wrapper.text()).not.toContain('Name/ID is required.');
  });

  // Test case for resetting form after successful submission (simulated)
  it('resets form after successful submission', async () => {
     const wrapper = mount(AddEquipmentForm);
     const nameInput = wrapper.find('input#equipment-name');
     const typeInput = wrapper.find('input#equipment-type');
     const statusSelect = wrapper.find('select#equipment-status');
     const form = wrapper.find('form');

     await nameInput.setValue('To Be Reset');
     await typeInput.setValue('To Be Reset Type');
     await statusSelect.setValue('Available');

     // Simulate successful save by calling handleSubmit directly after filling
     // In a real scenario, this would happen after the parent handles the emit
     // We'll test the state change directly here for simplicity.
     await wrapper.vm.handleSubmit();

     // Check if form fields are reset to initial state
     expect(nameInput.element.value).toBe('');
     expect(typeInput.element.value).toBe('');
     expect(statusSelect.element.value).toBe('');
     expect(wrapper.find('.error-message').exists()).toBe(false); // Errors should also be cleared
  });

   // Test case for resetting form on cancel
    it('resets form and clears errors on cancel', async () => {
       const wrapper = mount(AddEquipmentForm);
       const nameInput = wrapper.find('input#equipment-name');
       const typeInput = wrapper.find('input#equipment-type');
       const cancelButton = wrapper.find('button.button-secondary');
       const form = wrapper.find('form');

       // Put some data in the form and trigger validation to show errors
       await nameInput.setValue('Some Data');
       await form.trigger('submit.prevent'); // This will show errors
       expect(wrapper.find('.error-message').exists()).toBe(true);

       // Click cancel
       await cancelButton.trigger('click');

       // Check if form fields are reset and errors cleared
       expect(nameInput.element.value).toBe('');
       expect(typeInput.element.value).toBe('');
       expect(wrapper.find('.error-message').exists()).toBe(false);
       expect(wrapper.emitted('cancel')).toBeTruthy(); // Ensure cancel event was emitted
    });

    // Snapshot test in add mode
    it('matches snapshot in add mode', () => {
        const wrapper = mount(AddEquipmentForm, { props: { equipmentToEdit: null } });
        expect(wrapper.html()).toMatchSnapshot();
    });

    // Snapshot test in edit mode
     it('matches snapshot in edit mode', () => {
         const initialData = {
           id: 3,
           name: 'X-Ray Machine',
           type: 'Imaging',
           status: 'Available',
           location: 'Mobile',
         };
         const wrapper = mount(AddEquipmentForm, { props: { equipmentToEdit: initialData } });
         expect(wrapper.html()).toMatchSnapshot();
     });
});


================================================
FILE: src/components/__tests__/AddOrForm.test.js
================================================
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import AddOrForm from '../AddOrForm.vue';

describe('AddOrForm', () => {
  // Test case for rendering in add mode
  it('renders correctly in add mode', () => {
    const wrapper = mount(AddOrForm, {
      props: { orToEdit: null },
    });

    expect(wrapper.text()).toContain('Add New Operating Room');
    expect(wrapper.find('input#or-name').exists()).toBe(true);
    expect(wrapper.find('input#or-location').exists()).toBe(true);
    expect(wrapper.find('select#or-status').exists()).toBe(true);
    expect(wrapper.find('input#or-service').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Save OR');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
    expect(wrapper.find('.error-message').exists()).toBe(false); // No errors initially
  });

  // Test case for rendering in edit mode with initial data
  it('renders correctly in edit mode with initial data', () => {
    const initialData = {
      id: 1,
      name: 'OR 1',
      location: 'Floor 2',
      status: 'Active',
      primaryService: 'General Surgery',
    };
    const wrapper = mount(AddOrForm, {
      props: { orToEdit: initialData },
    });

    expect(wrapper.text()).toContain('Edit Operating Room');
    expect(wrapper.find('input#or-name').element.value).toBe(initialData.name);
    expect(wrapper.find('input#or-location').element.value).toBe(initialData.location);
    expect(wrapper.find('select#or-status').element.value).toBe(initialData.status);
    expect(wrapper.find('input#or-service').element.value).toBe(initialData.primaryService);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Update OR');
  });

  // Test case for form input and data binding
  it('updates form data on input', async () => {
    const wrapper = mount(AddOrForm);
    const nameInput = wrapper.find('input#or-name');
    const locationInput = wrapper.find('input#or-location');
    const statusSelect = wrapper.find('select#or-status');
    const serviceInput = wrapper.find('input#or-service');

    await nameInput.setValue('OR 5');
    await locationInput.setValue('Floor 3');
    await statusSelect.setValue('Under Maintenance');
    await serviceInput.setValue('Orthopedics');

    // Check the element values still
    expect(nameInput.element.value).toBe('OR 5');
    expect(locationInput.element.value).toBe('Floor 3');
    expect(statusSelect.element.value).toBe('Under Maintenance');
    expect(serviceInput.element.value).toBe('Orthopedics');
  });

  // Test case for submitting the form in add mode
  it('emits save event with form data and generated id when submitting in add mode', async () => {
    const wrapper = mount(AddOrForm);
    const nameInput = wrapper.find('input#or-name');
    const locationInput = wrapper.find('input#or-location');
    const statusSelect = wrapper.find('select#or-status');
    const serviceInput = wrapper.find('input#or-service');
    const form = wrapper.find('form');

    await nameInput.setValue('OR 6');
    await locationInput.setValue('Basement');
    await statusSelect.setValue('Active');
    await serviceInput.setValue('Cardiology');

    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    const emittedData = wrapper.emitted('save')[0][0];
    expect(emittedData).toMatchObject({
      name: 'OR 6',
      location: 'Basement',
      status: 'Active',
      primaryService: 'Cardiology',
    });
    expect(emittedData.id).toBeTypeOf('string'); // Check if an ID string is generated
  });

  // Test case for submitting the form in edit mode
  it('emits save event with updated form data and isUpdate flag when submitting in edit mode', async () => {
    const initialData = {
      id: 2,
      name: 'OR 2',
      location: 'Floor 1',
      status: 'Active',
      primaryService: 'Neurosurgery',
    };
    const wrapper = mount(AddOrForm, { props: { orToEdit: initialData } });

    const nameInput = wrapper.find('input#or-name');
    const statusSelect = wrapper.find('select#or-status');
    const form = wrapper.find('form');

    await nameInput.setValue('OR 2 Updated');
    await statusSelect.setValue('Inactive');

    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: 2,
      name: 'OR 2 Updated',
      location: 'Floor 1',
      status: 'Inactive',
      primaryService: 'Neurosurgery',
      isUpdate: true,
    });
  });

  // Test case for emitting cancel event
  it('emits cancel event when cancel button is clicked', async () => {
    const wrapper = mount(AddOrForm);
    await wrapper.find('button.button-secondary').trigger('click');
    expect(wrapper.emitted('cancel')).toBeTruthy();
  });

  // Test case for validation - missing required fields
  it('shows validation errors for missing required fields on submit', async () => {
    const wrapper = mount(AddOrForm);
    const form = wrapper.find('form');

    await form.trigger('submit.prevent');

    expect(wrapper.find('span.error-message').exists()).toBe(true); // At least one error message should be shown
    expect(wrapper.text()).toContain('Name/ID is required.');
    expect(wrapper.text()).toContain('Status is required.');
    expect(wrapper.emitted('save')).toBeUndefined(); // Save should not be emitted
  });

  // Test case for clearing validation errors on input
  it('clears validation errors on input', async () => {
    const wrapper = mount(AddOrForm);
    const nameInput = wrapper.find('input#or-name');
    const form = wrapper.find('form');

    // Submit once to show errors
    await form.trigger('submit.prevent');
    expect(wrapper.find('span.error-message').exists()).toBe(true);

    // Enter value and check if error clears
    await nameInput.setValue('Some OR Name');
    expect(wrapper.text()).not.toContain('Name/ID is required.');

     // Also check for status error clearing
     const statusSelect = wrapper.find('select#or-status');
     await statusSelect.setValue('Active');
     expect(wrapper.text()).not.toContain('Status is required.');
  });

  // Test case for resetting form after successful submission (simulated)
  it('emits save event and does not reset form itself on successful submission', async () => {
     const wrapper = mount(AddOrForm);
     const nameInput = wrapper.find('input#or-name');
     const statusSelect = wrapper.find('select#or-status');
     // const form = wrapper.find('form'); // Not needed if directly calling handleSubmit

     await nameInput.setValue('To Be Reset OR');
     await statusSelect.setValue('Active');

     // Simulate successful save by calling handleSubmit directly after filling
     await wrapper.vm.handleSubmit();

     // Check that the save event was emitted
     expect(wrapper.emitted('save')).toBeTruthy();
     const emittedData = wrapper.emitted('save')[0][0];
    expect(emittedData).toMatchObject({
      name: 'To Be Reset OR',
      status: 'Active',
    });

     // Check that form fields are NOT reset by the component itself
     expect(nameInput.element.value).toBe('To Be Reset OR');
     expect(statusSelect.element.value).toBe('Active');
     expect(wrapper.find('.error-message').exists()).toBe(false); // Errors should be cleared if submission was valid
  });

   // Test case for resetting form and clearing errors on cancel
    it('resets form and clears errors on cancel', async () => {
       const wrapper = mount(AddOrForm);
       const nameInput = wrapper.find('input#or-name');
       const form = wrapper.find('form');

       // Put some data in the form and trigger validation to show errors
       await nameInput.setValue('Some OR Data');
       await form.trigger('submit.prevent'); // This will show errors
       expect(wrapper.find('.error-message').exists()).toBe(true);

       // Click cancel
       await wrapper.find('button.button-secondary').trigger('click');

       // Check if form fields are reset and errors cleared
       expect(nameInput.element.value).toBe('');
       expect(wrapper.find('.error-message').exists()).toBe(false);
       expect(wrapper.emitted('cancel')).toBeTruthy(); // Ensure cancel event was emitted
    });

    // Snapshot test in add mode
    it('matches snapshot in add mode', () => {
        const wrapper = mount(AddOrForm, { props: { orToEdit: null } });
        expect(wrapper.html()).toMatchSnapshot();
    });

    // Snapshot test in edit mode
     it('matches snapshot in edit mode', () => {
         const initialData = {
           id: 3,
           name: 'OR 3',
           location: 'Floor 4',
           status: 'Inactive',
           primaryService: 'Pediatrics',
         };
         const wrapper = mount(AddOrForm, { props: { orToEdit: initialData } });
         expect(wrapper.html()).toMatchSnapshot();
     });
});


================================================
FILE: src/components/__tests__/AddStaffForm.test.js
================================================
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import AddStaffForm from '../AddStaffForm.vue';

describe('AddStaffForm', () => {
  // Test case for rendering in add mode
  it('renders correctly in add mode', () => {
    const wrapper = mount(AddStaffForm, {
      props: { staffToEdit: null },
    });

    expect(wrapper.text()).toContain('Add New Staff Member');
    expect(wrapper.find('input#staff-name').exists()).toBe(true);
    expect(wrapper.find('select#staff-role').exists()).toBe(true);
    expect(wrapper.find('input#staff-specializations').exists()).toBe(true);
    expect(wrapper.find('select#staff-status').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Save Staff');
    expect(wrapper.find('button[type="button"]').text()).toBe('Cancel');
    expect(wrapper.find('.error-message').exists()).toBe(false); // No errors initially
  });

  // Test case for rendering in edit mode with initial data
  it('renders correctly in edit mode with initial data', () => {
    const initialData = {
      id: 1,
      name: 'Dr. Smith',
      role: 'Surgeon',
      specializations: ['Orthopedics', 'Sports Medicine'],
      status: 'Active',
    };
    const wrapper = mount(AddStaffForm, {
      props: { staffToEdit: initialData },
    });

    expect(wrapper.text()).toContain('Edit Staff Member');
    expect(wrapper.find('input#staff-name').element.value).toBe(initialData.name);
    expect(wrapper.find('select#staff-role').element.value).toBe(initialData.role);
    expect(wrapper.find('input#staff-specializations').element.value).toBe('Orthopedics, Sports Medicine');
    expect(wrapper.find('select#staff-status').element.value).toBe(initialData.status);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Update Staff');
  });

  // Test case for form input and data binding
  it('updates form data on input', async () => {
    const wrapper = mount(AddStaffForm);
    const nameInput = wrapper.find('input#staff-name');
    const roleSelect = wrapper.find('select#staff-role');
    const specializationsInput = wrapper.find('input#staff-specializations');
    const statusSelect = wrapper.find('select#staff-status');

    await nameInput.setValue('Dr. Johnson');
    await roleSelect.setValue('Anesthetist');
    await specializationsInput.setValue('Pediatric, General');
    await statusSelect.setValue('Active');

    // Check the element values
    expect(nameInput.element.value).toBe('Dr. Johnson');
    expect(roleSelect.element.value).toBe('Anesthetist');
    expect(specializationsInput.element.value).toBe('Pediatric, General');
    expect(statusSelect.element.value).toBe('Active');
  });

  // Test case for submitting the form in add mode
  it('emits save event with form data when submitting in add mode', async () => {
    const wrapper = mount(AddStaffForm);
    const nameInput = wrapper.find('input#staff-name');
    const roleSelect = wrapper.find('select#staff-role');
    const specializationsInput = wrapper.find('input#staff-specializations');
    const statusSelect = wrapper.find('select#staff-status');
    const form = wrapper.find('form');

    await nameInput.setValue('Dr. Williams');
    await roleSelect.setValue('Surgeon');
    await specializationsInput.setValue('Cardiology, Vascular');
    await statusSelect.setValue('Active');

    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: null,
      name: 'Dr. Williams',
      role: 'Surgeon',
      specializations: ['Cardiology', 'Vascular'],
      status: 'Active',
    });
  });

  // Test case for submitting the form in edit mode
  it('emits save event with updated form data and isUpdate flag when submitting in edit mode', async () => {
    const initialData = {
      id: 2,
      name: 'Dr. Brown',
      role: 'Nurse',
      specializations: ['ICU'],
      status: 'On Leave',
    };
    const wrapper = mount(AddStaffForm, { props: { staffToEdit: initialData } });

    const nameInput = wrapper.find('input#staff-name');
    const statusSelect = wrapper.find('select#staff-status');
    const form = wrapper.find('form');

    await nameInput.setValue('Dr. Brown Updated');
    await statusSelect.setValue('Active');

    await form.trigger('submit.prevent');

    expect(wrapper.emitted('save')).toBeTruthy();
    expect(wrapper.emitted('save')[0][0]).toEqual({
      id: 2,
      name: 'Dr. Brown Updated',
      role: 'Nurse',
      specializations: ['ICU'],
      status: 'Active',
      isUpdate: true,
    });
  });

  // Test case for emitting cancel event
  it('emits cancel event when cancel button is clicked', async () => {
    const wrapper = mount(AddStaffForm);
    await wrapper.find('button.button-secondary').trigger('click');
    expect(wrapper.emitted('cancel')).toBeTruthy();
  });

  // Test case for validation - missing required fields
  it('shows validation errors for missing required fields on submit', async () => {
    const wrapper = mount(AddStaffForm);
    const form = wrapper.find('form');

    await form.trigger('submit.prevent');

    expect(wrapper.find('span.error-message').exists()).toBe(true); // At least one error message should be shown
    expect(wrapper.text()).toContain('Name is required.');
    expect(wrapper.text()).toContain('Role is required.');
    expect(wrapper.text()).toContain('Status is required.');
    expect(wrapper.emitted('save')).toBeUndefined(); // Save should not be emitted
  });

  // Test case for clearing validation errors on input
  it('clears validation errors on input', async () => {
    const wrapper = mount(AddStaffForm);
    const nameInput = wrapper.find('input#staff-name');
    const form = wrapper.find('form');

    // Submit once to show errors
    await form.trigger('submit.prevent');
    expect(wrapper.find('span.error-message').exists()).toBe(true);

    // Enter value and check if error clears
    await nameInput.setValue('Dr. Test');
    expect(wrapper.text()).not.toContain('Name is required.');

    // Also check for role error clearing
    const roleSelect = wrapper.find('select#staff-role');
    await roleSelect.setValue('Surgeon');
    expect(wrapper.text()).not.toContain('Role is required.');
  });

  // Test case for resetting form after successful submission
  it('resets form after successful submission', async () => {
    const wrapper = mount(AddStaffForm);
    const nameInput = wrapper.find('input#staff-name');
    const roleSelect = wrapper.find('select#staff-role');
    const statusSelect = wrapper.find('select#staff-status');

    await nameInput.setValue('To Be Reset');
    await roleSelect.setValue('Surgeon');
    await statusSelect.setValue('Active');

    // Simulate successful save by calling handleSubmit directly
    await wrapper.vm.handleSubmit();

    // Check if form fields are reset to initial state
    expect(nameInput.element.value).toBe('');
    expect(roleSelect.element.value).toBe('');
    expect(statusSelect.element.value).toBe('');
    expect(wrapper.find('.error-message').exists()).toBe(false); // Errors should also be cleared
  });

  // Test case for resetting form and clearing errors on cancel
  it('resets form and clears errors on cancel', async () => {
    const wrapper = mount(AddStaffForm);
    const nameInput = wrapper.find('input#staff-name');
    const form = wrapper.find('form');

    // Put some data in the form and trigger validation to show errors
    await nameInput.setValue('Some Staff Data');
    await form.trigger('submit.prevent'); // This will show errors
    expect(wrapper.find('.error-message').exists()).toBe(true);

    // Click cancel
    await wrapper.find('button.button-secondary').trigger('click');

    // Check if form fields are reset and errors cleared
    expect(nameInput.element.value).toBe('');
    expect(wrapper.find('.error-message').exists()).toBe(false);
    expect(wrapper.emitted('cancel')).toBeTruthy(); // Ensure cancel event was emitted
  });

  // Test case for specializations string to array conversion
  it('converts specializations string to array correctly', async () => {
    const wrapper = mount(AddStaffForm);
    const specializationsInput = wrapper.find('input#staff-specializations');

    await specializationsInput.setValue('Cardiology, Neurology, Pediatrics');

    // Trigger form submission to check the emitted data
    const nameInput = wrapper.find('input#staff-name');
    const roleSelect = wrapper.find('select#staff-role');
    const statusSelect = wrapper.find('select#staff-status');

    await nameInput.setValue('Dr. Specialist');
    await roleSelect.setValue('Surgeon');
    await statusSelect.setValue('Active');

    await wrapper.find('form').trigger('submit.prevent');

    const emittedData = wrapper.emitted('save')[0][0];
    expect(emittedData.specializations).toEqual(['Cardiology', 'Neurology', 'Pediatrics']);
  });

  // Snapshot test in add mode
  it('matches snapshot in add mode', () => {
    const wrapper = mount(AddStaffForm);
    expect(wrapper.html()).toMatchSnapshot();
  });

  // Snapshot test in edit mode
  it('matches snapshot in edit mode', () => {
    const initialData = {
      id: 3,
      name: 'Dr. Snapshot',
      role: 'Surgeon',
      specializations: ['General'],
      status: 'Active',
    };
    const wrapper = mount(AddStaffForm, { props: { staffToEdit: initialData } });
    expect(wrapper.html()).toMatchSnapshot();
  });
});


================================================
FILE: src/components/__tests__/AdministrationScreen.test.js
================================================
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mount } from '@vue/test-utils';
import AdministrationScreen from '../AdministrationScreen.vue';

describe('AdministrationScreen', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(AdministrationScreen);
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  // Basic rendering test
  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.find('.section-container').exists()).toBe(true);
    expect(wrapper.find('.admin-sections').exists()).toBe(true);
  });

  // Test if the main heading is rendered
  it('renders the main heading', () => {
    expect(wrapper.find('h1').exists()).toBe(true);
    expect(wrapper.find('h1').text()).toBe('Administration');
  });

  // Test if the placeholder text is rendered
  it('renders the placeholder text', () => {
    expect(wrapper.find('p').exists()).toBe(true);
    expect(wrapper.find('p').text()).toBe('Admin sections placeholder:');
  });

  // Test if the placeholder buttons are rendered
  it('renders the placeholder buttons', () => {
    const buttons = wrapper.findAll('button');
    expect(buttons.length).toBe(3);
    expect(buttons[0].text()).toBe('User Management');
    expect(buttons[1].text()).toBe('Role Management');
    expect(buttons[2].text()).toBe('System Settings');
  });

  // Test button interactions (even though they don't do anything yet)
  it('buttons are clickable', async () => {
    const buttons = wrapper.findAll('button');

    // Test that buttons can be clicked without errors
    for (const button of buttons) {
      await button.trigger('click');
      // Since buttons don't have functionality yet, just verify no errors occur
      expect(button.exists()).toBe(true);
    }
  });

  // Test component structure
  it('has correct CSS classes', () => {
    expect(wrapper.classes()).toContain('section-container');
    expect(wrapper.find('.admin-sections').exists()).toBe(true);
  });

  // Test that component is a placeholder (future-proofing)
  it('is currently a placeholder component', () => {
    expect(wrapper.text()).toContain('placeholder');
    // Verify no complex functionality exists yet
    expect(wrapper.findAll('form')).toHaveLength(0);
    expect(wrapper.findAll('table')).toHaveLength(0);
    expect(wrapper.findAll('input')).toHaveLength(0);
  });

  // Test accessibility basics
  it('has proper heading hierarchy', () => {
    const headings = wrapper.findAll('h1, h2, h3, h4, h5, h6');
    expect(headings.length).toBe(1);
    expect(headings[0].element.tagName).toBe('H1');
  });

  // Test component snapshot
  it('matches snapshot', () => {
    expect(wrapper.html()).toMatchSnapshot();
  });
});


================================================
FILE: src/components/__tests__/AnalyticsDashboard.test.js
================================================
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import AnalyticsDashboard from '../AnalyticsDashboard.vue';
import { createPinia, storeToRefs } from 'pinia';
import { useRouter } from 'vue-router';
import { useAnalyticsStore } from '@/stores/analyticsStore';
import { ref, reactive } from 'vue';

// Mock the router
vi.mock('vue-router', () => ({
  useRouter: vi.fn(() => ({
    push: vi.fn(),
  })),
}));

// Mock the analytics store
vi.mock('@/stores/analyticsStore', () => ({
  useAnalyticsStore: vi.fn(() => ({
    // Make properties reactive
    isLoading: ref(false),
    error: ref(null),
    dateRange: reactive({ start: new Date(), end: new Date() }),
    cachedData: reactive({}),
    // Keep methods as vi.fn()
    loadAnalyticsData: vi.fn(),
    setDateRange: vi.fn(),
  })),
}));

describe('AnalyticsDashboard', () => {
  let wrapper;
  let analyticsStore;
  let router;

  beforeEach(() => {
    const pinia = createPinia();
    analyticsStore = useAnalyticsStore();
    router = useRouter();

    wrapper = mount(AnalyticsDashboard, {
      global: {
        plugins: [pinia],
        mocks: {
          $router: router,
          $route: {},
        },
      },
    });
  });

  // Basic rendering test
  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true);
  });

  // Test if the main heading is rendered
  it('renders the main heading', () => {
    expect(wrapper.find('h1').exists()).toBe(true);
    expect(wrapper.find('h1').text()).toBe('Analytics Dashboard');
  });

  // Test if the date range selector section is rendered
  it('renders the date range selector section', () => {
    expect(wrapper.find('.date-range-selector').exists()).toBe(true);
    expect(wrapper.find('.date-range-selector h3').text()).toBe('Date Range');
  });

  // Test if date inputs and apply button are rendered
  it('renders date inputs and apply button', () => {
    expect(wrapper.find('#start-date').exists()).toBe(true);
    expect(wrapper.find('#end-date').exists()).toBe(true);
    expect(wrapper.find('.apply-button').exists()).toBe(true);
    expect(wrapper.find('.apply-button').text()).toBe('Apply');
  });

  // Test if quick range buttons are rendered
  it('renders quick range buttons', () => {
    const buttons = wrapper.findAll('.quick-ranges button');
    expect(buttons.length).toBe(4);
    expect(buttons[0].text()).toBe('Last 7 Days');
    expect(buttons[1].text()).toBe('Last 30 Days');
    expect(buttons[2].text()).toBe('This Month');
    expect(buttons[3].text()).toBe('Last Month');
  });

  // Test if summary metrics section is rendered (when not loading or error)
  it('renders summary metrics section when data is loaded', async () => {
    // Ensure loading and error are false in the mock
    analyticsStore.isLoading.value = false;
    analyticsStore.error.value = null;
    await wrapper.vm.$nextTick(); // Wait for DOM update
    expect(wrapper.find('.summary-metrics').exists()).toBe(true);
  });

  // Test if chart sections are rendered (when not loading or error)
  it('renders chart sections when data is loaded', async () => {
    // Ensure loading and error are false in the mock
    analyticsStore.isLoading.value = false;
    analyticsStore.error.value = null;
    await wrapper.vm.$nextTick(); // Wait for DOM update
    const chartContainers = wrapper.findAll('.chart-container');
    expect(chartContainers.length).toBe(4);
    expect(chartContainers[0].find('h3').text()).toBe('Daily Surgery Volume');
    expect(chartContainers[1].find('h3').text()).toBe('OR Utilization by Room');
    expect(chartContainers[2].find('h3').text()).toBe('Surgery Type Distribution');
    expect(chartContainers[3].find('h3').text()).toBe('Surgeon Performance');
  });

  // Test if report links section is rendered (when not loading or error)
  it('renders report links section when data is loaded', async () => {
    // Ensure loading and error are false in the mock
    analyticsStore.isLoading.value = false;
    analyticsStore.error.value = null;
    await wrapper.vm.$nextTick(); // Wait for DOM update
    expect(wrapper.find('.report-links').exists()).toBe(true);
    expect(wrapper.find('.report-links h3').text()).toBe('Detailed Reports');
  });

  // Test if loading indicator is shown when isLoading is true
  it('shows loading indicator when isLoading is true', async () => {
    analyticsStore.isLoading.value = true;
    analyticsStore.error.value = null;
    // await wrapper.vm.$nextTick(); // Wait for DOM update
    expect(await wrapper.find('.loading-overlay').exists()).toBe(true);
    expect(wrapper.find('.dashboard-content').exists()).toBe(false);
    expect(wrapper.find('.error-message').exists()).toBe(false);
  });

  // Test if error message is shown when error is not null
  it('shows error message when error is not null', async () => {
    analyticsStore.isLoading.value = false;
    analyticsStore.error.value = 'Failed to load data';
    // await wrapper.vm.$nextTick(); // Wait for DOM update
    expect(await wrapper.find('.error-message').exists()).toBe(true);
    expect(wrapper.find('.error-message p').text()).toBe('Failed to load data');
    expect(wrapper.find('.dashboard-content').exists()).toBe(false);
    expect(wrapper.find('.loading-overlay').exists()).toBe(false);
  });

  // Add more tests here based on component functionality (props, data, events, methods, etc.)

  // Test user interaction with date inputs and apply button
  it('updates date range and loads data when apply button is clicked', async () => {
    const startDateInput = wrapper.find('#start-date');
    const endDateInput = wrapper.find('#end-date');
    const applyButton = wrapper.find('.apply-button');

    // Simulate user input
    await startDateInput.setValue('2023-01-01');
    await endDateInput.setValue('2023-01-31');

    // Click the apply button
    await applyButton.trigger('click');

    // Check if setDateRange was called with the correct dates
    expect(analyticsStore.setDateRange).toHaveBeenCalledWith({
      start: new Date('2023-01-01'),
      end: new Date('2023-01-31'),
    });

    // Check if loadAnalyticsData was called
    expect(analyticsStore.loadAnalyticsData).toHaveBeenCalled();
  });

  // Test user interaction with quick range buttons
  it('updates date range and loads data when a quick range button is clicked', async () => {
    const quickRangeButtons = wrapper.findAll('.quick-ranges button');
    const last7DaysButton = quickRangeButtons[0];

    // Click the 'Last 7 Days' button
    await last7DaysButton.trigger('click');

    // Check if setDateRange was called (the exact dates will depend on the current date, so we just check if it was called)
    expect(analyticsStore.setDateRange).toHaveBeenCalled();

    // Check if loadAnalyticsData was called
    expect(analyticsStore.loadAnalyticsData).toHaveBeenCalled();
  });
});


================================================
FILE: src/components/__tests__/AppLayout.test.js
================================================
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { createRouter, createMemoryHistory } from 'vue-router';
import { createPinia, setActivePinia } from 'pinia';
import { ref } from 'vue';
import AppLayout from '../AppLayout.vue';

// Mock the auth store
const mockUser = ref({ id: 1, name: 'Test User', username: 'test@example.com' });
vi.mock('@/stores/authStore', () => ({
  useAuthStore: () => ({
    isAuthenticated: ref(true),
    user: mockUser,
    isLoading: ref(false),
    error: ref(null),
    logout: vi.fn()
  })
}));

// Mock vue-toastification
vi.mock('vue-toastification', () => ({
  useToast: () => ({
    success: vi.fn(),
    error: vi.fn(),
    info: vi.fn(),
    warning: vi.fn()
  })
}));

describe('AppLayout', () => {
  let wrapper;
  let router;
  let pinia;

  beforeEach(async () => {
    // Create a fresh Pinia instance for each test
    pinia = createPinia();
    setActivePinia(pinia);

    // Create a router instance
    router = createRouter({
      history: createMemoryHistory(),
      routes: [
        { path: '/', name: 'Dashboard', component: { template: '<div>Dashboard</div>' } },
        { path: '/login', name: 'Login', component: { template: '<div>Login</div>' } }
      ]
    });

    wrapper = mount(AppLayout, {
      global: {
        plugins: [router, pinia],
        stubs: {
          'router-link': true,
          'router-view': true
        }
      }
    });

    await router.isReady();
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.find('.app-layout').exists()).toBe(true);
  });

  it('renders the top navigation bar', () => {
    expect(wrapper.find('.top-nav-bar').exists()).toBe(true);
    expect(wrapper.find('.app-brand').exists()).toBe(true);
    expect(wrapper.find('.global-search').exists()).toBe(true);
    expect(wrapper.find('.user-utilities').exists()).toBe(true);
  });

  it('renders the left sidebar', () => {
    expect(wrapper.find('.left-sidebar').exists()).toBe(true);
    expect(wrapper.find('.left-sidebar nav').exists()).toBe(true);
  });

  it('renders the main content area', () => {
    expect(wrapper.find('.main-content').exists()).toBe(true);
    expect(wrapper.find('router-view-stub').exists()).toBe(true);
  });

  it('toggles sidebar when toggle button is clicked', async () => {
    const toggleButton = wrapper.find('.toggle-sidebar-button');
    expect(toggleButton.exists()).toBe(true);

    // Initially not collapsed
    expect(wrapper.find('.app-layout.sidebar-collapsed').exists()).toBe(false);

    // Click toggle button
    await toggleButton.trigger('click');
    await wrapper.vm.$nextTick();

    // Should be collapsed now
    expect(wrapper.find('.app-layout.sidebar-collapsed').exists()).toBe(true);

    // Click again to uncollapse
    await toggleButton.trigger('click');
    await wrapper.vm.$nextTick();

    // Should not be collapsed
    expect(wrapper.find('.app-layout.sidebar-collapsed').exists()).toBe(false);
  });

  it('handles search input', async () => {
    const searchInput = wrapper.find('.global-search input[type="text"]');
    expect(searchInput.exists()).toBe(true);

    await searchInput.setValue('test search');
    expect(searchInput.element.value).toBe('test search');
  });

  it('displays user information', () => {
    const userProfile = wrapper.find('.user-profile');
    expect(userProfile.exists()).toBe(true);
    // The component should display either the username or fallback to 'User Name'
    const userText = userProfile.text();
    expect(userText).toMatch(/test@example\.com|User Name/);
  });

  it('calls logout when logout button is clicked', async () => {
    const logoutButton = wrapper.find('.logout-button');
    expect(logoutButton.exists()).toBe(true);

    await logoutButton.trigger('click');

    // The logout function should have been called
    // Note: We can't easily test the actual store call due to mocking,
    // but we can verify the button exists and is clickable
    expect(logoutButton.exists()).toBe(true);
  });
});


================================================
FILE: src/components/__tests__/BulkSDSTEditor.test.js
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { createPinia, setActivePinia } from 'pinia';
import { ref } from 'vue';
import BulkSDSTEditor from '../BulkSDSTEditor.vue';

// Mock the schedule store
const mockSurgeryTypes = {
  'CABG': { name: 'Coronary Artery Bypass Graft', duration: 240 },
  'KNEE': { name: 'Knee Replacement', duration: 120 },
  'APPEN': { name: 'Appendectomy', duration: 60 }
};

const mockSdsRules = {
  'CABG': { 'KNEE': 45, 'APPEN': 30 },
  'KNEE': { 'CABG': 60, 'APPEN': 15 },
  'APPEN': { 'CABG': 50, 'KNEE': 20 }
};

vi.mock('@/stores/scheduleStore', () => ({
  useScheduleStore: () => ({
    surgeryTypes: mockSurgeryTypes,
    sdsRules: mockSdsRules,
    updateSDSTValue: vi.fn()
  })
}));

describe('BulkSDSTEditor', () => {
  let wrapper;
  let pinia;

  beforeEach(async () => {
    // Create a fresh Pinia instance for each test
    pinia = createPinia();
    setActivePinia(pinia);

    wrapper = mount(BulkSDSTEditor, {
      props: {
        show: true
      },
      global: {
        plugins: [pinia]
      }
    });
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders correctly when show prop is true', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.find('.modal-overlay').exists()).toBe(true);
    expect(wrapper.find('.bulk-edit-modal').exists()).toBe(true);
  });

  it('does not render when show prop is false', () => {
    wrapper = mount(BulkSDSTEditor, {
      props: {
        show: false
      },
      global: {
        plugins: [pinia]
      }
    });

    expect(wrapper.find('.modal-overlay').exists()).toBe(false);
  });

  it('renders the modal title', () => {
    expect(wrapper.find('#bulk-edit-title').text()).toBe('Bulk Edit SDST Values');
  });

  it('renders tab buttons', () => {
    const tabButtons = wrapper.findAll('.tab-button');
    expect(tabButtons.length).toBe(2);
    expect(tabButtons[0].text()).toBe('Pattern-based Editing');
    expect(tabButtons[1].text()).toBe('CSV Import/Export');
  });

  it('switches tabs when tab buttons are clicked', async () => {
    // Initially on pattern tab
    expect(wrapper.find('.tab-button.active').text()).toBe('Pattern-based Editing');

    // Click CSV tab
    const csvTab = wrapper.findAll('.tab-button')[1];
    await csvTab.trigger('click');

    expect(wrapper.find('.tab-button.active').text()).toBe('CSV Import/Export');
  });

  it('renders pattern-based editing form by default', () => {
    expect(wrapper.find('[id="pattern-type"]').exists()).toBe(true);
    expect(wrapper.find('[id="fixed-value"]').exists()).toBe(true);
    expect(wrapper.text()).toContain('Apply to:');
  });

  it('renders CSV import/export tab content', async () => {
    // Switch to CSV tab
    const csvTab = wrapper.findAll('.tab-button')[1];
    await csvTab.trigger('click');

    expect(wrapper.text()).toContain('Import or export SDST values as CSV');
    expect(wrapper.text()).toContain('Export as CSV');
    expect(wrapper.text()).toContain('Import from CSV');
    expect(wrapper.text()).toContain('CSV Format');
  });

  it('shows different input fields based on pattern type', async () => {
    const patternSelect = wrapper.find('#pattern-type');

    // Test fixed value (default)
    expect(wrapper.find('#fixed-value').exists()).toBe(true);
    expect(wrapper.find('#percentage-value').exists()).toBe(false);
    expect(wrapper.find('#increment-value').exists()).toBe(false);

    // Test percentage
    await patternSelect.setValue('percentage');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('#fixed-value').exists()).toBe(false);
    expect(wrapper.find('#percentage-value').exists()).toBe(true);
    expect(wrapper.find('#increment-value').exists()).toBe(false);

    // Test increment
    await patternSelect.setValue('increment');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('#fixed-value').exists()).toBe(false);
    expect(wrapper.find('#percentage-value').exists()).toBe(false);
    expect(wrapper.find('#increment-value').exists()).toBe(true);
  });

  it('handles apply to all checkbox correctly', async () => {
    const applyToAllCheckbox = wrapper.find('input[type="checkbox"]');

    // Initially checked (apply to all)
    expect(applyToAllCheckbox.element.checked).toBe(true);

    // Individual category checkboxes should not be visible
    expect(wrapper.text()).not.toContain('Low values (≤ 15 min)');

    // Uncheck apply to all
    await applyToAllCheckbox.setChecked(false);
    await wrapper.vm.$nextTick();

    // Individual category checkboxes should now be visible
    expect(wrapper.text()).toContain('Low values (≤ 15 min)');
    expect(wrapper.text()).toContain('Medium values (16-30 min)');
    expect(wrapper.text()).toContain('High values (> 30 min)');
  });

  it('shows preview section when pattern tab is active and has selection', () => {
    // Should show preview by default (apply to all is checked)
    expect(wrapper.find('.preview-section').exists()).toBe(true);
    expect(wrapper.text()).toContain('Preview of Changes');
    expect(wrapper.text()).toContain('values will be affected');
  });

  it('emits close event when cancel button is clicked', async () => {
    const cancelButton = wrapper.findAll('button').find(btn => btn.text() === 'Cancel');
    await cancelButton.trigger('click');

    expect(wrapper.emitted('close')).toBeTruthy();
  });

  it('has apply button disabled when no selection is made', async () => {
    // Uncheck apply to all
    const applyToAllCheckbox = wrapper.find('input[type="checkbox"]');
    await applyToAllCheckbox.setChecked(false);
    await wrapper.vm.$nextTick();

    const applyButton = wrapper.findAll('button').find(btn => btn.text() === 'Apply Changes');
    expect(applyButton.attributes('disabled')).toBeDefined();
  });

  it('updates input values correctly', async () => {
    // Test fixed value input
    const fixedValueInput = wrapper.find('#fixed-value');
    await fixedValueInput.setValue('45');
    expect(fixedValueInput.element.value).toBe('45');

    // Switch to percentage and test
    const patternSelect = wrapper.find('#pattern-type');
    await patternSelect.setValue('percentage');
    await wrapper.vm.$nextTick();

    const percentageInput = wrapper.find('#percentage-value');
    await percentageInput.setValue('25');
    expect(percentageInput.element.value).toBe('25');

    // Switch to increment and test
    await patternSelect.setValue('increment');
    await wrapper.vm.$nextTick();

    const incrementInput = wrapper.find('#increment-value');
    await incrementInput.setValue('10');
    expect(incrementInput.element.value).toBe('10');
  });

  it('shows correct preview text for different pattern types', async () => {
    const patternSelect = wrapper.find('#pattern-type');
    const fixedValueInput = wrapper.find('#fixed-value');

    // Test fixed value preview
    await fixedValueInput.setValue('45');
    await wrapper.vm.$nextTick();
    expect(wrapper.text()).toContain('Set selected SDST values to 45 minutes');

    // Test percentage increase preview
    await patternSelect.setValue('percentage');
    await wrapper.vm.$nextTick();
    const percentageInput = wrapper.find('#percentage-value');
    await percentageInput.setValue('20');
    await wrapper.vm.$nextTick();
    expect(wrapper.text()).toContain('Increase selected SDST values by 20%');

    // Test percentage decrease preview
    const percentageDirectionSelect = wrapper.findAll('select').find(select =>
      select.element.innerHTML.includes('Increase by')
    );
    await percentageDirectionSelect.setValue('decrease');
    await wrapper.vm.$nextTick();
    expect(wrapper.text()).toContain('Decrease selected SDST values by 20%');

    // Test increment preview
    await patternSelect.setValue('increment');
    await wrapper.vm.$nextTick();
    const incrementInput = wrapper.find('#increment-value');
    await incrementInput.setValue('15');
    await wrapper.vm.$nextTick();
    expect(wrapper.text()).toContain('Increase selected SDST values by 15 minutes');
  });

  it('handles individual category checkboxes correctly', async () => {
    // Uncheck apply to all first
    const applyToAllCheckbox = wrapper.find('input[type="checkbox"]');
    await applyToAllCheckbox.setChecked(false);
    await wrapper.vm.$nextTick();

    // Find and check individual category checkboxes
    const checkboxes = wrapper.findAll('input[type="checkbox"]');
    const lowCheckbox = checkboxes.find(cb =>
      cb.element.parentElement.textContent.includes('Low values')
    );
    const mediumCheckbox = checkboxes.find(cb =>
      cb.element.parentElement.textContent.includes('Medium values')
    );

    expect(lowCheckbox.exists()).toBe(true);
    expect(mediumCheckbox.exists()).toBe(true);

    // Check low values checkbox
    await lowCheckbox.setChecked(true);
    await wrapper.vm.$nextTick();

    // Apply button should now be enabled
    const applyButton = wrapper.findAll('button').find(btn => btn.text() === 'Apply Changes');
    expect(applyButton.attributes('disabled')).toBeUndefined();
  });

  it('emits update and close events when apply changes is clicked', async () => {
    const applyButton = wrapper.findAll('button').find(btn => btn.text() === 'Apply Changes');
    await applyButton.trigger('click');

    expect(wrapper.emitted('update')).toBeTruthy();
    expect(wrapper.emitted('close')).toBeTruthy();
  });

  it('triggers file input when import button is clicked', async () => {
    // Switch to CSV tab
    const csvTab = wrapper.findAll('.tab-button')[1];
    await csvTab.trigger('click');

    // Mock the file input click method
    const fileInput = wrapper.find('input[type="file"]');
    const clickSpy = vi.spyOn(fileInput.element, 'click');

    const importButton = wrapper.findAll('button').find(btn =>
      btn.text().includes('Import from CSV')
    );
    await importButton.trigger('click');

    expect(clickSpy).toHaveBeenCalled();
  });

  it('handles CSV export functionality', async () => {
    // Switch to CSV tab
    const csvTab = wrapper.findAll('.tab-button')[1];
    await csvTab.trigger('click');

    // Mock URL.createObjectURL and document methods
    global.URL.createObjectURL = vi.fn(() => 'mock-url');
    const createElementSpy = vi.spyOn(document, 'createElement');
    const appendChildSpy = vi.spyOn(document.body, 'appendChild');
    const removeChildSpy = vi.spyOn(document.body, 'removeChild');

    const exportButton = wrapper.findAll('button').find(btn =>
      btn.text().includes('Export as CSV')
    );
    await exportButton.trigger('click');

    expect(createElementSpy).toHaveBeenCalledWith('a');
    expect(appendChildSpy).toHaveBeenCalled();
    expect(removeChildSpy).toHaveBeenCalled();
  });

  it('validates CSV format information is displayed', async () => {
    // Switch to CSV tab
    const csvTab = wrapper.findAll('.tab-button')[1];
    await csvTab.trigger('click');

    expect(wrapper.text()).toContain('CSV Format');
    expect(wrapper.text()).toContain('FromType,ToType,Minutes');
    expect(wrapper.text()).toContain('CABG,KNEE,30');
    expect(wrapper.text()).toContain('The first row is a header row');
  });
});


================================================
FILE: src/components/__tests__/ConfirmationModal.test.js
================================================
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import ConfirmationModal from '../ConfirmationModal.vue';

describe('ConfirmationModal', () => {
  const defaultProps = {
    show: true,
    title: 'Test Title',
    message: 'Test Message',
  };

  it('renders correctly when show prop is true', () => {
    const wrapper = mount(ConfirmationModal, { props: defaultProps });
    expect(wrapper.find('.modal-overlay').exists()).toBe(true);
    expect(wrapper.text()).toContain(defaultProps.title);
    expect(wrapper.text()).toContain(defaultProps.message);
    // Check default button text if props are not provided
    const confirmButton = wrapper.find('button.button-danger');
    const cancelButton = wrapper.find('button.button-secondary');
    expect(confirmButton.exists()).toBe(true);
    expect(cancelButton.exists()).toBe(true);
    expect(confirmButton.text()).toBe('Confirm'); // Default text from template
    expect(cancelButton.text()).toBe('Cancel'); // Default text from template
  });

  it('emits confirm event when confirm button is clicked', async () => {
    const wrapper = mount(ConfirmationModal, { props: defaultProps });
    await wrapper.find('button.button-danger').trigger('click');
    expect(wrapper.emitted('confirm')).toBeTruthy();
  });

  it('emits cancel event when cancel button is clicked', async () => {
    const wrapper = mount(ConfirmationModal, { props: defaultProps });
    await wrapper.find('button.button-secondary').trigger('click');
    expect(wrapper.emitted('cancel')).toBeTruthy();
  });

  it('does not render when show prop is false', () => {
    const wrapper = mount(ConfirmationModal, { props: { ...defaultProps, show: false } });
    expect(wrapper.find('.modal-overlay').exists()).toBe(false);
  });

  // Snapshot test remains the same, but will capture the corrected HTML
  it('matches snapshot when shown', () => {
    const wrapper = mount(ConfirmationModal, { props: defaultProps });
    expect(wrapper.html()).toMatchSnapshot();
  });
});


================================================
FILE: src/components/__tests__/CustomReportBuilder.test.js
================================================
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import CustomReportBuilder from '../CustomReportBuilder.vue';

describe('CustomReportBuilder', () => {
  // Basic rendering test
  it('renders correctly', () => {
    const wrapper = mount(CustomReportBuilder);
    expect(wrapper.exists()).toBe(true);
  });

  // Add more tests here based on component functionality (props, data, events, methods, etc.)
});


================================================
FILE: src/components/__tests__/DashboardScreen.test.js
================================================
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { createRouter, createMemoryHistory } from 'vue-router';
import { createPinia, setActivePinia } from 'pinia';
import { ref } from 'vue';
import DashboardScreen from '../DashboardScreen.vue';

// Mock the auth store
vi.mock('@/stores/authStore', () => ({
  useAuthStore: () => ({
    user: ref({ id: 1, name: 'Test User', username: 'test@example.com' })
  })
}));

// Mock the schedule store
const mockScheduledSurgeries = ref([
  {
    id: 's-1',
    patientName: 'Alice Smith',
    type: 'CABG',
    startTime: '2023-10-27T08:00:00Z',
    conflicts: ['SDST violation: requires 60 minutes setup']
  },
  {
    id: 's-2',
    patientName: 'Bob Johnson',
    type: 'KNEE',
    startTime: '2023-10-27T12:30:00Z',
    conflicts: []
  }
]);

const mockPendingSurgeries = ref([
  {
    id: 'p-1',
    patientName: 'Charlie Brown',
    type: 'APPEN',
    priority: 'High'
  }
]);

vi.mock('@/stores/scheduleStore', () => ({
  useScheduleStore: () => ({
    visibleScheduledSurgeries: mockScheduledSurgeries,
    pendingSurgeries: mockPendingSurgeries,
    scheduledSurgeries: mockScheduledSurgeries.value,
    getSurgeriesForOR: vi.fn((orId) => {
      return mockScheduledSurgeries.value.filter(s => s.orId === orId || orId === 'OR1');
    }),
    selectSurgery: vi.fn()
  })
}));

describe('DashboardScreen', () => {
  let wrapper;
  let router;
  let pinia;

  beforeEach(async () => {
    // Create a fresh Pinia instance for each test
    pinia = createPinia();
    setActivePinia(pinia);

    // Create a router instance
    router = createRouter({
      history: createMemoryHistory(),
      routes: [
        { path: '/', name: 'Dashboard', component: { template: '<div>Dashboard</div>' } },
        { path: '/scheduling', name: 'Scheduling', component: { template: '<div>Scheduling</div>' } },
        { path: '/resource-management', name: 'ResourceManagement', component: { template: '<div>Resources</div>' } }
      ]
    });

    wrapper = mount(DashboardScreen, {
      global: {
        plugins: [router, pinia],
        stubs: {
          'router-link': true,
          'router-view': true
        }
      }
    });

    await router.isReady();
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.find('.dashboard-container').exists()).toBe(true);
  });

  it('renders the main heading', () => {
    expect(wrapper.find('h1').text()).toBe('Welcome, User!');
  });

  it('renders dashboard widgets', () => {
    expect(wrapper.find('.dashboard-widgets').exists()).toBe(true);

    // Check for key widgets
    expect(wrapper.text()).toContain('Quick Actions');
    expect(wrapper.text()).toContain('Key Performance Indicators');
    expect(wrapper.text()).toContain('Critical Resource Alerts');
    expect(wrapper.text()).toContain('SDST Conflict Summary'); // Actual text in component
    expect(wrapper.text()).toContain('Pending Surgeries');
    expect(wrapper.text()).toContain("Today's OR Schedule Overview"); // Actual text in component
  });

  it('displays KPI values', () => {
    // Check that KPI values are displayed
    expect(wrapper.text()).toContain('85%'); // OR Utilization
    expect(wrapper.text()).toContain('30 min'); // Avg SDST
    expect(wrapper.text()).toContain('2'); // Emergency Cases
    expect(wrapper.text()).toContain('1'); // Cancelled Surgeries
  });

  it('displays pending surgeries from store', () => {
    expect(wrapper.text()).toContain('Charlie Brown');
    expect(wrapper.text()).toContain('APPEN');
  });

  it('displays SDST conflicts from store', () => {
    expect(wrapper.text()).toContain('Alice Smith');
    expect(wrapper.text()).toContain('SDST violation');
  });

  it('handles quick action button clicks', async () => {
    const routerPushSpy = vi.spyOn(router, 'push');

    // Test "Go to Master Schedule" button
    const masterScheduleBtn = wrapper.findAll('button').find(btn =>
      btn.text().includes('Go to Master Schedule')
    );
    if (masterScheduleBtn) {
      await masterScheduleBtn.trigger('click');
      expect(routerPushSpy).toHaveBeenCalledWith({ name: 'Scheduling' });
    }

    // Test "Manage Resources" button
    const manageResourcesBtn = wrapper.findAll('button').find(btn =>
      btn.text().includes('Manage Resources')
    );
    if (manageResourcesBtn) {
      await manageResourcesBtn.trigger('click');
      expect(routerPushSpy).toHaveBeenCalledWith({ name: 'ResourceManagement' });
    }
  });
});


================================================
FILE: src/components/__tests__/GanttAccessibleTable.test.js
================================================
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import GanttAccessibleTable from '../GanttAccessibleTable.vue';

describe('GanttAccessibleTable', () => {
  // Basic rendering test
  it('renders correctly', () => {
    const wrapper = mount(GanttAccessibleTable);
    expect(wrapper.exists()).toBe(true);
  });

  // Add more tests here based on component functionality (props, data, events, methods, etc.)
});


================================================
FILE: src/components/__tests__/GanttChart.test.js
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { createPinia, setActivePinia } from 'pinia';
import { ref } from 'vue';
import GanttChart from '../GanttChart.vue';

// Mock the schedule store
const mockScheduledSurgeries = ref([
  {
    id: 's-1',
    patientName: 'Alice Smith',
    type: 'CABG',
    fullType: 'Coronary Artery Bypass Graft',
    surgeon: 'Dr. Johnson',
    startTime: '2023-10-27T08:00:00Z',
    endTime: '2023-10-27T10:30:00Z',
    duration: 150,
    estimatedDuration: 150,
    sdsTime: 45,
    precedingType: 'KNEE',
    orId: 'OR1',
    orName: 'OR 1',
    conflicts: ['SDST violation: requires 60 minutes setup']
  },
  {
    id: 's-2',
    patientName: 'Bob Johnson',
    type: 'KNEE',
    fullType: 'Knee Replacement',
    surgeon: 'Dr. Smith',
    startTime: '2023-10-27T12:30:00Z',
    endTime: '2023-10-27T14:00:00Z',
    duration: 90,
    estimatedDuration: 90,
    sdsTime: 15,
    precedingType: null,
    orId: 'OR2',
    orName: 'OR 2',
    conflicts: []
  }
]);

const mockOperatingRooms = ref([
  { id: 'OR1', name: 'OR 1', isAvailable: true },
  { id: 'OR2', name: 'OR 2', isAvailable: true },
  { id: 'OR3', name: 'OR 3', isAvailable: false }
]);

const mockCurrentDateRange = ref({
  start: new Date('2023-10-27T07:00:00Z'),
  end: new Date('2023-10-27T19:00:00Z')
});

// Define the base mock store object
const mockScheduleStore = {
  visibleScheduledSurgeries: mockScheduledSurgeries,
  availableOperatingRooms: mockOperatingRooms,
  currentDateRange: mockCurrentDateRange,
  isLoading: ref(false),
  selectedSurgeryId: ref(null),
  ganttViewMode: 'Day',
  getSurgeriesForOR: vi.fn((orId) => {
    return mockScheduledSurgeries.value.filter(s => s.orId === orId);
  }),
  selectSurgery: vi.fn(),
  loadInitialData: vi.fn(),
  navigateGanttDate: vi.fn(),
  updateGanttViewMode: vi.fn(),
  resetGanttToToday: vi.fn(),
  rescheduleSurgery: vi.fn()
};

vi.mock('@/stores/scheduleStore', () => ({
  useScheduleStore: () => mockScheduleStore
}));

// Mock the GanttAccessibleTable component
vi.mock('../GanttAccessibleTable.vue', () => ({
  default: {
    name: 'GanttAccessibleTable',
    template: '<div data-testid="gantt-accessible-table">Accessible Table</div>'
  }
}));

describe('GanttChart', () => {
  let wrapper;
  let pinia;

  beforeEach(async () => {
    // Create a fresh Pinia instance for each test
    pinia = createPinia();
    setActivePinia(pinia);

    wrapper = mount(GanttChart, {
      global: {
        plugins: [pinia]
      }
    });
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.find('.gantt-container').exists()).toBe(true);
  });

  it('renders the gantt header with title and controls', () => {
    expect(wrapper.find('.gantt-header').exists()).toBe(true);
    expect(wrapper.find('.gantt-title h3').text()).toBe('Operating Room Schedule');
    expect(wrapper.find('.view-mode-indicator').text()).toBe('Day View');
  });

  it('renders view mode buttons', () => {
    const dayButton = wrapper.findAll('button').find(btn => btn.text() === 'Day');
    const weekButton = wrapper.findAll('button').find(btn => btn.text() === 'Week');
    const todayButton = wrapper.findAll('button').find(btn => btn.text() === 'Today');

    expect(dayButton.exists()).toBe(true);
    expect(weekButton.exists()).toBe(true);
    expect(todayButton.exists()).toBe(true);
  });

  it('renders date navigation controls', () => {
    expect(wrapper.find('.date-navigation').exists()).toBe(true);
    expect(wrapper.find('.current-date-display').exists()).toBe(true);

    const prevButton = wrapper.find('button[aria-label="Previous day"]');
    const nextButton = wrapper.find('button[aria-label="Next day"]');

    expect(prevButton.exists()).toBe(true);
    expect(nextButton.exists()).toBe(true);
  });

  it('renders SDST legend', () => {
    expect(wrapper.find('.sdst-legend').exists()).toBe(true);
    expect(wrapper.text()).toContain('SDST Color Coding:');
    expect(wrapper.text()).toContain('Short (≤15 min)');
    expect(wrapper.text()).toContain('Medium (16-30 min)');
    expect(wrapper.text()).toContain('Long (>30 min)');
  });

  it('renders operating room rows', () => {
    const orRows = wrapper.findAll('.gantt-or-row');
    expect(orRows.length).toBe(3); // OR1, OR2, OR3

    expect(wrapper.text()).toContain('OR 1');
    expect(wrapper.text()).toContain('OR 2');
    expect(wrapper.text()).toContain('OR 3');
  });

  it('renders surgery blocks with correct information', () => {
    const surgeryBlocks = wrapper.findAll('.surgery-block');
    expect(surgeryBlocks.length).toBe(2); // Two surgeries in mock data

    // Check first surgery
    expect(wrapper.text()).toContain('Alice Smith - CABG');
    expect(wrapper.text()).toContain('Bob Johnson - KNEE');
  });

  it('displays conflict indicators for surgeries with conflicts', () => {
    const conflictIndicators = wrapper.findAll('.conflict-indicator');
    expect(conflictIndicators.length).toBe(1); // Only Alice Smith has conflicts
    expect(conflictIndicators[0].text()).toBe('⚠️');
  });

  it('renders SDST segments with appropriate styling', () => {
    const sdstSegments = wrapper.findAll('.sdst-segment');
    expect(sdstSegments.length).toBe(2); // Both surgeries have SDST

    // Check SDST classes based on duration
    const highSDST = wrapper.find('.sdst-high'); // Alice Smith: 45 min
    const lowSDST = wrapper.find('.sdst-low'); // Bob Johnson: 15 min

    expect(highSDST.exists()).toBe(true);
    expect(lowSDST.exists()).toBe(true);
  });

  it('renders time axis with hour markers', () => {
    expect(wrapper.find('.gantt-time-axis').exists()).toBe(true);
    const timeMarkers = wrapper.findAll('.time-marker');
    expect(timeMarkers.length).toBeGreaterThan(0);
  });

  it('renders accessible table component', () => {
    expect(wrapper.find('[data-testid="gantt-accessible-table"]').exists()).toBe(true);
  });

  it('navigation buttons are clickable and functional', async () => {
    // Test that navigation buttons exist and are clickable
    const prevButton = wrapper.find('button[aria-label="Previous day"]');
    const nextButton = wrapper.find('button[aria-label="Next day"]');
    const todayButton = wrapper.findAll('button').find(btn => btn.text() === 'Today');

    expect(prevButton.exists()).toBe(true);
    expect(nextButton.exists()).toBe(true);
    expect(todayButton.exists()).toBe(true);

    // Test that buttons are clickable (no errors thrown)
    await prevButton.trigger('click');
    await nextButton.trigger('click');
    await todayButton.trigger('click');

    // If we get here without errors, the buttons are functional
    expect(true).toBe(true);
  });

  it('view mode buttons are clickable and functional', async () => {
    // Test that view mode buttons exist and are clickable
    const weekButton = wrapper.findAll('button').find(btn => btn.text() === 'Week');
    const dayButton = wrapper.findAll('button').find(btn => btn.text() === 'Day');

    expect(weekButton.exists()).toBe(true);
    expect(dayButton.exists()).toBe(true);

    // Test that buttons are clickable (no errors thrown)
    await weekButton.trigger('click');
    await dayButton.trigger('click');

    // If we get here without errors, the buttons are functional
    expect(true).toBe(true);
  });

  it('surgery blocks are clickable', async () => {
    const surgeryBlocks = wrapper.findAll('.surgery-block');
    expect(surgeryBlocks.length).toBeGreaterThan(0);

    // Test that surgery blocks are clickable (no errors thrown)
    await surgeryBlocks[0].trigger('click');

    // If we get here without errors, the surgery blocks are clickable
    expect(true).toBe(true);
  });

  it('shows tooltip on surgery block hover', async () => {
    const surgeryBlocks = wrapper.findAll('.surgery-block');
    expect(surgeryBlocks.length).toBeGreaterThan(0);

    // Initially no tooltip
    expect(wrapper.find('.surgery-tooltip').exists()).toBe(false);

    // Mock getBoundingClientRect for the hover event
    const mockRect = { left: 100, top: 100, width: 200, height: 50, bottom: 150 };
    surgeryBlocks[0].element.getBoundingClientRect = vi.fn(() => mockRect);

    // Trigger mouseover
    await surgeryBlocks[0].trigger('mouseover');
    await wrapper.vm.$nextTick();

    // Tooltip should now be visible
    expect(wrapper.find('.surgery-tooltip').exists()).toBe(true);
    expect(wrapper.find('.tooltip-header').text()).toContain('Alice Smith');
  });

  it('hides tooltip on surgery block mouseleave', async () => {
    const surgeryBlocks = wrapper.findAll('.surgery-block');

    // First show tooltip
    const mockRect = { left: 100, top: 100, width: 200, height: 50, bottom: 150 };
    surgeryBlocks[0].element.getBoundingClientRect = vi.fn(() => mockRect);
    await surgeryBlocks[0].trigger('mouseover');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('.surgery-tooltip').exists()).toBe(true);

    // Then hide it
    await surgeryBlocks[0].trigger('mouseleave');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('.surgery-tooltip').exists()).toBe(false);
  });

  it('handles drag and drop setup correctly', async () => {
    const surgeryBlocks = wrapper.findAll('.surgery-block');
    expect(surgeryBlocks.length).toBeGreaterThan(0);

    // Mock dataTransfer for drag events
    const mockDataTransfer = {
      effectAllowed: '',
      setData: vi.fn(),
      getData: vi.fn(() => 's-1')
    };

    // Test dragstart
    const dragStartEvent = new Event('dragstart');
    dragStartEvent.dataTransfer = mockDataTransfer;

    await surgeryBlocks[0].trigger('dragstart', { dataTransfer: mockDataTransfer });

    expect(mockDataTransfer.setData).toHaveBeenCalledWith('text/plain', 's-1');
    expect(mockDataTransfer.effectAllowed).toBe('move');
  });

  it('displays loading state when store is loading', async () => {
    // Update the mock to show loading state
    const { useScheduleStore } = await import('@/stores/scheduleStore');
    const store = useScheduleStore();
    store.isLoading.value = true;

    await wrapper.vm.$nextTick();

    expect(wrapper.find('.loading-overlay').exists()).toBe(true);
    expect(wrapper.text()).toContain('Loading Schedule...');
  });
});


================================================
FILE: src/components/__tests__/HelloWorld.test.js
================================================
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { mount } from '@vue/test-utils'
import HelloWorld from '../HelloWorld.vue';

describe('HelloWorld', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(HelloWorld, { props: { msg: 'Hello Vitest' } });
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders properly with message prop', () => {
    expect(wrapper.text()).toContain('Hello Vitest');
    expect(wrapper.find('h1').text()).toBe('Hello Vitest');
  });

  it('renders with different message prop', () => {
    const customWrapper = mount(HelloWorld, { props: { msg: 'Custom Message' } });
    expect(customWrapper.find('h1').text()).toBe('Custom Message');
    customWrapper.unmount();
  });

  it('renders without message prop', () => {
    const noPropsWrapper = mount(HelloWorld);
    expect(noPropsWrapper.find('h1').text()).toBe(''); // Should be empty when no prop provided
    noPropsWrapper.unmount();
  });

  it('displays initial count as 0', () => {
    const button = wrapper.find('button');
    expect(button.text()).toBe('count is 0');
  });

  it('increments count when button is clicked', async () => {
    const button = wrapper.find('button');

    // Initial state
    expect(button.text()).toBe('count is 0');

    // Click once
    await button.trigger('click');
    expect(button.text()).toBe('count is 1');

    // Click again
    await button.trigger('click');
    expect(button.text()).toBe('count is 2');

    // Click multiple times
    await button.trigger('click');
    await button.trigger('click');
    await button.trigger('click');
    expect(button.text()).toBe('count is 5');
  });

  it('renders static content correctly', () => {
    expect(wrapper.text()).toContain('Edit');
    expect(wrapper.text()).toContain('components/HelloWorld.vue');
    expect(wrapper.text()).toContain('to test HMR');
    expect(wrapper.text()).toContain('Check out');
    expect(wrapper.text()).toContain('create-vue');
    expect(wrapper.text()).toContain('Learn more about IDE Support');
    expect(wrapper.text()).toContain('Click on the Vite and Vue logos to learn more');
  });

  it('renders external links with correct attributes', () => {
    const links = wrapper.findAll('a');
    expect(links.length).toBe(2);

    // First link - create-vue
    expect(links[0].attributes('href')).toBe('https://vuejs.org/guide/quick-start.html#local');
    expect(links[0].attributes('target')).toBe('_blank');
    expect(links[0].text()).toBe('create-vue');

    // Second link - Vue Docs
    expect(links[1].attributes('href')).toBe('https://vuejs.org/guide/scaling-up/tooling.html#ide-support');
    expect(links[1].attributes('target')).toBe('_blank');
    expect(links[1].text()).toBe('Vue Docs Scaling up Guide');
  });

  it('has correct CSS classes', () => {
    expect(wrapper.find('.card').exists()).toBe(true);
    expect(wrapper.find('.read-the-docs').exists()).toBe(true);
  });

  it('button has correct type attribute', () => {
    const button = wrapper.find('button');
    expect(button.attributes('type')).toBe('button');
  });

  it('maintains independent count state across multiple instances', async () => {
    const wrapper1 = mount(HelloWorld, { props: { msg: 'Instance 1' } });
    const wrapper2 = mount(HelloWorld, { props: { msg: 'Instance 2' } });

    const button1 = wrapper1.find('button');
    const button2 = wrapper2.find('button');

    // Click first instance button
    await button1.trigger('click');
    await button1.trigger('click');

    // Click second instance button once
    await button2.trigger('click');

    // Each instance should maintain its own count
    expect(button1.text()).toBe('count is 2');
    expect(button2.text()).toBe('count is 1');

    wrapper1.unmount();
    wrapper2.unmount();
  });

  it('renders code element correctly', () => {
    const codeElement = wrapper.find('code');
    expect(codeElement.exists()).toBe(true);
    expect(codeElement.text()).toBe('components/HelloWorld.vue');
  });
})


================================================
FILE: src/components/__tests__/HelpDocumentationScreen.test.js
================================================
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import HelpDocumentationScreen from '../HelpDocumentationScreen.vue';

describe('HelpDocumentationScreen', () => {
  // Basic rendering test
  it('renders correctly', () => {
    const wrapper = mount(HelpDocumentationScreen);
    expect(wrapper.exists()).toBe(true);
  });

  // Add more tests here based on component functionality (props, data, events, methods, etc.)
});


================================================
FILE: src/components/__tests__/KeyboardShortcutsHelp.test.js
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { nextTick } from 'vue';
import KeyboardShortcutsHelp from '../KeyboardShortcutsHelp.vue';

// Mock the keyboard shortcuts service
vi.mock('@/services/keyboardShortcuts', () => {
  const mockShortcuts = [
    {
      key: 's',
      ctrlKey: true,
      description: 'Save current work',
      scope: 'global'
    },
    {
      key: 'n',
      ctrlKey: true,
      description: 'Create new item',
      scope: 'global'
    },
    {
      key: 'f',
      ctrlKey: true,
      description: 'Find and search',
      scope: 'search'
    },
    {
      key: 'escape',
      description: 'Cancel current action',
      scope: 'navigation'
    },
    {
      key: '?',
      shiftKey: true,
      description: 'Show keyboard shortcuts help',
      scope: 'global'
    }
  ];

  return {
    default: {
      getShortcuts: vi.fn(() => mockShortcuts),
      register: vi.fn(() => vi.fn()), // Returns unregister function
    }
  };
});

describe('KeyboardShortcutsHelp', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(KeyboardShortcutsHelp);
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders correctly when not visible', () => {
    expect(wrapper.exists()).toBe(true);
    // Modal should not be visible initially
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();
  });

  it('shows modal when show method is called', async () => {
    wrapper.vm.show();
    await nextTick();

    const overlay = document.querySelector('.keyboard-shortcuts-overlay');
    expect(overlay).toBeTruthy();
    expect(overlay.querySelector('.keyboard-shortcuts-modal')).toBeTruthy();
  });

  it('hides modal when close method is called', async () => {
    wrapper.vm.show();
    await nextTick();
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeTruthy();

    wrapper.vm.close();
    await nextTick();
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();
  });

  it('toggles modal visibility when toggle method is called', async () => {
    // Initially hidden
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();

    // Toggle to show
    wrapper.vm.toggle();
    await nextTick();
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeTruthy();

    // Toggle to hide
    wrapper.vm.toggle();
    await nextTick();
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();
  });

  it('displays modal title correctly', async () => {
    wrapper.vm.show();
    await nextTick();

    const title = document.querySelector('.modal-header h2');
    expect(title.textContent).toBe('Keyboard Shortcuts');
  });

  it('closes modal when close button is clicked', async () => {
    wrapper.vm.show();
    await nextTick();

    const closeButton = document.querySelector('.close-button');
    closeButton.click();
    await nextTick();

    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();
  });

  it('closes modal when overlay is clicked', async () => {
    wrapper.vm.show();
    await nextTick();

    const overlay = document.querySelector('.keyboard-shortcuts-overlay');
    overlay.click();
    await nextTick();

    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();
  });

  it('does not close modal when modal content is clicked', async () => {
    wrapper.vm.show();
    await nextTick();

    const modal = document.querySelector('.keyboard-shortcuts-modal');
    modal.click();
    await nextTick();

    // Modal should still be visible
    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeTruthy();
  });

  it('closes modal when footer close button is clicked', async () => {
    wrapper.vm.show();
    await nextTick();

    const footerButton = document.querySelector('.modal-footer .btn');
    footerButton.click();
    await nextTick();

    expect(document.querySelector('.keyboard-shortcuts-overlay')).toBeFalsy();
  });

  it('groups shortcuts by scope correctly', async () => {
    wrapper.vm.show();
    await nextTick();

    const groups = document.querySelectorAll('.shortcut-group');
    expect(groups.length).toBe(3); // global, search, navigation

    // Check that groups have correct titles
    const groupTitles = Array.from(groups).map(group =>
      group.querySelector('h3').textContent
    );
    expect(groupTitles).toContain('Global');
    expect(groupTitles).toContain('Search');
    expect(groupTitles).toContain('Navigation');
  });

  it('displays shortcuts with correct formatting', async () => {
    wrapper.vm.show();
    await nextTick();

    // Check that shortcuts are displayed in tables
    const tables = document.querySelectorAll('table');
    expect(tables.length).toBeGreaterThan(0);

    // Check table headers
    const headers = document.querySelectorAll('th');
    expect(headers[0].textContent).toBe('Shortcut');
    expect(headers[1].textContent).toBe('Description');

    // Check that key combinations are displayed
    const keyElements = document.querySelectorAll('.key');
    expect(keyElements.length).toBeGreaterThan(0);
  });

  it('formats special keys correctly', () => {
    // Test the formatKeyName method through the component
    const testCases = [
      { input: 'escape', expected: 'Esc' },
      { input: ' ', expected: 'Space' },
      { input: 'arrowup', expected: '↑' },
      { input: 'arrowdown', expected: '↓' },
      { input: 'enter', expected: 'Enter' },
      { input: 'a', expected: 'A' }
    ];

    testCases.forEach(({ input, expected }) => {
      const result = wrapper.vm.formatKeyName(input);
      expect(result).toBe(expected);
    });
  });

  it('formats scope names correctly', () => {
    expect(wrapper.vm.formatScopeName('global')).toBe('Global');
    expect(wrapper.vm.formatScopeName('search')).toBe('Search');
    expect(wrapper.vm.formatScopeName('navigation')).toBe('Navigation');
  });

  it('registers keyboard shortcut on mount', async () => {
    const keyboardShortcuts = await import('@/services/keyboardShortcuts');
    expect(keyboardShortcuts.default.register).toHaveBeenCalledWith(
      '?',
      expect.any(Function),
      {
        shiftKey: true,
        description: 'Show keyboard shortcuts help',
        scope: 'global'
      }
    );
  });

  it('displays modifier keys correctly', async () => {
    wrapper.vm.show();
    await nextTick();

    // Find a shortcut with Ctrl key (like Ctrl+S)
    const shortcutRows = document.querySelectorAll('tbody tr');
    const ctrlSRow = Array.from(shortcutRows).find(row =>
      row.textContent.includes('Save current work')
    );

    expect(ctrlSRow).toBeTruthy();
    const keys = ctrlSRow.querySelectorAll('.key');
    expect(keys.length).toBe(2); // Ctrl + S
    expect(keys[0].textContent).toBe('Ctrl');
    expect(keys[1].textContent).toBe('S');
  });

  it('has proper accessibility attributes', async () => {
    wrapper.vm.show();
    await nextTick();

    const closeButton = document.querySelector('.close-button');
    expect(closeButton.getAttribute('aria-label')).toBe('Close keyboard shortcuts help');
  });

  it('calls getShortcuts from keyboard shortcuts service', async () => {
    const keyboardShortcuts = await import('@/services/keyboardShortcuts');
    expect(keyboardShortcuts.default.getShortcuts).toHaveBeenCalled();
  });
});


================================================
FILE: src/components/__tests__/LoginScreen.spec.js
================================================
import { mount } from '@vue/test-utils';
import { createRouter, createMemoryHistory } from 'vue-router';
import { createPinia } from 'pinia';
import LoginScreen from '../LoginScreen.vue';
import DashboardScreen from '../DashboardScreen.vue';
import { ref } from 'vue'; // Import ref for reactive state in mock

// Mock the setAuthenticated function from the router
const mockSetAuthenticated = vi.fn();

// Mock localStorage
const localStorageMock = (() => {
  let store = {};
  return {
    getItem: (key) => store[key] || null,
    setItem: (key, value) => {
      store[key] = value.toString();
    },
    clear: () => {
      store = {};
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
});

// Mock the authStore with reactive state and simulated actions
const mockIsAuthenticated = ref(false);
const mockUser = ref(null);
const mockLoading = ref(false);
const mockError = ref(null);

const mockLogin = vi.fn(async (username, password) => {
  mockLoading.value = true;
  mockError.value = null;
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 10));

  if (username === 'test@example.com' && password === 'password') {
    mockIsAuthenticated.value = true;
    mockUser.value = { id: 1, username: 'test@example.com', name: 'Test User' };
    // Simulate router push on successful login
    mockRouterPush({ name: 'Dashboard' });
  } else {
    mockError.value = 'Invalid username or password.';
    mockIsAuthenticated.value = false;
    mockUser.value = null;
  }
  mockLoading.value = false;
});

const mockRegister = vi.fn(async (username, password) => {
  mockLoading.value = true;
  mockError.value = null;
  let success = false;
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 10));

  // Mocked registration logic (e.g., fail if username exists)
  if (username === 'test@example.com') {
    mockError.value = 'Mock: Username already exists.';
    success = false;
  } else {
    // Simulate successful registration
    console.log('Mock Registration successful for:', username);
    success = true;
  }
  mockLoading.value = false;
  return success;
});

const mockLogout = vi.fn(() => {
  mockIsAuthenticated.value = false;
  mockUser.value = null;
  mockError.value = null;
  // Simulate router push on logout
  mockRouterPush({ name: 'Login' });
});

vi.mock('@/stores/authStore', () => ({
  useAuthStore: () => ({
    get isAuthenticated() { return mockIsAuthenticated.value; },
    get user() { return mockUser.value; },
    get isLoading() { return mockLoading.value; },
    get error() { return mockError.value; },
    login: mockLogin,
    register: mockRegister,
    logout: mockLogout,
    // Add $reset if your component uses it and you need to mock its behavior
    $reset: vi.fn(() => {
      mockIsAuthenticated.value = false;
      mockUser.value = null;
      mockLoading.value = false;
      mockError.value = null;
    })
  }),
}));

const routes = [
  { path: '/', name: 'Login', component: LoginScreen },
  { path: '/dashboard', name: 'Dashboard', component: DashboardScreen },
];

const router = createRouter({
  history: createMemoryHistory(), // Changed here
  routes,
});

// Mock the setAuthenticated function from ../router
vi.mock('../router', () => ({
  setAuthenticated: mockSetAuthenticated
}));

// Mock vue-router's useRouter hook
const mockRouterPush = vi.fn();
vi.mock('vue-router', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...actual, // Preserve other exports from vue-router
    useRouter: () => ({
      push: mockRouterPush,
      // Add other router methods or properties if your component uses them
    }),
  };
});

describe('LoginScreen.vue', () => {
  let wrapper;
  let pinia; // Declare pinia variable

  beforeEach(async () => {
    // Reset localStorage and mocks before each test
    localStorageMock.clear();
    mockSetAuthenticated.mockClear();
    mockRouterPush.mockClear();
    mockLogin.mockClear(); // Clear the authStore login mock
    mockRegister.mockClear(); // Clear the authStore register mock
    mockLogout.mockClear(); // Clear the authStore logout mock
    // Reset mock store state
    mockIsAuthenticated.value = false;
    mockUser.value = null;
    mockLoading.value = false;
    mockError.value = null;

    pinia = createPinia();

    wrapper = mount(LoginScreen, {
      global: {
        plugins: [router, pinia], // Add pinia to plugins
        stubs: {
          RouterLink: true,
        }
      }
    });
    await router.isReady();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('renders login form by default', () => {
    expect(wrapper.find('h2.form-title').text()).toBe('Login');
    expect(wrapper.find('input#username').exists()).toBe(true);
    expect(wrapper.find('input#password').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Login');
  });

  it('allows a user to login with correct credentials', async () => {
    await wrapper.find('input#username').setValue('test@example.com'); // Use the username expected by the mock
    await wrapper.find('input#password').setValue('password'); // Use the password expected by the mock
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 200)); // Increase delay

    // Expect the mocked login action to have been called
    expect(mockLogin).toHaveBeenCalledWith('test@example.com', 'password');
    // Expect the mocked router push to have been called by the mocked login action
    expect(mockRouterPush).toHaveBeenCalledWith({ name: 'Dashboard' });
    // Expect no error message to be displayed
    expect(wrapper.find('.error-message').exists()).toBe(false);
  });

  it('shows an error message with incorrect credentials', async () => {
    await wrapper.find('input#username').setValue('wronguser');
    await wrapper.find('input#password').setValue('wrongpassword');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 200)); // Increase delay

    // Expect the mocked login action to have been called
    expect(mockLogin).toHaveBeenCalledWith('wronguser', 'wrongpassword');
    // Expect the mocked router push NOT to have been called
    expect(mockRouterPush).not.toHaveBeenCalled();
    // Wait for the error message to appear in the DOM
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 50)); // Additional wait for DOM update
    // Expect the error message to be displayed (the mock sets the error state)
    expect(wrapper.find('.error-message').exists()).toBe(true);
    expect(wrapper.find('.error-message').text()).toBe('Invalid username or password.'); // Match the error message from the mock
  });

  it('shows an error message if username or password fields are empty', async () => {
    await wrapper.find('input#username').setValue('');
    await wrapper.find('input#password').setValue('somepassword');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('.error-message').text()).toBe('Please enter both username and password.');
    expect(mockSetAuthenticated).not.toHaveBeenCalled();
    expect(mockRouterPush).not.toHaveBeenCalled();

    await wrapper.find('input#username').setValue('someuser');
    await wrapper.find('input#password').setValue('');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('.error-message').text()).toBe('Please enter both username and password.');
    expect(mockSetAuthenticated).not.toHaveBeenCalled();
    expect(mockRouterPush).not.toHaveBeenCalled();
  });

  it('toggles to registration form when "Create one" is clicked', async () => {
    await wrapper.findAll('a[href="#"]').filter(a => a.text().includes('Create one'))[0].trigger('click');
    await wrapper.vm.$nextTick();

    expect(wrapper.find('h2.form-title').text()).toBe('Create Account');
    expect(wrapper.find('input#new-username').exists()).toBe(true);
    expect(wrapper.find('input#new-password').exists()).toBe(true);
    expect(wrapper.find('input#confirm-password').exists()).toBe(true);
    expect(wrapper.find('button[type="submit"]').text()).toBe('Create Account');
  });

  // Add more tests for registration functionality
  it('allows a user to register a new account', async () => {
    await wrapper.findAll('a[href="#"]').filter(a => a.text().includes('Create one'))[0].trigger('click');
    await wrapper.vm.$nextTick();

    await wrapper.find('input#new-username').setValue('newuser');
    await wrapper.find('input#new-password').setValue('newpass123');
    await wrapper.find('input#confirm-password').setValue('newpass123');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 200)); // Increase delay

    // Expect the mocked register action to have been called
    expect(mockRegister).toHaveBeenCalledWith('newuser', 'newpass123');
    // Wait for DOM updates
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 50));

    // The component switches back to login form after successful registration
    // So the success message won't be visible since it's in the registration form
    expect(wrapper.find('h2.form-title').text()).toBe('Login'); // Should switch back to login form

    // Instead, let's verify that the registration was successful by checking the mock was called
    // and that we're back on the login form (which indicates success)
  });

  it('shows an error if registration passwords do not match', async () => {
    await wrapper.findAll('a[href="#"]').filter(a => a.text().includes('Create one'))[0].trigger('click');
    await wrapper.vm.$nextTick();

    await wrapper.find('input#new-username').setValue('anotheruser');
    await wrapper.find('input#new-password').setValue('password123');
    await wrapper.find('input#confirm-password').setValue('password456');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();

    // Expect the mocked register action NOT to have been called because passwords don't match
    expect(mockRegister).not.toHaveBeenCalled();
    // Expect the error message to be displayed (the component should handle password mismatch before calling the store)
    expect(wrapper.find('.error-message').exists()).toBe(true);
    expect(wrapper.find('.error-message').text()).toBe('Passwords do not match.'); // Assuming component shows this error
  });

  it('shows an error if username already exists during registration', async () => {
    // Simulate an existing user by making the mockRegister return false and set an error
    mockRegister.mockImplementationOnce(async (username, password) => {
      mockLoading.value = true;
      mockError.value = null;
      await new Promise(resolve => setTimeout(resolve, 10));
      mockError.value = 'Mock: Username already exists.';
      mockLoading.value = false;
      return false; // Simulate registration failure
    });

    await wrapper.findAll('a[href="#"]').filter(a => a.text().includes('Create one'))[0].trigger('click');
    await wrapper.vm.$nextTick();

    await wrapper.find('input#new-username').setValue('test@example.com'); // Use a username that the mock will treat as existing
    await wrapper.find('input#new-password').setValue('somepass');
    await wrapper.find('input#confirm-password').setValue('somepass');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 200)); // Increase delay
    // Wait for DOM updates
    await wrapper.vm.$nextTick();
    await new Promise(resolve => setTimeout(resolve, 50));

    // Expect the mocked register action to have been called
    expect(mockRegister).toHaveBeenCalledWith('test@example.com', 'somepass');
    // Expect the error message to be displayed (the mock sets the error state)
    expect(wrapper.find('.error-message').exists()).toBe(true);
    expect(wrapper.find('.error-message').text()).toBe('Mock: Username already exists.'); // Match the error message from the mock
  });

  it('shows an error if any registration field is empty', async () => {
    await wrapper.findAll('a[href="#"]').filter(a => a.text().includes('Create one'))[0].trigger('click');
    await wrapper.vm.$nextTick();

    // Test with empty username
    await wrapper.find('input#new-username').setValue('');
    await wrapper.find('input#new-password').setValue('somepass');
    await wrapper.find('input#confirm-password').setValue('somepass');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    expect(wrapper.find('.error-message').exists()).toBe(true);
    expect(wrapper.find('.error-message').text()).toBe('Please fill in all fields.'); // Assuming component shows this error
    expect(mockRegister).not.toHaveBeenCalled();

    // Test with empty password
    await wrapper.find('input#new-username').setValue('someuser');
    await wrapper.find('input#new-password').setValue('');
    await wrapper.find('input#confirm-password').setValue('somepass');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    expect(wrapper.find('.error-message').exists()).toBe(true);
    expect(wrapper.find('.error-message').text()).toBe('Please fill in all fields.');
    expect(mockRegister).not.toHaveBeenCalled();

    // Test with empty confirm password
    await wrapper.find('input#new-username').setValue('someuser');
    await wrapper.find('input#new-password').setValue('somepass');
    await wrapper.find('input#confirm-password').setValue('');
    await wrapper.find('form.login-form').trigger('submit.prevent');
    await wrapper.vm.$nextTick();
    // Fixed: Use .find() instead of .findBySelector()
    const errorMessage = wrapper.find('.error-message');
    expect(errorMessage.exists()).toBe(true);
    expect(errorMessage.text()).toBe('Please fill in all fields.');
    expect(mockRegister).not.toHaveBeenCalled();
  });
});


================================================
FILE: src/components/__tests__/ResourceManagementScreen.test.js
================================================
import { mount } from '@vue/test-utils';
import { createTestingPinia } from '@pinia/testing';
import { useResourceStore } from '@/stores/resourceStore';
import ResourceManagementScreen from '@/components/ResourceManagementScreen.vue';
import ConfirmationModal from '@/components/ConfirmationModal.vue';
import flushPromises from 'flush-promises';

// Mock data for the store
const INITIAL_STATE = {
  operatingRooms: [
    { id: 'or1', name: 'OR 1', location: 'Main', status: 'Available', primaryService: 'General' },
    { id: 'or2', name: 'OR 2', location: 'Main', status: 'In Use', primaryService: 'Orthopedics' },
  ],
  staff: [
    { id: 'staff1', name: 'Dr. Smith', role: 'Surgeon', specializations: ['General'], status: 'Available' },
    { id: 'staff2', name: 'Nurse Jones', role: 'Nurse', specializations: ['Anesthesia'], status: 'In Surgery' },
  ],
  equipment: [
    { id: 'equip1', name: 'X-Ray Machine', type: 'Imaging', status: 'Available', location: 'OR 1' },
    { id: 'equip2', name: 'Anesthesia Cart', type: 'Anesthesia', status: 'In Use', location: 'OR 2' },
  ],
  isLoading: false,
  error: null,
};

// Helper function to wait for table content to appear
// This helper is simplified; the primary fix is the selector change.
async function waitForTableContent(wrapper, selector, expectedRowCount, timeout = 3000) {
  const startTime = Date.now();
  let rowCount = 0;
  while (rowCount < expectedRowCount && (Date.now() - startTime < timeout)) {
    const section = wrapper.find(selector);
    if (section.exists()) {
      const table = section.find('table');
      if (table.exists()) {
        rowCount = table.findAll('tbody tr').length;
      }
    }
    if (rowCount < expectedRowCount) {
      await new Promise(resolve => setTimeout(resolve, 50)); // Wait a bit before re-checking
    }
  }
   if (rowCount < expectedRowCount) {
        console.error(`waitForTableContent failed for selector ${selector}. Expected at least ${expectedRowCount} rows, found ${rowCount}. HTML: ${wrapper.html()}`);
    }
  return rowCount;
}

describe('ResourceManagementScreen.vue', () => {
  let wrapper;
  let pinia;
  let resourceStore;

  beforeEach(() => {
    pinia = createTestingPinia({
      initialState: {
        resource: INITIAL_STATE,
      },
      // stubActions: false, // Keep actions real to test store interaction
    });
    resourceStore = useResourceStore(pinia);

    wrapper = mount(ResourceManagementScreen, {
      global: {
        plugins: [pinia],
        stubs: {
          AddOrForm: true,
          AddStaffForm: true,
          AddEquipmentForm: true,
          ConfirmationModal: false, // Stub ConfirmationModal to control its behavior
          ResourceAvailabilityCalendar: true,
        }
      }
    });
  });

  afterEach(() => {
    wrapper.unmount();
  });

  it('renders the component and displays OR tab by default', async () => {
    // Wait for initial data load and rendering
    await flushPromises();
    await wrapper.vm.$nextTick();

    expect(wrapper.exists()).toBe(true);
    expect(wrapper.find('h1').text()).toBe('Resource Management');
    expect(wrapper.find('.tabs button.active').text()).toBe('Operating Rooms');

    // Check if the OR section is displayed and others are not
    const orSection = wrapper.find('.resource-section'); // OR section is the first and only active one
    expect(orSection.exists()).toBe(true);
    expect(orSection.find('h2').text()).toBe('Operating Rooms List');

    // Check if other sections are NOT displayed (due to v-if)
    expect(wrapper.find('.resource-section:has(h2:contains("Staff List"))').exists()).toBe(false);
    expect(wrapper.find('.resource-section:has(h2:contains("Equipment List"))').exists()).toBe(false);

    // Wait for the OR table content
    const rowCount = await waitForTableContent(wrapper, '.resource-section', INITIAL_STATE.operatingRooms.length);
    expect(rowCount).toBe(INITIAL_STATE.operatingRooms.length);
  });

  it('switches to Staff tab when clicked', async () => {
    await wrapper.findAll('.tabs button')[1].trigger('click');
    await wrapper.vm.$nextTick();
    await flushPromises();

    expect(wrapper.find('.tabs button.active').text()).toBe('Staff');
    // Correct selector for the active Staff section
    const staffSection = wrapper.find('.resource-section');
    expect(staffSection.exists()).toBe(true);
    expect(staffSection.find('h2').text()).toBe('Staff List');

    // Check if other sections are NOT displayed
    expect(wrapper.find('.resource-section:has(h2:contains("Operating Rooms List"))').exists()).toBe(false);
    expect(wrapper.find('.resource-section:has(h2:contains("Equipment List"))').exists()).toBe(false);

    // Wait for the Staff table content
    const rowCount = await waitForTableContent(wrapper, '.resource-section', INITIAL_STATE.staff.length);
    expect(rowCount).toBe(INITIAL_STATE.staff.length);
  });

  it('switches to Equipment tab when clicked', async () => {
    await wrapper.findAll('.tabs button')[2].trigger('click');
    await wrapper.vm.$nextTick();
    await flushPromises();

    expect(wrapper.find('.tabs button.active').text()).toBe('Equipment');
    // Correct selector for the active Equipment section
    const equipmentSection = wrapper.find('.resource-section');
    expect(equipmentSection.exists()).toBe(true);
    expect(equipmentSection.find('h2').text()).toBe('Equipment List');

    // Check if other sections are NOT displayed
    expect(wrapper.find('.resource-section:has(h2:contains("Operating Rooms List"))').exists()).toBe(false);
    expect(wrapper.find('.resource-section:has(h2:contains("Staff List"))').exists()).toBe(false);

    // Wait for the Equipment table content
    const rowCount = await waitForTableContent(wrapper, '.resource-section', INITIAL_STATE.equipment.length);
    expect(rowCount).toBe(INITIAL_STATE.equipment.length);
  });

  // Test OR tab display
  describe('Operating Rooms tab', () => {
    // No separate beforeEach needed, uses the main one

    it('displays the OR table with correct columns', async () => {
      // Assumes OR tab is active by default and data is loaded (from main beforeEach)
      const orSection = wrapper.find('.resource-section'); // OR section is the active one
      expect(orSection.exists()).toBe(true);

      const table = orSection.find('table');
      expect(table.exists()).toBe(true);

      const headers = table.findAll('th').map(th => th.text());
      expect(headers).toEqual(['Name/ID', 'Location', 'Status', 'Primary Service', 'Actions']);
    });

    it('displays the initial OR data correctly', async () => {
      // Assumes OR tab is active by default and data is loaded (from main beforeEach)
      const orSection = wrapper.find('.resource-section'); // OR section is the active one
      expect(orSection.exists()).toBe(true);

      // Wait for the table content to be fully rendered
      await waitForTableContent(wrapper, '.resource-section', INITIAL_STATE.operatingRooms.length);

      const rows = orSection.findAll('tbody tr');
      expect(rows.length).toBe(INITIAL_STATE.operatingRooms.length);

      // Check content of the first row
      const firstRowCells = rows[0].findAll('td').map(td => td.text());
      expect(firstRowCells[0]).toBe(INITIAL_STATE.operatingRooms[0].name);
      expect(firstRowCells[1]).toBe(INITIAL_STATE.operatingRooms[0].location);
      expect(firstRowCells[2]).toBe(INITIAL_STATE.operatingRooms[0].status);
      expect(firstRowCells[3]).toBe(INITIAL_STATE.operatingRooms[0].primaryService);
    });

    it('shows the Add New OR form when button is clicked', async () => {
      const orSection = wrapper.find('.resource-section'); // OR section is the active one
      expect(orSection.exists()).toBe(true);

      const addButton = orSection.find('button.button-primary');
      expect(addButton.exists()).toBe(true);

      await addButton.trigger('click');
      await wrapper.vm.$nextTick();

      expect(wrapper.findComponent({ name: 'AddOrForm' }).exists()).toBe(true);
      // Check if the table is hidden when the form is shown (requires component logic fix)
      expect(orSection.find('table').exists()).toBe(false);
    });
  });

  // Test Staff tab display
  describe('Staff tab', () => {
    beforeEach(async () => {
      // Switch to Staff tab before each test in this block
      await wrapper.findAll('.tabs button')[1].trigger('click');
      await wrapper.vm.$nextTick();
      await flushPromises();

      // Wait for the Staff table content
      await waitForTableContent(wrapper, '.resource-section', INITIAL_STATE.staff.length);
    });

    it('displays the Staff table with correct columns', async () => {
      const staffSection = wrapper.find('.resource-section'); // Staff section is the active one
      expect(staffSection.exists()).toBe(true);

      const table = staffSection.find('table');
      expect(table.exists()).toBe(true);

      const headers = table.findAll('th').map(th => th.text());
      expect(headers).toEqual(['Name', 'Role', 'Specialization(s)', 'Status', 'Actions']);
    });

    it('displays the initial staff data correctly', async () => {
      const staffSection = wrapper.find('.resource-section'); // Staff section is the active one
      expect(staffSection.exists()).toBe(true);

      const rows = staffSection.findAll('tbody tr');
      expect(rows.length).toBe(INITIAL_STATE.staff.length);

      // Check content of the first row
      const firstRowCells = rows[0].findAll('td').map(td => td.text());
      expect(firstRowCells[0]).toBe(INITIAL_STATE.staff[0].name);
      expect(firstRowCells[1]).toBe(INITIAL_STATE.staff[0].role);
      expect(firstRowCells[2]).toBe(INITIAL_STATE.staff[0].specializations.join(', '));
      expect(firstRowCells[3]).toBe(INITIAL_STATE.staff[0].status);
    });

    it('shows the Add New Staff form when button is clicked', async () => {
      const staffSection = wrapper.find('.resource-section'); // Staff section is the active one
      expect(staffSection.exists()).toBe(true);

      const addButton = staffSection.find('button.button-primary');
      expect(addButton.exists()).toBe(true);

      await addButton.trigger('click');
      await wrapper.vm.$nextTick();

      expect(wrapper.findComponent({ name: 'AddStaffForm' }).exists()).toBe(true);
      // Check if the table is hidden when the form is shown (requires component logic fix)
      expect(staffSection.find('table').exists()).toBe(false);
    });
  });

  // Test Equipment tab display
  describe('Equipment tab', () => {
    beforeEach(async () => {
      // Switch to Equipment tab before each test in this block
      await wrapper.findAll('.tabs button')[2].trigger('click');
      await wrapper.vm.$nextTick();
      await flushPromises();

      // Wait for the Equipment table content
      await waitForTableContent(wrapper, '.resource-section', INITIAL_STATE.equipment.length);
    });

    it('displays the Equipment table with correct columns', async () => {
      const equipmentSection = wrapper.find('.resource-section'); // Equipment section is the active one
      expect(equipmentSection.exists()).toBe(true);

      const table = equipmentSection.find('table');
      expect(table.exists()).toBe(true);

      const headers = table.findAll('th').map(th => th.text());
      expect(headers).toEqual(['Name/ID', 'Type', 'Status', 'Location', 'Actions']);
    });

    it('displays the initial equipment data correctly', async () => {
      const equipmentSection = wrapper.find('.resource-section'); // Equipment section is the active one
      expect(equipmentSection.exists()).toBe(true);

      const rows = equipmentSection.findAll('tbody tr');
      expect(rows.length).toBe(INITIAL_STATE.equipment.length);

      // Check content of the first row
      const firstRowCells = rows[0].findAll('td').map(td => td.text());
      expect(firstRowCells[0]).toBe(INITIAL_STATE.equipment[0].name);
      expect(firstRowCells[1]).toBe(INITIAL_STATE.equipment[0].type);
      expect(firstRowCells[2]).toBe(INITIAL_STATE.equipment[0].status);
      expect(firstRowCells[3]).toBe(INITIAL_STATE.equipment[0].location);
    });

    it('shows the Add New Equipment form when button is clicked', async () => {
      const equipmentSection = wrapper.find('.resource-section'); // Equipment section is the active one
      expect(equipmentSection.exists()).toBe(true);

      const addButton = equipmentSection.find('button.button-primary');
      expect(addButton.exists()).toBe(true);

      await addButton.trigger('click');
      await wrapper.vm.$nextTick();

      expect(wrapper.findComponent({ name: 'AddEquipmentForm' }).exists()).toBe(true);
      // Check if the table is hidden when the form is shown (requires component logic fix)
      expect(equipmentSection.find('table').exists()).toBe(false);
    });
  });

  // Test form submission for adding a new OR
  describe('Form submissions', () => {
    // Note: These tests use a separate wrapper instance to isolate form behavior
    it('adds a new OR when form is submitted', async () => {
      const localPinia = createTestingPinia({
        initialState: {
          resource: INITIAL_STATE,
        },
        stubActions: false, // Keep actions real to test store interaction
      });
      const orStore = useResourceStore(localPinia);

      const fullWrapper = mount(ResourceManagementScreen, {
        global: {
          plugins: [localPinia],
          stubs: {
            AddOrForm: false, // Don't stub the form to test its emission
            AddStaffForm: true,
            AddEquipmentForm: true,
            ConfirmationModal: true,
            ResourceAvailabilityCalendar: true,
          }
        }
      });

      // Wait for initial data load
      await flushPromises();
      await fullWrapper.vm.$nextTick();

      const orSection = fullWrapper.find('.resource-section'); // OR section is the active one
      expect(orSection.exists()).toBe(true);

      // Click Add New OR button to show the form
      await orSection.find('button.button-primary').trigger('click');
      await fullWrapper.vm.$nextTick();

      const addOrForm = fullWrapper.findComponent({ name: 'AddOrForm' });
      expect(addOrForm.exists()).toBe(true);

      // Simulate emitting the save event from the form
      const newOrData = { name: 'OR 3', location: 'South', status: 'Available', primaryService: 'Cardiology' };
      await addOrForm.vm.$emit('save', newOrData);

      // Wait for the store action and DOM updates
      await flushPromises();
      await fullWrapper.vm.$nextTick();

      // Assert that the form is hidden and the new OR is added to the store and table
      expect(fullWrapper.findComponent({ name: 'AddOrForm' }).exists()).toBe(false);
      expect(orStore.operatingRooms.length).toBe(INITIAL_STATE.operatingRooms.length + 1);

      // Wait for the table to update with the new row
      const updatedRowCount = await waitForTableContent(fullWrapper, '.resource-section', INITIAL_STATE.operatingRooms.length + 1);
      expect(updatedRowCount).toBe(INITIAL_STATE.operatingRooms.length + 1);

      // Optionally check if the new row content is correct
      const rows = fullWrapper.find('.resource-section').findAll('tbody tr');
      const newRowCells = rows[rows.length - 1].findAll('td').map(td => td.text());
      expect(newRowCells[0]).toBe(newOrData.name);
      expect(newRowCells[1]).toBe(newOrData.location);
    });

    // Add similar tests for Staff and Equipment form submissions if needed
  });

  // Test deletion confirmation
  describe('Deletion confirmation', () => {
    // Note: These tests use separate wrapper instances to isolate deletion behavior

    // Test OR deletion confirmation
    it('should show confirmation modal on deleting an OR', async () => {
      const localPinia = createTestingPinia({
        initialState: {
          resource: INITIAL_STATE,
        },
        stubActions: false, // Keep actions real to test store interaction
      });
      const orStore = useResourceStore(localPinia);

      const orWrapper = mount(ResourceManagementScreen, {
        global: {
          plugins: [localPinia],
          stubs: {
            AddOrForm: true,
            AddStaffForm: true,
            AddEquipmentForm: true,
            ConfirmationModal: false, // Don't stub modal to test its appearance
            ResourceAvailabilityCalendar: true,
          }
        }
      });

      // Wait for initial data load and rendering
      await flushPromises();
      await orWrapper.vm.$nextTick();

      const orSection = orWrapper.find('.resource-section'); // OR section is the active one
      expect(orSection.exists()).toBe(true);

      // Wait for the OR table content in this specific test context
      const initialRowCount = await waitForTableContent(
        orWrapper,
        '.resource-section',
        orStore.operatingRooms.length,
        5000 // Increased timeout
      );
      expect(initialRowCount).toBeGreaterThan(0); // Ensure there are rows to delete

      const firstRow = orSection.find('tbody tr');
      expect(firstRow.exists()).toBe(true);
      // Find the delete button in the first row
      const deleteButton = firstRow.findAll('button').filter(btn => btn.text() === 'Delete')[0];
      expect(deleteButton.exists()).toBe(true);

      // Click the delete button to open the confirmation modal
      await deleteButton.trigger('click');
      await orWrapper.vm.$nextTick(); // Wait for modal to appear

      // Assert that the confirmation modal is shown
      const confirmationModal = orWrapper.findComponent(ConfirmationModal);
      expect(confirmationModal.exists()).toBe(true);
      expect(confirmationModal.vm.title).toBe('Delete Operating Room?');

      // Simulate confirming the deletion
      await confirmationModal.vm.$emit('confirm');
      await flushPromises(); // Wait for the delete action and state update

      // Assert that the modal is hidden and the item is removed from the table
      expect(orWrapper.findComponent(ConfirmationModal).exists()).toBe(false);
      expect(orSection.find('table').exists()).toBe(true); // Table should still exist

      // Wait for the table to update after deletion
      const updatedRowCount = await waitForTableContent(orWrapper, '.resource-section', initialRowCount - 1);
      expect(updatedRowCount).toBe(initialRowCount - 1);
    });

    // Test Staff deletion confirmation
    describe('Staff deletion confirmation', () => {
      let wrapper;
      let resourceStore;

      beforeEach(async () => {
        const localPinia = createTestingPinia({
          initialState: {
            resource: INITIAL_STATE,
          },
          stubActions: false,
        });
        resourceStore = useResourceStore(localPinia);

        wrapper = mount(ResourceManagementScreen, {
          global: {
            plugins: [localPinia],
            stubs: {
              AddOrForm: true,
              AddStaffForm: true,
              AddEquipmentForm: true,
              ConfirmationModal: false,
              ResourceAvailabilityCalendar: true,
            }
          }
        });

        // Switch to Staff tab
        await wrapper.findAll('.tabs button')[1].trigger('click');
        await wrapper.vm.$nextTick(); // Wait for DOM to update after tab switch
        await flushPromises(); // Ensure all promises are resolved after tab switch

        // Wait for the Staff table rows to appear after tab switch
        const initialRowCount = await waitForTableContent(
          wrapper,
          '.resource-section', // Correct selector for the active section
          resourceStore.staff.length,
          5000 // Increased timeout to 5 seconds
        );
        expect(initialRowCount).toBeGreaterThan(0); // Assert that rows eventually exist
        wrapper.vm.initialRowCount = initialRowCount; // Store initial row count on the wrapper instance
      });

      it('should show confirmation modal on deleting a Staff', async () => {
        // Assuming initial data has at least one Staff member, checked in beforeEach
        const initialRowCount = wrapper.vm.initialRowCount; // Use stored initial row count

        const staffSection = wrapper.find('.resource-section'); // Staff section is the active one
        const firstRow = staffSection.find('tbody tr');
        expect(firstRow.exists()).toBe(true);
        // Find the delete button in the first row
        const deleteButton = firstRow.findAll('button').filter(btn => btn.text() === 'Delete')[0];
        expect(deleteButton.exists()).toBe(true);

        // Click the delete button to open the confirmation modal
        await deleteButton.trigger('click');
        await wrapper.vm.$nextTick(); // Wait for modal to appear

        // Assert that the confirmation modal is shown
        const confirmationModal = wrapper.findComponent(ConfirmationModal);
        expect(confirmationModal.exists()).toBe(true);
        expect(confirmationModal.vm.title).toBe('Delete Staff Member?');

        // Simulate confirming the deletion
        await confirmationModal.vm.$emit('confirm');
        await flushPromises(); // Wait for the delete action and state update

        // Assert that the modal is hidden and the item is removed from the table
        expect(wrapper.findComponent(ConfirmationModal).exists()).toBe(false);
        expect(staffSection.find('table').exists()).toBe(true); // Table should still exist within the section

        // Wait for the table to update after deletion
        const updatedRowCount = await waitForTableContent(wrapper, '.resource-section', initialRowCount - 1);
        expect(updatedRowCount).toBe(initialRowCount - 1);
      });
    });

    // Test Equipment deletion confirmation
    describe('Equipment deletion confirmation', () => {
      let wrapper;
      let resourceStore;

      beforeEach(async () => {
        const localPinia = createTestingPinia({
          initialState: {
            resource: INITIAL_STATE,
          },
          stubActions: false,
        });
        resourceStore = useResourceStore(localPinia);

        wrapper = mount(ResourceManagementScreen, {
          global: {
            plugins: [localPinia],
            stubs: {
              AddOrForm: true,
              AddStaffForm: true,
              AddEquipmentForm: true,
              ConfirmationModal: false,
              ResourceAvailabilityCalendar: true,
            }
          }
        });

        // Switch to Equipment tab
        await wrapper.findAll('.tabs button')[2].trigger('click');
        await wrapper.vm.$nextTick(); // Wait for DOM to update after tab switch
        await flushPromises(); // Ensure all promises are resolved after tab switch

        // Wait for the Equipment table rows to appear after tab switch
        const initialRowCount = await waitForTableContent(
          wrapper,
          '.resource-section', // Correct selector for the active section
          resourceStore.equipment.length,
          5000 // Increased timeout to 5 seconds
        );
        expect(initialRowCount).toBeGreaterThan(0); // Assert that rows eventually exist
        wrapper.vm.initialRowCount = initialRowCount; // Store initial row count on the wrapper instance
      });

      it('should show confirmation modal on deleting an Equipment', async () => {
        // Assuming initial data has at least one Equipment item, checked in beforeEach
        const initialRowCount = wrapper.vm.initialRowCount; // Use stored initial row count

        const equipmentSection = wrapper.find('.resource-section'); // Equipment section is the active one
        const firstRow = equipmentSection.find('tbody tr');
        expect(firstRow.exists()).toBe(true);
        // Find the delete button in the first row
        const deleteButton = firstRow.findAll('button').filter(btn => btn.text() === 'Delete')[0];
        expect(deleteButton.exists()).toBe(true);

        // Click the delete button to open the confirmation modal
        await deleteButton.trigger('click');
        await wrapper.vm.$nextTick(); // Wait for modal to appear

        // Assert that the confirmation modal is shown
        const confirmationModal = wrapper.findComponent(ConfirmationModal);
        expect(confirmationModal.exists()).toBe(true);
        expect(confirmationModal.vm.title).toBe('Delete Equipment?');

        // Simulate confirming the deletion
        await confirmationModal.vm.$emit('confirm');
        await flushPromises(); // Wait for the delete action and state update

        // Assert that the modal is hidden and the item is removed from the table
        expect(wrapper.findComponent(ConfirmationModal).exists()).toBe(false);
        expect(equipmentSection.find('table').exists()).toBe(true); // Table should still exist within the section

        // Wait for the table to update after deletion
        const updatedRowCount = await waitForTableContent(wrapper, '.resource-section', initialRowCount - 1);
        expect(updatedRowCount).toBe(initialRowCount - 1);
      });
    });
  });

  // Test form submission for adding a new OR
});


================================================
FILE: src/components/__tests__/SchedulingScreen.spec.js
================================================
import { mount } from '@vue/test-utils';
import { createPinia } from 'pinia'; // Import createPinia
import SchedulingScreen from '../SchedulingScreen.vue';

describe('SchedulingScreen.vue', () => {
  let pinia; // Declare pinia variable

  beforeEach(() => {
    pinia = createPinia(); // Create a new Pinia instance
  });

  it('renders the main scheduling container', () => {
    const wrapper = mount(SchedulingScreen, {
      global: {
        plugins: [pinia] // Add pinia to plugins
      }
    });
    expect(wrapper.find('.scheduling-container').exists()).toBe(true);
  });

  it('displays the main title "Surgery Scheduling"', () => {
    const wrapper = mount(SchedulingScreen, {
      global: {
        plugins: [pinia] // Add pinia to plugins
      }
    });
    expect(wrapper.find('h1').text()).toBe('Surgery Scheduling');
  });

  // Add more tests here
});


================================================
FILE: src/components/__tests__/SchedulingScreen.test.js
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount, flushPromises } from '@vue/test-utils';
import SchedulingScreen from '../SchedulingScreen.vue';
import { createPinia, setActivePinia } from 'pinia';
import { ref } from 'vue';
import flushPromises from 'flush-promises';

// Mock DataTransfer for JSDOM environment
global.DataTransfer = class DataTransfer {
  constructor() {
    this.data = {};
    this.effectAllowed = 'all';
    this.dropEffect = 'none';
  }

  setData(format, data) {
    this.data[format] = data;
  }

  getData(format) {
    return this.data[format] || '';
  }

  setDragImage() {
    // Mock implementation
  }
};

// Mock the stores
const mockPendingSurgeries = ref([
  {
    id: 1,
    patientId: 'P12345',
    patientName: 'John Doe',
    type: 'CABG',
    fullType: 'Coronary Artery Bypass Graft',
    estimatedDuration: 120,
    priority: 'High',
    status: 'Pending',
    requiredSpecialty: 'Cardiology'
  },
  {
    id: 2,
    patientId: 'P67890',
    patientName: 'Jane Smith',
    type: 'KNEE',
    fullType: 'Knee Replacement',
    estimatedDuration: 90,
    priority: 'Medium',
    status: 'Pending',
    requiredSpecialty: 'Orthopedics'
  }
]);

vi.mock('@/stores/scheduleStore', () => ({
  useScheduleStore: () => ({
    pendingSurgeries: mockPendingSurgeries,
    scheduledSurgeries: ref([]),
    selectedSurgeryId: ref(null),
    isLoading: ref(false),
    loadInitialData: vi.fn()
  })
}));

vi.mock('@/stores/notificationStore', () => ({
  useNotificationStore: () => ({
    addNotification: vi.fn(),
    setToastRef: vi.fn()
  })
}));

// Mock child components
vi.mock('./GanttChart.vue', () => ({
  default: {
    name: 'GanttChart',
    template: '<div data-testid="gantt-chart">Gantt Chart</div>'
  }
}));

vi.mock('./ToastNotification.vue', () => ({
  default: {
    name: 'ToastNotification',
    template: '<div data-testid="toast-notification">Toast</div>'
  }
}));

vi.mock('./KeyboardShortcutsHelp.vue', () => ({
  default: {
    name: 'KeyboardShortcutsHelp',
    template: '<div data-testid="keyboard-shortcuts">Shortcuts</div>'
  }
}));

vi.mock('@/services/keyboardShortcuts', () => ({
  default: {
    init: vi.fn(),
    destroy: vi.fn(),
    register: vi.fn(() => vi.fn()) // Returns an unregister function
  }
}));

// Mock the router
// Remove the mock for SchedulingScreen.vue
// vi.mock('../SchedulingScreen.vue', () => ({...

describe('SchedulingScreen.vue', () => {
  let wrapper;
  let pinia;

  beforeEach(async () => {
    // Create a fresh Pinia instance for each test
    pinia = createPinia();
    setActivePinia(pinia);

    wrapper = mount(SchedulingScreen, {
      global: {
        plugins: [pinia]
      }
    });

    await flushPromises();
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders the main scheduling container', () => {
    expect(wrapper.find('.scheduling-container').exists()).toBe(true);
  });

  it('displays the main title "Surgery Scheduling"', () => {
    expect(wrapper.find('h1').text()).toBe('Surgery Scheduling');
  });

  it('renders all three panels: left, main, and right', () => {
    expect(wrapper.find('.left-panel').exists()).toBe(true);
    expect(wrapper.find('.main-panel').exists()).toBe(true);
    expect(wrapper.find('.right-panel').exists()).toBe(true);
  });

  it('displays pending surgeries in the left panel', async () => {
    await flushPromises();
    const pendingSurgeryItems = wrapper.findAll('.pending-surgery-item');
    expect(pendingSurgeryItems.length).toBe(2); // Based on our mock data

    // Check if the first surgery is displayed correctly
    const firstSurgery = pendingSurgeryItems[0];
    expect(firstSurgery.text()).toContain('P12345');
    expect(firstSurgery.text()).toContain('High');
    expect(firstSurgery.text()).toContain('CABG');
    expect(firstSurgery.text()).toContain('120');
  });

  it('renders filter controls', () => {
    expect(wrapper.find('#filter-priority').exists()).toBe(true);
    expect(wrapper.find('#filter-specialty').exists()).toBe(true);
    expect(wrapper.find('#filter-status').exists()).toBe(true);
  });

  it('filters pending surgeries by priority', async () => {
    // Select 'High' priority filter
    await wrapper.find('#filter-priority').setValue('High');
    await wrapper.vm.$nextTick();

    // Should only show surgeries with 'High' priority
    const filteredItems = wrapper.findAll('.pending-surgery-item');
    expect(filteredItems.length).toBe(1);
    expect(filteredItems[0].text()).toContain('High');
  });

  it('shows advanced filters when toggle is clicked', async () => {
    // Initially advanced filters should not be visible
    expect(wrapper.find('#filter-surgeon').exists()).toBe(false);

    // Click the show advanced button
    const advancedToggle = wrapper.find('button').element.textContent.includes('Show Advanced');
    const toggleButton = wrapper.findAll('button').find(btn =>
      btn.text().includes('Show Advanced')
    );

    if (toggleButton) {
      await toggleButton.trigger('click');
      await wrapper.vm.$nextTick();

      // Advanced filters should now be visible
      expect(wrapper.find('#filter-surgeon').exists()).toBe(true);
      expect(wrapper.find('#filter-equipment').exists()).toBe(true);
    }
  });

  it('selects a surgery for viewing details when clicked', async () => {
    const pendingSurgeryItems = wrapper.findAll('.pending-surgery-item');
    expect(pendingSurgeryItems.length).toBeGreaterThan(0);

    // Click on the first surgery item
    await pendingSurgeryItems[0].trigger('click');
    await wrapper.vm.$nextTick();

    // Check if the right panel shows surgery details
    const rightPanel = wrapper.find('.right-panel');
    expect(rightPanel.exists()).toBe(true);
    expect(rightPanel.text()).toContain('Surgery Details');
  });

  it('renders gantt chart area', () => {
    expect(wrapper.find('#gantt-chart-container').exists()).toBe(true);
    expect(wrapper.find('.gantt-chart-container').exists()).toBe(true);
  });

  it('renders schedule controls', () => {
    expect(wrapper.find('.schedule-controls').exists()).toBe(true);
    expect(wrapper.text()).toContain('Previous');
    expect(wrapper.text()).toContain('Next');
    expect(wrapper.text()).toContain('Day View');
    expect(wrapper.text()).toContain('Week View');
    expect(wrapper.text()).toContain('Create New Surgery');
  });

  it('renders sort controls', () => {
    expect(wrapper.find('.sort-controls').exists()).toBe(true);
    const sortSelect = wrapper.find('.sort-controls select');
    expect(sortSelect.exists()).toBe(true);

    // Check sort options
    expect(wrapper.text()).toContain('Priority');
    expect(wrapper.text()).toContain('Patient Name');
    expect(wrapper.text()).toContain('Surgery Type');
    expect(wrapper.text()).toContain('Duration');
  });

  it('renders create new surgery button', () => {
    const createButton = wrapper.findAll('button').find(btn =>
      btn.text().includes('Create New Surgery')
    );
    expect(createButton.exists()).toBe(true);
  });

  it('renders surgery form fields in right panel', () => {
    expect(wrapper.text()).toContain('Patient ID');
    expect(wrapper.text()).toContain('Patient Name');
    expect(wrapper.text()).toContain('Surgery Type');
    expect(wrapper.text()).toContain('Estimated Duration');
    expect(wrapper.text()).toContain('Priority Level');
  });

  it('renders draggable pending surgery items', () => {
    const pendingSurgeryItems = wrapper.findAll('.pending-surgery-item');
    expect(pendingSurgeryItems.length).toBeGreaterThan(0);

    // Check that items are draggable
    pendingSurgeryItems.forEach(item => {
      expect(item.attributes('draggable')).toBe('true');
    });
  });

  it('renders gantt chart drop area', () => {
    const ganttContainer = wrapper.find('#gantt-chart-container');
    expect(ganttContainer.exists()).toBe(true);
    expect(ganttContainer.attributes('data-drop-message')).toBeDefined();
  });

  it('shows placeholder text when Gantt chart is not initialized', () => {
    const placeholderText = wrapper.find('.gantt-placeholder-text');
    expect(placeholderText.exists()).toBe(true);
    expect(placeholderText.text()).toContain('Gantt Chart Area');
  });

  it('renders child components', () => {
    // Check for component instances since they use Teleport
    expect(wrapper.findComponent({ name: 'ToastNotification' }).exists()).toBe(true);
    expect(wrapper.findComponent({ name: 'KeyboardShortcutsHelp' }).exists()).toBe(true);
  });

  it('renders surgery action buttons', () => {
    const pendingSurgeryItems = wrapper.findAll('.pending-surgery-item');
    if (pendingSurgeryItems.length > 0) {
      const firstItem = pendingSurgeryItems[0];
      expect(firstItem.text()).toContain('View');
      expect(firstItem.text()).toContain('Schedule');
    }
  });

  it('renders SDST information panel', () => {
    expect(wrapper.text()).toContain('SDST (Setup, Disinfection, Sterilization Time)');
    expect(wrapper.text()).toContain('Resource Conflicts');
  });
});


================================================
FILE: src/components/__tests__/SchedulingScreenBasic.test.js
================================================
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import SchedulingScreen from '../SchedulingScreen.vue';

// Create a simplified mock version for testing
const MockSchedulingScreen = {
  name: 'SchedulingScreen',
  template: `
    <div class="scheduling-container">
      <h1>Surgery Scheduling</h1>
      <div class="scheduling-layout">
        <aside class="left-panel"></aside>
        <main class="main-panel"></main>
        <aside class="right-panel"></aside>
      </div>
    </div>
  `
};

describe('SchedulingScreen.vue', () => {
  it('renders the main scheduling container', () => {
    const wrapper = mount(MockSchedulingScreen);
    expect(wrapper.find('.scheduling-container').exists()).toBe(true);
  });

  it('displays the main title "Surgery Scheduling"', () => {
    const wrapper = mount(MockSchedulingScreen);
    expect(wrapper.find('h1').text()).toBe('Surgery Scheduling');
  });

  it('renders all three panels: left, main, and right', () => {
    const wrapper = mount(MockSchedulingScreen);
    expect(wrapper.find('.left-panel').exists()).toBe(true);
    expect(wrapper.find('.main-panel').exists()).toBe(true);
    expect(wrapper.find('.right-panel').exists()).toBe(true);
  });
});


================================================
FILE: src/components/__tests__/ToastNotification.test.js
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { nextTick } from 'vue';
import ToastNotification from '../ToastNotification.vue';

describe('ToastNotification', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(ToastNotification, {
      global: {
        config: {
          globalProperties: {
            // Mock any global properties if needed
          }
        }
      }
    });
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  it('renders correctly with no toasts initially', () => {
    expect(wrapper.exists()).toBe(true);
    // Since the component uses Teleport to body, check the document body
    const toastContainer = document.querySelector('.toast-container');
    expect(toastContainer).toBeTruthy();
    expect(document.querySelectorAll('.toast')).toHaveLength(0);
  });

  it('adds a basic toast notification', async () => {
    const toast = {
      type: 'info',
      message: 'Test message'
    };

    wrapper.vm.addToast(toast);
    await nextTick();

    const toastElements = document.querySelectorAll('.toast');
    expect(toastElements).toHaveLength(1);
    expect(toastElements[0].classList.contains('toast-info')).toBe(true);
    expect(toastElements[0].textContent).toContain('Test message');
  });

  it('adds toast with title', async () => {
    const toast = {
      type: 'success',
      title: 'Success!',
      message: 'Operation completed successfully'
    };

    wrapper.vm.addToast(toast);
    await nextTick();

    const toastElement = document.querySelector('.toast');
    expect(toastElement.querySelector('.toast-title').textContent).toBe('Success!');
    expect(toastElement.querySelector('.toast-message').textContent).toBe('Operation completed successfully');
    expect(toastElement.classList.contains('toast-success')).toBe(true);
  });

  it('displays correct icons for different toast types', async () => {
    const toastTypes = [
      { type: 'success', icon: '✓' },
      { type: 'error', icon: '✕' },
      { type: 'warning', icon: '⚠' },
      { type: 'info', icon: 'ℹ' }
    ];

    for (const { type, icon } of toastTypes) {
      wrapper.vm.addToast({ type, message: `${type} message` });
      await nextTick();

      const toastElements = document.querySelectorAll('.toast');
      const toastElement = toastElements[toastElements.length - 1];
      expect(toastElement.querySelector('.toast-icon').textContent).toBe(icon);
      expect(toastElement.classList.contains(`toast-${type}`)).toBe(true);
    }
  });

  it('dismisses toast when close button is clicked', async () => {
    wrapper.vm.addToast({ message: 'Test message' });
    await nextTick();

    expect(document.querySelectorAll('.toast')).toHaveLength(1);

    const closeButton = document.querySelector('.toast-close');
    closeButton.click();
    await nextTick();

    expect(document.querySelectorAll('.toast')).toHaveLength(0);
  });

  it('adds toast with action button', async () => {
    const actionCallback = vi.fn();
    const toast = {
      type: 'warning',
      message: 'Action required',
      action: {
        label: 'Retry',
        callback: actionCallback
      }
    };

    wrapper.vm.addToast(toast);
    await nextTick();

    const toastElement = document.querySelector('.toast');
    expect(toastElement.classList.contains('with-action')).toBe(true);

    const actionButton = toastElement.querySelector('.toast-action');
    expect(actionButton).toBeTruthy();
    expect(actionButton.textContent).toBe('Retry');
    expect(actionButton.getAttribute('aria-label')).toBe('Retry');

    actionButton.click();
    expect(actionCallback).toHaveBeenCalled();
  });

  it('auto-dismisses toast after specified duration', async () => {
    vi.useFakeTimers();

    wrapper.vm.addToast({
      message: 'Auto dismiss test',
      duration: 1000
    });
    await nextTick();

    expect(document.querySelectorAll('.toast')).toHaveLength(1);

    // Fast-forward time by 1000ms
    vi.advanceTimersByTime(1000);
    await nextTick();

    expect(document.querySelectorAll('.toast')).toHaveLength(0);

    vi.useRealTimers();
  });

  it('does not auto-dismiss toast with duration 0', async () => {
    // Don't use fake timers for this test to avoid interference
    const id = wrapper.vm.addToast({
      message: 'Persistent toast',
      duration: 0
    });
    await nextTick();

    expect(document.querySelectorAll('.toast')).toHaveLength(1);

    // Check that no timeout was set for this toast
    expect(wrapper.vm.toastTimeouts[id]).toBeUndefined();

    // Verify the toast is still in the component state
    expect(wrapper.vm.toasts.some(t => t.id === id)).toBe(true);
  });

  it('dismisses specific toast by ID', async () => {
    const id1 = wrapper.vm.addToast({ message: 'First toast' });
    const id2 = wrapper.vm.addToast({ message: 'Second toast' });
    await nextTick();

    expect(document.querySelectorAll('.toast')).toHaveLength(2);

    wrapper.vm.dismissToast(id1);
    await nextTick();

    const remainingToasts = document.querySelectorAll('.toast');
    expect(remainingToasts).toHaveLength(1);
    expect(remainingToasts[0].textContent).toContain('Second toast');
  });

  it('handles multiple toasts correctly', async () => {
    const toasts = [
      { type: 'info', message: 'Info message' },
      { type: 'success', message: 'Success message' },
      { type: 'error', message: 'Error message' }
    ];

    toasts.forEach(toast => wrapper.vm.addToast(toast));
    await nextTick();

    const toastElements = document.querySelectorAll('.toast');
    expect(toastElements).toHaveLength(3);

    toasts.forEach((toast, index) => {
      expect(toastElements[index].textContent).toContain(toast.message);
      expect(toastElements[index].classList.contains(`toast-${toast.type}`)).toBe(true);
    });
  });

  it('has proper accessibility attributes', async () => {
    wrapper.vm.addToast({
      message: 'Accessible toast',
      action: { label: 'Action', callback: vi.fn() }
    });
    await nextTick();

    const toastElement = document.querySelector('.toast');
    expect(toastElement.getAttribute('role')).toBe('alert');
    expect(toastElement.getAttribute('aria-live')).toBe('assertive');

    const closeButton = toastElement.querySelector('.toast-close');
    expect(closeButton.getAttribute('aria-label')).toBe('Close notification');

    const actionButton = toastElement.querySelector('.toast-action');
    expect(actionButton.getAttribute('aria-label')).toBe('Action');
  });

  it('cleans up timeouts on unmount', async () => {
    vi.useFakeTimers();
    const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');

    wrapper.vm.addToast({ message: 'Test', duration: 5000 });
    await nextTick();

    wrapper.unmount();

    expect(clearTimeoutSpy).toHaveBeenCalled();

    vi.useRealTimers();
    clearTimeoutSpy.mockRestore();
  });

  it('returns unique IDs for each toast', async () => {
    const id1 = wrapper.vm.addToast({ message: 'First' });
    await nextTick();
    const id2 = wrapper.vm.addToast({ message: 'Second' });
    await nextTick();

    expect(id1).toBeDefined();
    expect(id2).toBeDefined();
    expect(id1).not.toBe(id2);
    expect(typeof id1).toBe('string');
    expect(typeof id2).toBe('string');
  });

  it('uses default values for missing properties', async () => {
    wrapper.vm.addToast({ message: 'Minimal toast' });
    await nextTick();

    const toastElement = document.querySelector('.toast');
    expect(toastElement.classList.contains('toast-info')).toBe(true); // Default type
    expect(toastElement.querySelector('.toast-title')).toBeFalsy(); // No title
    expect(toastElement.querySelector('.toast-action')).toBeFalsy(); // No action
  });
});



================================================
FILE: src/components/__tests__/__snapshots__/AddEditInitialSetupModal.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddEditInitialSetupModal > matches snapshot in add mode 1`] = `
"<div data-v-60ea9dff="" class="modal-overlay">
  <div data-v-60ea9dff="" class="modal-content">
    <h3 data-v-60ea9dff="">Add New Initial Setup Time</h3>
    <form data-v-60ea9dff="">
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-type">Surgery Type</label><!-- Dropdown to select surgery type -->
        <!-- This dropdown should be populated by surgery types passed from the parent --><select data-v-60ea9dff="" id="setup-type" required="">
          <!-- Disable type selection when editing -->
          <option data-v-60ea9dff="" value="">Select Surgery Type</option><!-- Options will be populated via v-for on a prop -->
          <option data-v-60ea9dff="" value="1">Surgery Type A</option>
          <option data-v-60ea9dff="" value="2">Surgery Type B</option>
        </select>
        <!--v-if-->
      </div>
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-time">Initial Setup Time (minutes)</label><input data-v-60ea9dff="" type="number" id="setup-time" required="" min="0"></div>
      <div data-v-60ea9dff="" class="form-actions"><button data-v-60ea9dff="" type="submit" class="button-primary">Add Setup Time</button><button data-v-60ea9dff="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;

exports[`AddEditInitialSetupModal > matches snapshot in edit mode 1`] = `
"<div data-v-60ea9dff="" class="modal-overlay">
  <div data-v-60ea9dff="" class="modal-content">
    <h3 data-v-60ea9dff="">Edit Initial Setup Time</h3>
    <form data-v-60ea9dff="">
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-type">Surgery Type</label><!-- Dropdown to select surgery type -->
        <!-- This dropdown should be populated by surgery types passed from the parent --><select data-v-60ea9dff="" id="setup-type" required="" disabled="">
          <!-- Disable type selection when editing -->
          <option data-v-60ea9dff="" value="">Select Surgery Type</option><!-- Options will be populated via v-for on a prop -->
          <option data-v-60ea9dff="" value="1">Surgery Type A</option>
          <option data-v-60ea9dff="" value="2">Surgery Type B</option>
        </select><small data-v-60ea9dff="">Cannot change Surgery Type when editing.</small>
      </div>
      <div data-v-60ea9dff="" class="input-group"><label data-v-60ea9dff="" for="setup-time">Initial Setup Time (minutes)</label><input data-v-60ea9dff="" type="number" id="setup-time" required="" min="0"></div>
      <div data-v-60ea9dff="" class="form-actions"><button data-v-60ea9dff="" type="submit" class="button-primary">Save Changes</button><button data-v-60ea9dff="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/AddEditSurgeryTypeModal.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddEditSurgeryTypeModal > matches snapshot in add mode 1`] = `
"<div data-v-09ed78bd="" class="modal-overlay">
  <div data-v-09ed78bd="" class="modal-content">
    <h3 data-v-09ed78bd="">Add New Surgery Type</h3>
    <form data-v-09ed78bd="">
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-name">Name</label><input data-v-09ed78bd="" type="text" id="type-name" required=""></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-code">Code (e.g., CABG, TKR)</label><input data-v-09ed78bd="" type="text" id="type-code"></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-description">Description</label><textarea data-v-09ed78bd="" id="type-description"></textarea></div>
      <div data-v-09ed78bd="" class="form-actions"><button data-v-09ed78bd="" type="submit" class="button-primary">Add Type</button><button data-v-09ed78bd="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;

exports[`AddEditSurgeryTypeModal > matches snapshot in edit mode 1`] = `
"<div data-v-09ed78bd="" class="modal-overlay">
  <div data-v-09ed78bd="" class="modal-content">
    <h3 data-v-09ed78bd="">Edit Surgery Type</h3>
    <form data-v-09ed78bd="">
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-name">Name</label><input data-v-09ed78bd="" type="text" id="type-name" required=""></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-code">Code (e.g., CABG, TKR)</label><input data-v-09ed78bd="" type="text" id="type-code"></div>
      <div data-v-09ed78bd="" class="input-group"><label data-v-09ed78bd="" for="type-description">Description</label><textarea data-v-09ed78bd="" id="type-description"></textarea></div>
      <div data-v-09ed78bd="" class="form-actions"><button data-v-09ed78bd="" type="submit" class="button-primary">Save Changes</button><button data-v-09ed78bd="" type="button" class="button-secondary">Cancel</button></div>
    </form>
  </div>
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/AddEquipmentForm.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddEquipmentForm > matches snapshot in add mode 1`] = `
"<div data-v-509ecb30="" class="add-equipment-form">
  <h3 data-v-509ecb30="">Add New Equipment</h3>
  <form data-v-509ecb30="">
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-name">Name/ID</label><input data-v-509ecb30="" type="text" id="equipment-name">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-type">Type</label><input data-v-509ecb30="" type="text" id="equipment-type">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-status">Status</label><select data-v-509ecb30="" id="equipment-status">
        <option value="" data-v-509ecb30="">Select Status</option>
        <option value="Available" data-v-509ecb30="">Available</option>
        <option value="In Use" data-v-509ecb30="">In Use</option>
        <option value="Maintenance" data-v-509ecb30="">Maintenance</option>
        <option value="Retired" data-v-509ecb30="">Retired</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-location">Location</label><input data-v-509ecb30="" type="text" id="equipment-location"><small data-v-509ecb30="">E.g., OR 5, Storage Room B</small><!-- Location is optional, so no specific validation message for being empty -->
    </div>
    <div data-v-509ecb30="" class="form-actions"><button data-v-509ecb30="" type="submit" class="button-primary">Save Equipment</button><button data-v-509ecb30="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;

exports[`AddEquipmentForm > matches snapshot in edit mode 1`] = `
"<div data-v-509ecb30="" class="add-equipment-form">
  <h3 data-v-509ecb30="">Edit Equipment</h3>
  <form data-v-509ecb30="">
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-name">Name/ID</label><input data-v-509ecb30="" type="text" id="equipment-name">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-type">Type</label><input data-v-509ecb30="" type="text" id="equipment-type">
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-status">Status</label><select data-v-509ecb30="" id="equipment-status">
        <option value="" data-v-509ecb30="">Select Status</option>
        <option value="Available" data-v-509ecb30="">Available</option>
        <option value="In Use" data-v-509ecb30="">In Use</option>
        <option value="Maintenance" data-v-509ecb30="">Maintenance</option>
        <option value="Retired" data-v-509ecb30="">Retired</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-509ecb30="" class="input-group"><label data-v-509ecb30="" for="equipment-location">Location</label><input data-v-509ecb30="" type="text" id="equipment-location"><small data-v-509ecb30="">E.g., OR 5, Storage Room B</small><!-- Location is optional, so no specific validation message for being empty -->
    </div>
    <div data-v-509ecb30="" class="form-actions"><button data-v-509ecb30="" type="submit" class="button-primary">Update Equipment</button><button data-v-509ecb30="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/AddOrForm.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddOrForm > matches snapshot in add mode 1`] = `
"<div data-v-4b031d55="" class="add-or-form">
  <h3 data-v-4b031d55="">Add New Operating Room</h3>
  <form data-v-4b031d55="">
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-name">Name/ID</label><input data-v-4b031d55="" type="text" id="or-name">
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-location">Location</label><input data-v-4b031d55="" type="text" id="or-location"><!-- No validation for location in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-status">Status</label><select data-v-4b031d55="" id="or-status">
        <option data-v-4b031d55="" value="">Select Status</option>
        <option data-v-4b031d55="" value="Active">Active</option>
        <option data-v-4b031d55="" value="Under Maintenance">Under Maintenance</option>
        <option data-v-4b031d55="" value="Inactive">Inactive</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-service">Primary Service</label><input data-v-4b031d55="" type="text" id="or-service"><!-- No validation for primary service in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="form-actions"><button data-v-4b031d55="" type="submit" class="button-primary">Save OR</button><button data-v-4b031d55="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;

exports[`AddOrForm > matches snapshot in edit mode 1`] = `
"<div data-v-4b031d55="" class="add-or-form">
  <h3 data-v-4b031d55="">Edit Operating Room</h3>
  <form data-v-4b031d55="">
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-name">Name/ID</label><input data-v-4b031d55="" type="text" id="or-name">
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-location">Location</label><input data-v-4b031d55="" type="text" id="or-location"><!-- No validation for location in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-status">Status</label><select data-v-4b031d55="" id="or-status">
        <option data-v-4b031d55="" value="">Select Status</option>
        <option data-v-4b031d55="" value="Active">Active</option>
        <option data-v-4b031d55="" value="Under Maintenance">Under Maintenance</option>
        <option data-v-4b031d55="" value="Inactive">Inactive</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-4b031d55="" class="input-group"><label data-v-4b031d55="" for="or-service">Primary Service</label><input data-v-4b031d55="" type="text" id="or-service"><!-- No validation for primary service in this example, but can be added -->
    </div>
    <div data-v-4b031d55="" class="form-actions"><button data-v-4b031d55="" type="submit" class="button-primary">Update OR</button><button data-v-4b031d55="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/AddStaffForm.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AddStaffForm > matches snapshot in add mode 1`] = `
"<div data-v-7c00223e="" class="add-staff-form">
  <h3 data-v-7c00223e="">Add New Staff Member</h3>
  <form data-v-7c00223e="">
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-name">Name</label><input data-v-7c00223e="" type="text" id="staff-name">
      <!--v-if-->
    </div>
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-role">Role</label><select data-v-7c00223e="" id="staff-role">
        <option value="" data-v-7c00223e="">Select Role</option>
        <option value="Surgeon" data-v-7c00223e="">Surgeon</option>
        <option value="Nurse" data-v-7c00223e="">Nurse</option>
        <option value="Anesthetist" data-v-7c00223e="">Anesthetist</option>
        <option value="Other" data-v-7c00223e="">Other</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-specializations">Specialization(s)</label><input data-v-7c00223e="" type="text" id="staff-specializations"><small data-v-7c00223e="">Enter specializations separated by commas (e.g., Orthopedics, Sports Medicine)</small><!-- Basic validation for specializations can be added if it becomes a strict requirement -->
    </div>
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-status">Status</label><select data-v-7c00223e="" id="staff-status">
        <option data-v-7c00223e="" value="">Select Status</option>
        <option data-v-7c00223e="" value="Active">Active</option>
        <option data-v-7c00223e="" value="On Leave">On Leave</option>
        <option data-v-7c00223e="" value="Inactive">Inactive</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-7c00223e="" class="form-actions"><button data-v-7c00223e="" type="submit" class="button-primary">Save Staff</button><button data-v-7c00223e="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;

exports[`AddStaffForm > matches snapshot in edit mode 1`] = `
"<div data-v-7c00223e="" class="add-staff-form">
  <h3 data-v-7c00223e="">Edit Staff Member</h3>
  <form data-v-7c00223e="">
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-name">Name</label><input data-v-7c00223e="" type="text" id="staff-name">
      <!--v-if-->
    </div>
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-role">Role</label><select data-v-7c00223e="" id="staff-role">
        <option value="" data-v-7c00223e="">Select Role</option>
        <option value="Surgeon" data-v-7c00223e="">Surgeon</option>
        <option value="Nurse" data-v-7c00223e="">Nurse</option>
        <option value="Anesthetist" data-v-7c00223e="">Anesthetist</option>
        <option value="Other" data-v-7c00223e="">Other</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-specializations">Specialization(s)</label><input data-v-7c00223e="" type="text" id="staff-specializations"><small data-v-7c00223e="">Enter specializations separated by commas (e.g., Orthopedics, Sports Medicine)</small><!-- Basic validation for specializations can be added if it becomes a strict requirement -->
    </div>
    <div data-v-7c00223e="" class="input-group"><label data-v-7c00223e="" for="staff-status">Status</label><select data-v-7c00223e="" id="staff-status">
        <option data-v-7c00223e="" value="">Select Status</option>
        <option data-v-7c00223e="" value="Active">Active</option>
        <option data-v-7c00223e="" value="On Leave">On Leave</option>
        <option data-v-7c00223e="" value="Inactive">Inactive</option>
      </select>
      <!--v-if-->
    </div>
    <div data-v-7c00223e="" class="form-actions"><button data-v-7c00223e="" type="submit" class="button-primary">Update Staff</button><button data-v-7c00223e="" type="button" class="button-secondary">Cancel</button></div>
  </form>
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/AdministrationScreen.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AdministrationScreen > matches snapshot 1`] = `
"<div data-v-eaf6c11d="" class="section-container">
  <h1 data-v-eaf6c11d="">Administration</h1>
  <div data-v-eaf6c11d="" class="admin-sections">
    <!-- Placeholder navigation for different admin sections -->
    <p data-v-eaf6c11d="">Admin sections placeholder:</p><button data-v-eaf6c11d="">User Management</button><button data-v-eaf6c11d="">Role Management</button><button data-v-eaf6c11d="">System Settings</button>
  </div>
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/AppLayout.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AppLayout > matches snapshot 1`] = `
"<div data-v-6f6437fc="" class="app-layout">
  <header data-v-6f6437fc="" class="top-nav-bar">
    <div data-v-6f6437fc="" class="app-brand"><button data-v-6f6437fc="" class="icon-button toggle-sidebar-button">
        <!-- Hamburger or arrow icon -->
        <!-- Right arrow --><span data-v-6f6437fc="">◄</span><!-- Left arrow -->
      </button><!-- App Logo/Name --><img data-v-6f6437fc="" src="data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20aria-hidden='true'%20role='img'%20class='iconify%20iconify--logos'%20width='31.88'%20height='32'%20preserveAspectRatio='xMidYMid%20meet'%20viewBox='0%200%20256%20257'%3e%3cdefs%3e%3clinearGradient%20id='IconifyId1813088fe1fbc01fb466'%20x1='-.828%25'%20x2='57.636%25'%20y1='7.652%25'%20y2='78.411%25'%3e%3cstop%20offset='0%25'%20stop-color='%2341D1FF'%3e%3c/stop%3e%3cstop%20offset='100%25'%20stop-color='%23BD34FE'%3e%3c/stop%3e%3c/linearGradient%3e%3clinearGradient%20id='IconifyId1813088fe1fbc01fb467'%20x1='43.376%25'%20x2='50.316%25'%20y1='2.242%25'%20y2='89.03%25'%3e%3cstop%20offset='0%25'%20stop-color='%23FFEA83'%3e%3c/stop%3e%3cstop%20offset='8.333%25'%20stop-color='%23FFDD35'%3e%3c/stop%3e%3cstop%20offset='100%25'%20stop-color='%23FFA800'%3e%3c/stop%3e%3c/linearGradient%3e%3c/defs%3e%3cpath%20fill='url(%23IconifyId1813088fe1fbc01fb466)'%20d='M255.153%2037.938L134.897%20252.976c-2.483%204.44-8.862%204.466-11.382.048L.875%2037.958c-2.746-4.814%201.371-10.646%206.827-9.67l120.385%2021.517a6.537%206.537%200%200%200%202.322-.004l117.867-21.483c5.438-.991%209.574%204.796%206.877%209.62Z'%3e%3c/path%3e%3cpath%20fill='url(%23IconifyId1813088fe1fbc01fb467)'%20d='M185.432.063L96.44%2017.501a3.268%203.268%200%200%200-2.634%203.014l-5.474%2092.456a3.268%203.268%200%200%200%203.997%203.378l24.777-5.718c2.318-.535%204.413%201.507%203.936%203.838l-7.361%2036.047c-.495%202.426%201.782%204.5%204.151%203.78l15.304-4.649c2.372-.72%204.652%201.36%204.15%203.788l-11.698%2056.621c-.732%203.542%203.979%205.473%205.943%202.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505%204.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z'%3e%3c/path%3e%3c/svg%3e" alt="App Logo" class="app-logo-small"><!-- Assuming vite.svg is in public folder --><span data-v-6f6437fc="">Surgery Scheduler</span></div>
    <div data-v-6f6437fc="" class="global-search">
      <!-- Global Search Bar --><input data-v-6f6437fc="" type="text" placeholder="Search...">
    </div>
    <div data-v-6f6437fc="" class="user-utilities">
      <!-- Notification Icon --><button data-v-6f6437fc="" class="icon-button">🔔</button><!-- User Profile Dropdown -->
      <div data-v-6f6437fc="" class="user-profile"><span data-v-6f6437fc="">User Name</span><!-- This should be dynamic later -->
        <!-- Dropdown icon/button here -->
      </div>
    </div>
  </header>
  <aside data-v-6f6437fc="" class="left-sidebar">
    <!-- Navigation Links -->
    <nav data-v-6f6437fc="">
      <ul data-v-6f6437fc="">
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/dashboard"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/scheduling"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/resource-management"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/sdst-data-management"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/reporting-analytics"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/notifications"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/administration"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/patient-management"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/my-profile-settings"></router-link-stub>
        </li>
        <li data-v-6f6437fc="">
          <router-link-stub data-v-6f6437fc="" to="/help-documentation"></router-link-stub>
        </li>
        <li data-v-6f6437fc="" class="logout-item"><button data-v-6f6437fc="" class="logout-button"><span data-v-6f6437fc="" class="nav-icon">🚪</span><span data-v-6f6437fc="" class="nav-text">Logout</span></button></li>
      </ul>
    </nav>
  </aside>
  <main data-v-6f6437fc="" class="main-content">
    <!-- Router View renders the specific page component -->
    <router-view-stub data-v-6f6437fc=""></router-view-stub>
  </main><!-- Toast notifications are typically triggered programmatically, not placed as a component here -->
  <!-- Toasts will be rendered by the plugin at the root level -->
</div>"
`;



================================================
FILE: src/components/__tests__/__snapshots__/ConfirmationModal.test.js.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ConfirmationModal > matches snapshot when shown 1`] = `
"<div data-v-67e05d21="" class="modal-overlay">
  <div data-v-67e05d21="" class="modal-content">
    <h3 data-v-67e05d21="">Test Title</h3>
    <div data-v-67e05d21="" class="modal-body">
      <p data-v-67e05d21="">Test Message</p>
    </div>
    <div data-v-67e05d21="" class="form-actions"><button data-v-67e05d21="" type="button" class="button-danger">Confirm</button><button data-v-67e05d21="" type="button" class="button-secondary">Cancel</button></div>
  </div>
</div>"
`;



================================================
FILE: src/router/index.js
================================================
import { createRouter, createWebHistory } from 'vue-router';
// import { ref } from 'vue'; // No longer needed as auth state is in Pinia store

import LoginScreen from '../components/LoginScreen.vue';
import AppLayout from '../components/AppLayout.vue';
import DashboardScreen from '../components/DashboardScreen.vue';
// Import other placeholder components
import SchedulingScreen from '../components/SchedulingScreen.vue';
import ResourceManagementScreen from '../components/ResourceManagementScreen.vue';
import SDSTManagementScreen from '../components/SDSTManagementScreen.vue';
import ReportingAnalyticsScreen from '../components/ReportingAnalyticsScreen.vue';
import AnalyticsDashboard from '../components/AnalyticsDashboard.vue';
import UtilizationReports from '../components/UtilizationReports.vue';
import SchedulingEfficiencyReports from '../components/SchedulingEfficiencyReports.vue';
import CustomReportBuilder from '../components/CustomReportBuilder.vue';
import NotificationsScreen from '../components/NotificationsScreen.vue';
import AdministrationScreen from '../components/AdministrationScreen.vue';
import MyProfileSettingsScreen from '../components/MyProfileSettingsScreen.vue';
import HelpDocumentationScreen from '../components/HelpDocumentationScreen.vue';
import NotFound from '../components/NotFound.vue';

// Import the authentication store
import { useAuthStore } from '@/stores/authStore';

// Simple authentication state (for simulation) - REMOVED, using authStore instead
// const isAuthenticated = ref(false);

// Function to set authentication status - REMOVED, authStore handles this
// const setAuthenticated = (status) => {
//   isAuthenticated.value = status;
// };

const routes = [
  {
    path: '/',
    name: 'Login',
    component: LoginScreen,
  },
  {
    path: '/', // Use a parent route for authenticated sections
    component: AppLayout, // Use the layout component
    meta: { requiresAuth: true }, // Apply auth guard to this parent route
    children: [
        {
            path: '/dashboard',
            name: 'Dashboard',
            component: DashboardScreen,
        },
        {
            path: '/scheduling',
            name: 'Scheduling',
            component: SchedulingScreen,
        },
        {
            path: '/resource-management',
            name: 'ResourceManagement',
            component: ResourceManagementScreen,
        },
        {
            path: '/sdst-data-management',
            name: 'SDSTDataManagement',
            component: SDSTManagementScreen,
        },
        {
            path: '/reporting-analytics',
            component: ReportingAnalyticsScreen,
            children: [
                {
                    path: '',
                    name: 'AnalyticsDashboard',
                    component: AnalyticsDashboard,
                },
                {
                    path: 'utilization',
                    name: 'UtilizationReports',
                    component: UtilizationReports,
                },
                {
                    path: 'efficiency',
                    name: 'SchedulingEfficiencyReports',
                    component: SchedulingEfficiencyReports,
                },
                {
                    path: 'custom',
                    name: 'CustomReportBuilder',
                    component: CustomReportBuilder,
                },
            ],
        },
        {
            path: '/notifications',
            name: 'Notifications',
            component: NotificationsScreen,
        },
        {
            path: '/administration',
            name: 'Administration',
            component: AdministrationScreen,
        },
        {
            path: '/my-profile-settings',
            name: 'MyProfileSettings',
            component: MyProfileSettingsScreen,
        },
        {
            path: '/help-documentation',
            name: 'HelpDocumentation',
            component: HelpDocumentationScreen,
        },
         // Add a redirect for the base authenticated path if needed
        {
            path: '',
            redirect: '/dashboard' // Redirect / to /dashboard when authenticated
        }
    ]
  },
  // Add a catch-all route for 404s if needed
  {
    path: '/:pathMatch(.*)*', // Catch-all route
    name: 'NotFound',
    component: NotFound
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Navigation guard
router.beforeEach((to, from, next) => {
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  // Use the auth store to check authentication status
  const authStore = useAuthStore(); // Get store instance inside the guard

  if (requiresAuth && !authStore.isAuthenticated) {
    // User is not authenticated and route requires auth, redirect to login
    next({ name: 'Login', query: { redirect: to.fullPath } });
  } else if (to.name === 'Login' && authStore.isAuthenticated) {
    // If the user is authenticated and tries to go to login, redirect to dashboard
     next({ name: 'Dashboard' });
  }else {
    // Otherwise, allow navigation
    next();
  }
});

// export { setAuthenticated }; // REMOVED, authStore handles setting auth state

export default router;



================================================
FILE: src/services/keyboardShortcuts.js
================================================
// Keyboard Shortcuts Service
// This service manages keyboard shortcuts for the application

class KeyboardShortcutsService {
  constructor() {
    this.shortcuts = new Map();
    this.isListening = false;
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }

  // Register a keyboard shortcut
  register(key, callback, options = {}) {
    const shortcut = {
      key: key.toLowerCase(),
      callback,
      ctrlKey: options.ctrlKey || false,
      altKey: options.altKey || false,
      shiftKey: options.shiftKey || false,
      metaKey: options.metaKey || false,
      description: options.description || '',
      scope: options.scope || 'global',
      disabled: options.disabled || false
    };

    // Create a unique ID for this shortcut
    const id = this.getShortcutId(shortcut);
    this.shortcuts.set(id, shortcut);

    // Start listening if not already
    if (!this.isListening) {
      this.startListening();
    }

    // Return a function to unregister this shortcut
    return () => this.unregister(id);
  }

  // Unregister a keyboard shortcut
  unregister(id) {
    this.shortcuts.delete(id);
    
    // Stop listening if no shortcuts remain
    if (this.shortcuts.size === 0) {
      this.stopListening();
    }
  }

  // Enable a shortcut
  enable(id) {
    const shortcut = this.shortcuts.get(id);
    if (shortcut) {
      shortcut.disabled = false;
    }
  }

  // Disable a shortcut
  disable(id) {
    const shortcut = this.shortcuts.get(id);
    if (shortcut) {
      shortcut.disabled = true;
    }
  }

  // Start listening for keyboard events
  startListening() {
    if (!this.isListening) {
      document.addEventListener('keydown', this.handleKeyDown);
      this.isListening = true;
    }
  }

  // Stop listening for keyboard events
  stopListening() {
    document.removeEventListener('keydown', this.handleKeyDown);
    this.isListening = false;
  }

  // Handle keydown events
  handleKeyDown(event) {
    // Skip if the event target is an input, textarea, or select
    if (this.shouldIgnoreEvent(event)) {
      return;
    }

    // Check if any registered shortcut matches this event
    for (const [id, shortcut] of this.shortcuts.entries()) {
      if (this.matchesShortcut(event, shortcut) && !shortcut.disabled) {
        event.preventDefault();
        shortcut.callback(event);
        break;
      }
    }
  }

  // Check if an event should be ignored (e.g., when typing in an input field)
  shouldIgnoreEvent(event) {
    const target = event.target;
    const tagName = target.tagName.toLowerCase();
    
    // Ignore if target is an input, textarea, or select
    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
      return true;
    }
    
    // Ignore if target has contentEditable attribute
    if (target.isContentEditable) {
      return true;
    }
    
    return false;
  }

  // Check if an event matches a shortcut
  matchesShortcut(event, shortcut) {
    const key = event.key.toLowerCase();
    
    return (
      key === shortcut.key &&
      event.ctrlKey === shortcut.ctrlKey &&
      event.altKey === shortcut.altKey &&
      event.shiftKey === shortcut.shiftKey &&
      event.metaKey === shortcut.metaKey
    );
  }

  // Get a unique ID for a shortcut
  getShortcutId(shortcut) {
    return `${shortcut.key}_${shortcut.ctrlKey}_${shortcut.altKey}_${shortcut.shiftKey}_${shortcut.metaKey}_${shortcut.scope}`;
  }

  // Get all registered shortcuts
  getShortcuts() {
    return Array.from(this.shortcuts.values());
  }

  // Get shortcuts for a specific scope
  getShortcutsForScope(scope) {
    return Array.from(this.shortcuts.values())
      .filter(shortcut => shortcut.scope === scope);
  }
}

// Create a singleton instance
const keyboardShortcuts = new KeyboardShortcutsService();

export default keyboardShortcuts;



================================================
FILE: src/stores/analyticsStore.js
================================================
import { defineStore } from 'pinia';
import { useScheduleStore } from './scheduleStore';
import { useResourceStore } from './resourceStore';

export const useAnalyticsStore = defineStore('analytics', {
  state: () => ({
    isLoading: false,
    error: null,
    
    // Date range for analytics
    dateRange: {
      start: new Date(new Date().setDate(new Date().getDate() - 30)), // Default to last 30 days
      end: new Date(),
    },
    
    // Cached analytics data
    cachedData: {
      orUtilization: null,
      surgeonUtilization: null,
      surgeryTypeDistribution: null,
      sdstEfficiency: null,
      dailyMetrics: null,
    },
    
    // Custom report configurations
    savedReports: [
      {
        id: 'report-1',
        name: 'Monthly OR Utilization',
        type: 'orUtilization',
        dateRange: { 
          start: new Date(new Date().setMonth(new Date().getMonth() - 1)), 
          end: new Date() 
        },
        filters: { orIds: ['OR1', 'OR2', 'OR3'] },
        metrics: ['utilizationRate', 'idleTime', 'overtimeRate'],
        chartType: 'bar',
      },
      {
        id: 'report-2',
        name: 'Surgeon Performance',
        type: 'surgeonUtilization',
        dateRange: { 
          start: new Date(new Date().setMonth(new Date().getMonth() - 3)), 
          end: new Date() 
        },
        filters: { surgeonIds: ['SG1', 'SG2', 'SG3'] },
        metrics: ['surgeryCount', 'averageDuration', 'onTimeStart'],
        chartType: 'line',
      },
    ],
  }),
  
  getters: {
    // Get the schedule and resource stores
    scheduleStore: () => useScheduleStore(),
    resourceStore: () => useResourceStore(),
    
    // Get OR utilization data
    orUtilization: (state) => {
      if (state.cachedData.orUtilization) {
        return state.cachedData.orUtilization;
      }
      
      // If not cached, calculate it (this would normally be fetched from an API)
      return null;
    },
    
    // Get surgeon utilization data
    surgeonUtilization: (state) => {
      if (state.cachedData.surgeonUtilization) {
        return state.cachedData.surgeonUtilization;
      }
      
      // If not cached, calculate it (this would normally be fetched from an API)
      return null;
    },
    
    // Get surgery type distribution data
    surgeryTypeDistribution: (state) => {
      if (state.cachedData.surgeryTypeDistribution) {
        return state.cachedData.surgeryTypeDistribution;
      }
      
      // If not cached, calculate it (this would normally be fetched from an API)
      return null;
    },
    
    // Get SDST efficiency data
    sdstEfficiency: (state) => {
      if (state.cachedData.sdstEfficiency) {
        return state.cachedData.sdstEfficiency;
      }
      
      // If not cached, calculate it (this would normally be fetched from an API)
      return null;
    },
    
    // Get daily metrics data
    dailyMetrics: (state) => {
      if (state.cachedData.dailyMetrics) {
        return state.cachedData.dailyMetrics;
      }
      
      // If not cached, calculate it (this would normally be fetched from an API)
      return null;
    },
  },
  
  actions: {
    // Set the date range for analytics
    setDateRange(start, end) {
      this.dateRange.start = start;
      this.dateRange.end = end;
      
      // Clear cached data when date range changes
      this.clearCachedData();
    },
    
    // Clear cached data
    clearCachedData() {
      this.cachedData = {
        orUtilization: null,
        surgeonUtilization: null,
        surgeryTypeDistribution: null,
        sdstEfficiency: null,
        dailyMetrics: null,
      };
    },
    
    // Load analytics data
    async loadAnalyticsData() {
      this.isLoading = true;
      this.error = null;
      
      try {
        // In a real app, this would fetch data from an API
        await this.simulateLoadORUtilization();
        await this.simulateLoadSurgeonUtilization();
        await this.simulateLoadSurgeryTypeDistribution();
        await this.simulateLoadSDSTEfficiency();
        await this.simulateLoadDailyMetrics();
        
        console.log('Analytics data loaded successfully');
      } catch (error) {
        this.error = 'Failed to load analytics data';
        console.error('Failed to load analytics data:', error);
      } finally {
        this.isLoading = false;
      }
    },
    
    // Simulate loading OR utilization data
    async simulateLoadORUtilization() {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Generate mock data
      const orUtilization = [];
      const scheduleStore = useScheduleStore();
      const resourceStore = useResourceStore();
      
      resourceStore.operatingRooms.forEach(or => {
        // Calculate utilization based on scheduled surgeries
        const surgeries = scheduleStore.scheduledSurgeries.filter(s => s.orId === or.id);
        const totalMinutes = surgeries.reduce((total, s) => total + s.duration, 0);
        const totalHours = totalMinutes / 60;
        
        // Assume 8-hour workday
        const workdayHours = 8;
        const utilizationRate = Math.min(totalHours / workdayHours, 1);
        
        orUtilization.push({
          orId: or.id,
          orName: or.name,
          utilizationRate: utilizationRate,
          scheduledHours: totalHours,
          availableHours: workdayHours,
          idleTime: Math.max(0, workdayHours - totalHours),
          overtimeRate: Math.max(0, (totalHours - workdayHours) / workdayHours),
        });
      });
      
      this.cachedData.orUtilization = orUtilization;
    },
    
    // Simulate loading surgeon utilization data
    async simulateLoadSurgeonUtilization() {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Generate mock data
      const surgeonUtilization = [];
      const scheduleStore = useScheduleStore();
      const resourceStore = useResourceStore();
      
      resourceStore.staff
        .filter(s => s.role === 'Surgeon')
        .forEach(surgeon => {
          // Calculate utilization based on scheduled surgeries
          const surgeries = scheduleStore.scheduledSurgeries.filter(s => s.surgeonId === surgeon.id);
          const totalMinutes = surgeries.reduce((total, s) => total + s.duration, 0);
          const totalHours = totalMinutes / 60;
          const surgeryCount = surgeries.length;
          
          // Calculate average duration
          const averageDuration = surgeryCount > 0 ? totalMinutes / surgeryCount : 0;
          
          // Simulate on-time start percentage (would be calculated from actual data)
          const onTimeStart = Math.random() * 0.3 + 0.7; // Random between 70% and 100%
          
          surgeonUtilization.push({
            surgeonId: surgeon.id,
            surgeonName: surgeon.name,
            surgeryCount,
            totalHours,
            averageDuration,
            onTimeStart,
          });
        });
      
      this.cachedData.surgeonUtilization = surgeonUtilization;
    },
    
    // Simulate loading surgery type distribution data
    async simulateLoadSurgeryTypeDistribution() {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Generate mock data
      const surgeryTypeDistribution = [];
      const scheduleStore = useScheduleStore();
      
      // Get unique surgery types
      const surgeryTypes = [...new Set(scheduleStore.scheduledSurgeries.map(s => s.type))];
      
      surgeryTypes.forEach(type => {
        const surgeries = scheduleStore.scheduledSurgeries.filter(s => s.type === type);
        const count = surgeries.length;
        const totalMinutes = surgeries.reduce((total, s) => total + s.duration, 0);
        
        surgeryTypeDistribution.push({
          type,
          count,
          totalMinutes,
          averageDuration: count > 0 ? totalMinutes / count : 0,
          percentage: count / scheduleStore.scheduledSurgeries.length,
        });
      });
      
      this.cachedData.surgeryTypeDistribution = surgeryTypeDistribution;
    },
    
    // Simulate loading SDST efficiency data
    async simulateLoadSDSTEfficiency() {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Generate mock data for SDST efficiency
      const sdstEfficiency = {
        averageSDST: 22.5, // minutes
        sdstPercentage: 0.12, // 12% of total OR time
        mostEfficientTransition: {
          from: 'APPEN',
          to: 'KNEE',
          averageTime: 15,
        },
        leastEfficientTransition: {
          from: 'CABG',
          to: 'APPEN',
          averageTime: 45,
        },
        potentialSavings: 120, // minutes per day
      };
      
      this.cachedData.sdstEfficiency = sdstEfficiency;
    },
    
    // Simulate loading daily metrics data
    async simulateLoadDailyMetrics() {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Generate mock data for daily metrics over the last 30 days
      const dailyMetrics = [];
      const startDate = new Date(this.dateRange.start);
      const endDate = new Date(this.dateRange.end);
      
      // Loop through each day in the date range
      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
        const date = new Date(d);
        
        // Generate random metrics for the day
        dailyMetrics.push({
          date: date.toISOString().split('T')[0],
          surgeryCount: Math.floor(Math.random() * 10) + 5,
          utilizationRate: Math.random() * 0.3 + 0.6, // 60-90%
          onTimeStart: Math.random() * 0.3 + 0.7, // 70-100%
          averageTurnaround: Math.floor(Math.random() * 10) + 20, // 20-30 minutes
        });
      }
      
      this.cachedData.dailyMetrics = dailyMetrics;
    },
    
    // Save a custom report configuration
    saveCustomReport(reportConfig) {
      // Generate a unique ID
      const newId = `report-${Date.now()}`;
      
      // Add the new report
      this.savedReports.push({
        id: newId,
        ...reportConfig,
      });
      
      return newId;
    },
    
    // Delete a custom report
    deleteCustomReport(reportId) {
      this.savedReports = this.savedReports.filter(r => r.id !== reportId);
    },
  }
});



================================================
FILE: src/stores/authStore.js
================================================
// src/stores/authStore.js
import { defineStore } from 'pinia';
import router from '@/router'; // Import the router instance

export const useAuthStore = defineStore('auth', {
  state: () => ({
    isAuthenticated: localStorage.getItem('isAuthenticated') === 'true', // Load initial state from local storage
    user: JSON.parse(localStorage.getItem('user') || 'null'), // Load user info from local storage
    isLoading: false,
    error: null,
  }),
  getters: {
    // isAuthenticated: (state) => state.isAuthenticated, // Can be a simple state property
    // user: (state) => state.user,
  },
  actions: {
    async login(username, password) {
      this.isLoading = true;
      this.error = null;

      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));

      try {
        // Mocked login logic
        if (username === 'test@example.com' && password === 'password') {
          const mockUser = { id: 1, username: 'test@example.com', name: 'Test User' };
          this.isAuthenticated = true;
          this.user = mockUser;
          localStorage.setItem('isAuthenticated', 'true');
          localStorage.setItem('user', JSON.stringify(mockUser));
          router.push({ name: 'Dashboard' });
        } else {
          throw new Error('Invalid mock credentials');
        }
      } catch (error) {
        console.error('Mock Login error:', error);
        this.error = error.message;
        this.isAuthenticated = false;
        this.user = null;
        localStorage.removeItem('isAuthenticated');
        localStorage.removeItem('user');
      } finally {
        this.isLoading = false;
      }
    },

    async register(username, password) {
      this.isLoading = true;
      this.error = null;
      let success = false;

      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));

      try {
        // Mocked registration logic
        // For simplicity, let's assume registration is always successful for a new user
        // or fails if username is already 'test@example.com'
        if (username === 'test@example.com') {
          throw new Error('Mock: Username already exists.');
        }

        // You could add to a mock user list in localStorage if needed for more complex simulation
        // For now, just simulate success
        console.log('Mock Registration successful for:', username, '. Please log in.');
        success = true;
      } catch (error) {
        console.error('Mock Registration error:', error);
        this.error = error.message;
        success = false;
      } finally {
        this.isLoading = false;
      }
      return success;
    },

    logout() {
       console.log('Auth Store: Logging out.');
      // Clear auth state
      this.isAuthenticated = false;
      this.user = null;
      this.error = null; // Clear any lingering errors
      // Remove auth data from local storage
      localStorage.removeItem('isAuthenticated');
      localStorage.removeItem('user');
      // localStorage.removeItem('authToken'); // Clear token if used

      // Redirect to login page
      router.push({ name: 'Login' }); // Use router instance
    }
  }
});



================================================
FILE: src/stores/notificationStore.js
================================================
import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useNotificationStore = defineStore('notification', () => {
  const notifications = ref([]);
  const toastRef = ref(null);

  // Set the toast component reference
  const setToastRef = (ref) => {
    toastRef.value = ref;
  };

  // Show a success notification
  const success = (message, options = {}) => {
    return showNotification({
      type: 'success',
      message,
      ...options
    });
  };

  // Show an error notification
  const error = (message, options = {}) => {
    return showNotification({
      type: 'error',
      message,
      ...options
    });
  };

  // Show a warning notification
  const warning = (message, options = {}) => {
    return showNotification({
      type: 'warning',
      message,
      ...options
    });
  };

  // Show an info notification
  const info = (message, options = {}) => {
    return showNotification({
      type: 'info',
      message,
      ...options
    });
  };

  // Generic method to show a notification
  const showNotification = (notification) => {
    if (toastRef.value) {
      return toastRef.value.addToast(notification);
    } else {
      console.warn('Toast component reference not set. Falling back to alert.');
      alert(`${notification.type.toUpperCase()}: ${notification.message}`);
      return null;
    }
  };

  // Dismiss a notification by ID
  const dismiss = (id) => {
    if (toastRef.value) {
      toastRef.value.dismissToast(id);
    }
  };

  return {
    notifications,
    setToastRef,
    success,
    error,
    warning,
    info,
    showNotification,
    dismiss
  };
});



================================================
FILE: src/stores/resourceStore.js
================================================
import { defineStore } from 'pinia';

export const useResourceStore = defineStore('resource', {
  state: () => ({
    isLoading: false,
    error: null,

    // Operating Rooms
    operatingRooms: [
      { id: 'OR1', name: 'OR 1', location: 'Main Building, 2nd Floor', status: 'Active', primaryService: 'General Surgery' },
      { id: 'OR2', name: 'OR 2', location: 'Main Building, 2nd Floor', status: 'Active', primaryService: 'Orthopedics' },
      { id: 'OR3', name: 'OR 3', location: 'Main Building, 3rd Floor', status: 'Under Maintenance', primaryService: 'Cardiac Surgery' },
      { id: 'OR4', name: 'OR 4', location: 'East Wing, 1st Floor', status: 'Active', primaryService: 'Neurosurgery' },
      { id: 'OR5', name: 'OR 5', location: 'East Wing, 1st Floor', status: 'Active', primaryService: 'Ophthalmology' },
    ],

    // Staff
    staff: [
      { id: 'SG1', name: 'Dr. Jane Smith', role: 'Surgeon', specializations: ['Cardiac Surgery', 'Vascular Surgery'], status: 'Active' },
      { id: 'SG2', name: 'Dr. Bill Adams', role: 'Surgeon', specializations: ['Orthopedics', 'Sports Medicine'], status: 'Active' },
      { id: 'SG3', name: 'Dr. Sarah Chen', role: 'Surgeon', specializations: ['General Surgery'], status: 'Active' },
      { id: 'SG4', name: 'Dr. Michael Wong', role: 'Surgeon', specializations: ['Ophthalmology'], status: 'Active' },
      { id: 'AN1', name: 'Dr. Emily Carter', role: 'Anesthetist', specializations: [], status: 'Active' },
      { id: 'AN2', name: 'Dr. Robert Johnson', role: 'Anesthetist', specializations: [], status: 'On Leave' },
      { id: 'NR1', name: 'Nurse John Doe', role: 'Scrub Nurse', specializations: ['General Surgery'], status: 'Active' },
      { id: 'NR2', name: 'Nurse Maria Garcia', role: 'Circulating Nurse', specializations: ['Cardiac Surgery'], status: 'Active' },
    ],

    // Equipment
    equipment: [
      { id: 'EQ1', name: 'Heart-Lung Machine 1', type: 'Heart-Lung Machine', status: 'Available', location: 'Storage Room A' },
      { id: 'EQ2', name: 'Arthroscope Unit 2', type: 'Arthroscope', status: 'In Use', location: 'OR 2' },
      { id: 'EQ3', name: 'C-Arm Unit 1', type: 'C-Arm', status: 'Available', location: 'Storage Room A' },
      { id: 'EQ4', name: 'Anesthesia Machine B', type: 'Anesthesia Machine', status: 'In Use', location: 'OR 2' },
      { id: 'EQ5', name: 'Microscope Model X', type: 'Surgical Microscope', status: 'Available', location: 'Storage Room B' },
      { id: 'EQ6', name: 'Phacoemulsification Machine', type: 'Phacoemulsification Machine', status: 'Available', location: 'Storage Room C' },
      { id: 'EQ7', name: 'Orthopedic Power Tools Set', type: 'Orthopedic Power Tools', status: 'Available', location: 'Storage Room B' },
    ],

    // Resource availability (for scheduling)
    resourceAvailability: {
      // Key is date in ISO format, value is object with resource IDs and their availability
      '2023-10-27': {
        'OR1': { available: true, unavailablePeriods: [] },
        'OR2': { available: true, unavailablePeriods: [] },
        'OR3': { available: false, unavailablePeriods: [{ start: '00:00', end: '23:59', reason: 'Maintenance' }] },
        'SG1': { available: true, unavailablePeriods: [{ start: '12:00', end: '13:00', reason: 'Lunch' }] },
        'SG2': { available: true, unavailablePeriods: [{ start: '12:30', end: '13:30', reason: 'Lunch' }] },
      }
    }
  }),

  getters: {
    // Get all active operating rooms
    activeOperatingRooms: (state) => {
      return state.operatingRooms.filter(or => or.status === 'Active');
    },

    // Get all active staff
    activeStaff: (state) => {
      return state.staff.filter(s => s.status === 'Active');
    },

    // Get all available equipment
    availableEquipment: (state) => {
      return state.equipment.filter(eq => eq.status === 'Available');
    },

    // Get staff by role
    getStaffByRole: (state) => (role) => {
      return state.staff.filter(s => s.role === role && s.status === 'Active');
    },

    // Get surgeons by specialization
    getSurgeonsBySpecialization: (state) => (specialization) => {
      return state.staff.filter(s =>
        s.role === 'Surgeon' &&
        s.status === 'Active' &&
        s.specializations.includes(specialization)
      );
    },

    // Check if a resource is available at a specific time
    isResourceAvailable: (state) => (resourceId, date, startTime, endTime) => {
      const dateKey = new Date(date).toISOString().split('T')[0];
      const resourceAvailability = state.resourceAvailability[dateKey]?.[resourceId];

      if (!resourceAvailability || !resourceAvailability.available) {
        return false;
      }

      // Check if the resource is unavailable during any part of the requested time
      for (const period of resourceAvailability.unavailablePeriods) {
        if (
          (startTime >= period.start && startTime < period.end) || // Start time is within unavailable period
          (endTime > period.start && endTime <= period.end) || // End time is within unavailable period
          (startTime <= period.start && endTime >= period.end) // Requested time spans the unavailable period
        ) {
          return false;
        }
      }

      return true;
    }
  },

  actions: {
    // Load resources from API (simulated)
    async loadResources() {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));

        // In a real app, we would fetch data from the API here
        console.log('Resources loaded successfully');
      } catch (error) {
        this.error = 'Failed to load resources';
        console.error('Failed to load resources:', error);
      } finally {
        this.isLoading = false;
      }
    },

    // Operating Room actions
    async addOperatingRoom(orData) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Generate a unique ID
        const newId = `OR${this.operatingRooms.length + 1}`;

        // Add the new OR to the state
        this.operatingRooms.push({
          id: newId,
          ...orData
        });

        console.log('Operating room added successfully:', newId);
        return { success: true, id: newId };
      } catch (error) {
        this.error = 'Failed to add operating room';
        console.error('Failed to add operating room:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    async updateOperatingRoom(orId, orData) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Find the OR to update
        const index = this.operatingRooms.findIndex(or => or.id === orId);

        if (index !== -1) {
          // Update the OR
          this.operatingRooms[index] = {
            ...this.operatingRooms[index],
            ...orData
          };

          console.log('Operating room updated successfully:', orId);
          return { success: true };
        } else {
          throw new Error('Operating room not found');
        }
      } catch (error) {
        this.error = 'Failed to update operating room';
        console.error('Failed to update operating room:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    async deleteOperatingRoom(orId) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Remove the OR from the state
        this.operatingRooms = this.operatingRooms.filter(or => or.id !== orId);

        console.log('Operating room deleted successfully:', orId);
        return { success: true };
      } catch (error) {
        this.error = 'Failed to delete operating room';
        console.error('Failed to delete operating room:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    // Staff actions
    async addStaff(staffData) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Generate a unique ID based on role
        let prefix = 'ST'; // Default prefix
        if (staffData.role === 'Surgeon') prefix = 'SG';
        else if (staffData.role === 'Anesthetist') prefix = 'AN';
        else if (staffData.role === 'Nurse') prefix = 'NR';

        const newId = `${prefix}${this.staff.length + 1}`;

        // Add the new staff to the state
        this.staff.push({
          id: newId,
          ...staffData
        });

        console.log('Staff added successfully:', newId);
        return { success: true, id: newId };
      } catch (error) {
        this.error = 'Failed to add staff';
        console.error('Failed to add staff:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    async updateStaff(staffId, staffData) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Find the staff to update
        const index = this.staff.findIndex(s => s.id === staffId);

        if (index !== -1) {
          // Update the staff
          this.staff[index] = {
            ...this.staff[index],
            ...staffData
          };

          console.log('Staff updated successfully:', staffId);
          return { success: true };
        } else {
          throw new Error('Staff not found');
        }
      } catch (error) {
        this.error = 'Failed to update staff';
        console.error('Failed to update staff:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    async deleteStaff(staffId) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Remove the staff from the state
        this.staff = this.staff.filter(s => s.id !== staffId);

        console.log('Staff deleted successfully:', staffId);
        return { success: true };
      } catch (error) {
        this.error = 'Failed to delete staff';
        console.error('Failed to delete staff:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    // Equipment actions
    async addEquipment(equipmentData) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Generate a unique ID
        const newId = `EQ${this.equipment.length + 1}`;

        // Add the new equipment to the state
        this.equipment.push({
          id: newId,
          ...equipmentData
        });

        console.log('Equipment added successfully:', newId);
        return { success: true, id: newId };
      } catch (error) {
        this.error = 'Failed to add equipment';
        console.error('Failed to add equipment:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    async updateEquipment(equipmentId, equipmentData) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Find the equipment to update
        const index = this.equipment.findIndex(eq => eq.id === equipmentId);

        if (index !== -1) {
          // Update the equipment
          this.equipment[index] = {
            ...this.equipment[index],
            ...equipmentData
          };

          console.log('Equipment updated successfully:', equipmentId);
          return { success: true };
        } else {
          throw new Error('Equipment not found');
        }
      } catch (error) {
        this.error = 'Failed to update equipment';
        console.error('Failed to update equipment:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    async deleteEquipment(equipmentId) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Remove the equipment from the state
        this.equipment = this.equipment.filter(eq => eq.id !== equipmentId);

        console.log('Equipment deleted successfully:', equipmentId);
        return { success: true };
      } catch (error) {
        this.error = 'Failed to delete equipment';
        console.error('Failed to delete equipment:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    },

    // Resource availability actions
    async updateResourceAvailability(resourceId, date, availability) {
      this.isLoading = true;
      this.error = null;

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 500));

        // Format date as ISO string (YYYY-MM-DD)
        const dateKey = new Date(date).toISOString().split('T')[0];

        // Ensure the date exists in the availability object
        if (!this.resourceAvailability[dateKey]) {
          this.resourceAvailability[dateKey] = {};
        }

        // Update the resource availability
        this.resourceAvailability[dateKey][resourceId] = availability;

        console.log('Resource availability updated successfully:', resourceId, dateKey);
        return { success: true };
      } catch (error) {
        this.error = 'Failed to update resource availability';
        console.error('Failed to update resource availability:', error);
        return { success: false, error: this.error };
      } finally {
        this.isLoading = false;
      }
    }
  }
});



================================================
FILE: src/stores/scheduleStore.js
================================================
// src/stores/scheduleStore.js
import { defineStore } from 'pinia';
// Assuming these API services exist for fetching/updating data
// import { fetchScheduleData, updateSchedule, cancelSurgeryApi, fetchSDSTData, fetchResourceData } from '@/api';

export const useScheduleStore = defineStore('schedule', {
  state: () => ({
    // --- Core Schedule Data ---
    scheduledSurgeries: [
      // Example Data Structure (will be fetched from backend)
      {
        id: 's-1', patientId: 'P101', patientName: 'Alice Smith',
        type: 'CABG', fullType: 'Cardiac - Coronary Artery Bypass Graft',
        estimatedDuration: 240, duration: 240, priority: 'High',
        startTime: '2023-10-27T08:00:00Z', endTime: '2023-10-27T12:00:00Z',
        orId: 'OR1', orName: 'Operating Room 1',
        surgeonId: 'SG1', surgeon: 'Dr. Jane Smith',
        requiredSurgeons: ['Dr. Jane Smith'], requiredStaffRoles: ['Anesthetist', 'Scrub Nurse'], requiredEquipment: ['Heart-Lung Machine'],
        status: 'Scheduled',
        // These will be calculated/added after fetching schedule data based on sequence
        sdsTime: 30, // Example calculated SDST
        precedingType: 'Initial', // Example preceding surgery type
        conflicts: [], // Example: ['Surgeon unavailable']
      },
      {
        id: 's-2', patientId: 'P102', patientName: 'Bob Johnson',
        type: 'KNEE', fullType: 'Orthopedic - Knee Replacement',
        estimatedDuration: 120, duration: 120, priority: 'Medium',
        startTime: '2023-10-27T12:30:00Z', endTime: '2023-10-27T14:30:00Z', // Assuming 30 min setup after s-1
        orId: 'OR1', orName: 'Operating Room 1',
        surgeonId: 'SG2', surgeon: 'Dr. Bill Adams',
        requiredSurgeons: ['Dr. Bill Adams'], requiredStaffRoles: ['Scrub Nurse'], requiredEquipment: ['Arthroscope'],
        status: 'Scheduled',
        sdsTime: 15, // Example calculated SDST
        precedingType: 'CABG', // Example preceding surgery type
        conflicts: [],
      },
      {
        id: 's-3', patientId: 'P103', patientName: 'Charlie Davis',
        type: 'APPEN', fullType: 'General - Appendectomy',
        estimatedDuration: 60, duration: 60, priority: 'High',
        startTime: '2023-10-27T09:00:00Z', endTime: '2023-10-27T10:00:00Z',
        orId: 'OR2', orName: 'Operating Room 2',
        surgeonId: 'SG3', surgeon: 'Dr. Sarah Chen',
        requiredSurgeons: ['Dr. Sarah Chen'], requiredStaffRoles: ['Circulating Nurse'], requiredEquipment: [],
        status: 'Scheduled',
        sdsTime: 30, // Example calculated SDST
        precedingType: 'Initial', // First case of the day
        conflicts: [],
      },
      {
        id: 's-4', patientId: 'P104', patientName: 'Donna Miller',
        type: 'CABG', fullType: 'Cardiac - Coronary Artery Bypass Graft',
        estimatedDuration: 240, duration: 240, priority: 'Medium',
        startTime: '2023-10-27T10:30:00Z', endTime: '2023-10-27T14:30:00Z', // Assuming 30 min setup after s-3 type APPEN
        orId: 'OR2', orName: 'Operating Room 2',
        surgeonId: 'SG1', surgeon: 'Dr. Jane Smith', // Dr. Smith double booked? - this is a conflict!
        requiredSurgeons: ['Dr. Jane Smith'], requiredStaffRoles: ['Anesthetist', 'Scrub Nurse'], requiredEquipment: ['Heart-Lung Machine'],
        status: 'Scheduled',
        sdsTime: 30, // Example calculated SDST (APPEN -> CABG)
        precedingType: 'APPEN',
        conflicts: ['Surgeon Dr. Jane Smith unavailable (scheduled in OR1)'], // Example conflict
      },
      {
        id: 's-5', patientId: 'P105', patientName: 'Edward Thompson',
        type: 'HERNI', fullType: 'General - Hernia Repair',
        estimatedDuration: 90, duration: 90, priority: 'Medium',
        startTime: '2023-10-27T14:45:00Z', endTime: '2023-10-27T16:15:00Z',
        orId: 'OR1', orName: 'Operating Room 1',
        surgeonId: 'SG3', surgeon: 'Dr. Sarah Chen',
        requiredSurgeons: ['Dr. Sarah Chen'], requiredStaffRoles: ['Scrub Nurse'], requiredEquipment: [],
        status: 'Scheduled',
        sdsTime: 15, // Example calculated SDST
        precedingType: 'KNEE', // Example preceding surgery type
        conflicts: [],
      },
      {
        id: 's-6', patientId: 'P106', patientName: 'Fiona Green',
        type: 'CATAR', fullType: 'Ophthalmology - Cataract Surgery',
        estimatedDuration: 45, duration: 45, priority: 'Low',
        startTime: '2023-10-27T15:00:00Z', endTime: '2023-10-27T15:45:00Z',
        orId: 'OR2', orName: 'Operating Room 2',
        surgeonId: 'SG4', surgeon: 'Dr. Michael Wong',
        requiredSurgeons: ['Dr. Michael Wong'], requiredStaffRoles: ['Scrub Nurse'], requiredEquipment: ['Phacoemulsification Machine'],
        status: 'Scheduled',
        sdsTime: 15, // Example calculated SDST
        precedingType: 'CABG', // Example preceding surgery type
        conflicts: [],
      },
      {
        id: 's-7', patientId: 'P107', patientName: 'George Brown',
        type: 'HIPRE', fullType: 'Orthopedic - Hip Replacement',
        estimatedDuration: 150, duration: 150, priority: 'Medium',
        startTime: '2023-10-27T16:15:00Z', endTime: '2023-10-27T18:45:00Z',
        orId: 'OR2', orName: 'Operating Room 2',
        surgeonId: 'SG2', surgeon: 'Dr. Bill Adams',
        requiredSurgeons: ['Dr. Bill Adams'], requiredStaffRoles: ['Anesthetist', 'Scrub Nurse'], requiredEquipment: ['Orthopedic Power Tools'],
        status: 'Scheduled',
        sdsTime: 15, // Example calculated SDST
        precedingType: 'CATAR', // Example preceding surgery type
        conflicts: [],
      },
    ],
    pendingSurgeries: [
      // Example Pending Surgeries (will be fetched from backend)
      {
        id: 'p-1', patientId: 'P108', patientName: 'Ethan Brown',
        type: 'APPEN', fullType: 'General - Appendectomy',
        estimatedDuration: 75, duration: 75, priority: 'High',
        requestedDate: '2023-10-28T00:00:00Z', // Optional requested date
        requiredSurgeons: ['Dr. Sarah Chen'], requiredStaffRoles: ['Circulating Nurse'], requiredEquipment: [],
        status: 'Pending',
        sdsTime: null, // SDST not applicable until scheduled
        precedingType: null,
        conflicts: [],
      },
      {
        id: 'p-2', patientId: 'P109', patientName: 'Fiona Green',
        type: 'KNEE', fullType: 'Orthopedic - Knee Replacement',
        estimatedDuration: 150, duration: 150, priority: 'Medium',
        requestedDate: '2023-10-29T00:00:00Z',
        requiredSurgeons: ['Dr. Bill Adams'], requiredStaffRoles: ['Scrub Nurse'], requiredEquipment: ['Arthroscope'],
        status: 'Pending',
        sdsTime: null,
        precedingType: null,
        conflicts: [],
      },
      {
        id: 'p-3', patientId: 'P110', patientName: 'Henry Wilson',
        type: 'HERNI', fullType: 'General - Hernia Repair',
        estimatedDuration: 90, duration: 90, priority: 'Low',
        requestedDate: '2023-10-28T00:00:00Z',
        requiredSurgeons: ['Dr. Sarah Chen'], requiredStaffRoles: ['Scrub Nurse'], requiredEquipment: [],
        status: 'Pending',
        sdsTime: null,
        precedingType: null,
        conflicts: [],
      },
      {
        id: 'p-4', patientId: 'P111', patientName: 'Isabella Martinez',
        type: 'CATAR', fullType: 'Ophthalmology - Cataract Surgery',
        estimatedDuration: 45, duration: 45, priority: 'Medium',
        requestedDate: '2023-10-28T00:00:00Z',
        requiredSurgeons: ['Dr. Michael Wong'], requiredStaffRoles: ['Scrub Nurse'], requiredEquipment: ['Phacoemulsification Machine'],
        status: 'Pending',
        sdsTime: null,
        precedingType: null,
        conflicts: [],
      },
      {
        id: 'p-5', patientId: 'P112', patientName: 'James Taylor',
        type: 'HIPRE', fullType: 'Orthopedic - Hip Replacement',
        estimatedDuration: 150, duration: 150, priority: 'High',
        requestedDate: '2023-10-29T00:00:00Z',
        requiredSurgeons: ['Dr. Bill Adams'], requiredStaffRoles: ['Anesthetist', 'Scrub Nurse'], requiredEquipment: ['Orthopedic Power Tools'],
        status: 'Pending',
        sdsTime: null,
        precedingType: null,
        conflicts: [],
      },
    ],

    // --- Resource Data (Minimal Example) ---
    operatingRooms: [
      { id: 'OR1', name: 'Operating Room 1', status: 'Active' },
      { id: 'OR2', name: 'Operating Room 2', status: 'Active' },
      { id: 'OR3', name: 'Operating Room 3', status: 'Under Maintenance' },
    ],
     staff: [], // Full staff list would be here
     equipment: [], // Full equipment list would be here

    // --- SDST Data (Minimal Example) ---
    // Surgery type definitions with full names
    surgeryTypes: {
      'CABG': { fullName: 'Cardiac - Coronary Artery Bypass Graft', code: 'CABG' },
      'KNEE': { fullName: 'Orthopedic - Knee Replacement', code: 'KNEE' },
      'APPEN': { fullName: 'General - Appendectomy', code: 'APPEN' },
      'HERNI': { fullName: 'General - Hernia Repair', code: 'HERNI' },
      'CATAR': { fullName: 'Ophthalmology - Cataract Surgery', code: 'CATAR' },
      'HIPRE': { fullName: 'Orthopedic - Hip Replacement', code: 'HIPRE' },
    },

    sdsRules: {
      'CABG': { 'KNEE': 30, 'APPEN': 45, 'HERNI': 30, 'CATAR': 45, 'HIPRE': 30 },
      'KNEE': { 'CABG': 45, 'APPEN': 15, 'HERNI': 20, 'CATAR': 30, 'HIPRE': 15 },
      'APPEN': { 'CABG': 30, 'KNEE': 15, 'HERNI': 15, 'CATAR': 30, 'HIPRE': 30 },
      'HERNI': { 'CABG': 45, 'KNEE': 20, 'APPEN': 15, 'CATAR': 30, 'HIPRE': 25 },
      'CATAR': { 'CABG': 45, 'KNEE': 30, 'APPEN': 30, 'HERNI': 30, 'HIPRE': 30 },
      'HIPRE': { 'CABG': 45, 'KNEE': 15, 'APPEN': 30, 'HERNI': 25, 'CATAR': 30 },
      // Add rules for 'Initial' preceding type if different from initialSetupTimes
    },
    initialSetupTimes: {
        'CABG': 60,
        'KNEE': 45,
        'APPEN': 30,
        'HERNI': 30,
        'CATAR': 20,
        'HIPRE': 45,
    },


    // --- UI State ---
    selectedSurgeryId: null, // ID of the currently selected surgery
    currentDateRange: { // Date range for the Gantt chart view
        start: new Date('2023-10-27T07:00:00Z'), // Start of the day/view
        end: new Date('2023-10-27T19:00:00Z'), // End of the day/view
    },
    ganttViewMode: 'Day', // 'Day', 'Week', 'Month'
    isLoading: false,
    error: null,
  }),
  getters: {
    // Filter scheduled surgeries for the current view
    visibleScheduledSurgeries: (state) => {
        const startTime = state.currentDateRange.start.getTime();
        const endTime = state.currentDateRange.end.getTime();
        return state.scheduledSurgeries.filter(surgery => {
            const surgeryStart = new Date(surgery.startTime).getTime();
            const surgeryEnd = new Date(surgery.endTime).getTime();
            // Show surgeries that are at least partially within the view range
            return (surgeryStart < endTime && surgeryEnd > startTime);
        });
    },

    // Get surgeries for a specific OR within the current view
    getSurgeriesForOR: (state) => (orId) => {
      return state.visibleScheduledSurgeries
            .filter(s => s.orId === orId)
            .sort((a, b) => new Date(a.startTime) - new Date(b.startTime)); // Sort by time
    },

    // Get the currently selected surgery object
    selectedSurgery: (state) => {
        if (!state.selectedSurgeryId) return null;
        // Find in both scheduled and pending lists
        return state.scheduledSurgeries.find(s => s.id === state.selectedSurgeryId) ||
               state.pendingSurgeries.find(s => s.id === state.selectedSurgeryId);
    },

    // Get operating rooms that are not under maintenance (for scheduling)
    availableOperatingRooms: (state) => {
        return state.operatingRooms.filter(or => or.status !== 'Under Maintenance');
    }


    // ... other getters for filtered staff, equipment, reports etc.
  },
  actions: {
    // Action to simulate loading initial data
    async loadInitialData() {
      this.isLoading = true;
      this.error = null;
      try {
        // In a real app, this would be API calls:
        // const [scheduleData, sdstData, resourceData] = await Promise.all([
        //     fetchScheduleData(this.currentDateRange), // Pass date range to API
        //     fetchSDSTData(),
        //     fetchResourceData(),
        // ]);
        // this.scheduledSurgeries = scheduleData.surgeries;
        // this.pendingSurgeries = scheduleData.pending;
        // this.sdsRules = sdstData.rules;
        // this.initialSetupTimes = sdstData.initialTimes;
        // this.operatingRooms = resourceData.ors;
        // this.staff = resourceData.staff;
        // this.equipment = resourceData.equipment;

        // Simulate processing after fetch (to add sdsTime, precedingType, conflicts)
         this.processScheduleData();


      } catch (err) {
        // this.error = 'Failed to load schedule data.';
        console.error("Simulated data load failed:", err);
         this.error = 'Simulated data load error.';
      } finally {
        this.isLoading = false;
      }
    },

    // Simulate processing fetched schedule data to include SDST and conflicts
    // In a real app, this might happen on the backend or involve complex front-end logic
    processScheduleData() {
        // This is a simplified simulation of how SDST and conflicts *could* be added
        // based on the sequence in each OR.
        const processedSurgeries = [];

        this.operatingRooms.forEach(or => {
            const surgeriesInOR = this.scheduledSurgeries
                .filter(s => s.orId === or.id)
                .sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

            for (let i = 0; i < surgeriesInOR.length; i++) {
                const currentSurgery = surgeriesInOR[i];
                const precedingSurgery = i > 0 ? surgeriesInOR[i - 1] : null;
                const precedingType = precedingSurgery ? precedingSurgery.type : 'Initial';
                const succeedingSurgery = i < surgeriesInOR.length - 1 ? surgeriesInOR[i + 1] : null;
                const succeedingType = succeedingSurgery ? succeedingSurgery.type : 'End of Day';

                let sdsTime = 0;
                if (precedingType === 'Initial') {
                    sdsTime = this.initialSetupTimes[currentSurgery.type] || 0;
                } else if (this.sdsRules[precedingType] && this.sdsRules[precedingType][currentSurgery.type]) {
                     sdsTime = this.sdsRules[precedingType][currentSurgery.type];
                }
                 // Ensure sdsTime is at least 0
                 sdsTime = Math.max(0, sdsTime);


                // Simulate conflict checking (very basic: check for double booking)
                 const conflicts = [];
                 // Check if the surgeon is double booked (very simple check across all scheduled surgeries)
                 const surgeonConflicts = this.scheduledSurgeries.filter(s =>
                     s.id !== currentSurgery.id && // Not the same surgery
                     s.surgeonId === currentSurgery.surgeonId && // Same surgeon
                     (
                         (new Date(currentSurgery.startTime) < new Date(s.endTime) && new Date(currentSurgery.endTime) > new Date(s.startTime)) || // Overlap
                          // Also check if SDST overlaps with another surgery start
                          (new Date(currentSurgery.startTime) - (sdsTime * 60 * 1000) < new Date(s.endTime) && new Date(currentSurgery.startTime) > new Date(s.startTime))
                     )
                 );
                 if (surgeonConflicts.length > 0) {
                     surgeonConflicts.forEach(conflict => {
                          conflicts.push(`Surgeon ${currentSurgery.surgeon} unavailable (scheduled in ${conflict.orName} at ${new Date(conflict.startTime).toLocaleTimeString()})`);
                     });
                 }

                 // Check for SDST violation (if the gap before is less than required SDST)
                 if (precedingSurgery) {
                     const gapBefore = (new Date(currentSurgery.startTime).getTime() - new Date(precedingSurgery.endTime).getTime()) / (1000 * 60); // Gap in minutes
                      if (gapBefore < sdsTime) {
                         conflicts.push(`SDST Violation: Requires ${sdsTime} min setup, only ${Math.max(0, Math.floor(gapBefore))} min available after ${precedingSurgery.patientName}.`);
                      }
                 } else if (precedingType === 'Initial') {
                      // Check initial setup time if needed, though often assumed available before first case start
                 }


                processedSurgeries.push({
                    ...currentSurgery,
                    sdsTime,
                    precedingType,
                    conflicts, // Add calculated conflicts
                    // Recalculate endTime based on duration + SDST if needed
                     endTime: new Date(new Date(currentSurgery.startTime).getTime() + (currentSurgery.duration + sdsTime) * 60 * 1000).toISOString()
                });
            }
        });

        this.scheduledSurgeries = processedSurgeries; // Update the state with processed data
    },


    // Action to select a surgery to view details
     selectSurgery(surgeryId) {
        this.selectedSurgeryId = surgeryId;
     },

     // Action to clear the selected surgery
     clearSelectedSurgery() {
         this.selectedSurgeryId = null;
     },

    // Action to handle rescheduling a surgery (simulated)
    async rescheduleSurgery(surgeryId, targetORId, newStartTime) {
        this.isLoading = true; // Show loading indicator
        this.error = null;
        try {
            console.log(`Attempting to reschedule surgery ${surgeryId} to OR ${targetORId} at ${newStartTime.toISOString()}`);
            // In a real app, this would call the backend API to update the surgery
            // const updatedSurgeryData = await updateSchedule(surgeryId, {
            //     orId: targetORId,
            //     startTime: newStartTime.toISOString(),
            // });

            // Simulate backend success and state update
             const surgeryIndex = this.scheduledSurgeries.findIndex(s => s.id === surgeryId);
             if (surgeryIndex !== -1) {
                 // Remove from old position and add to new (simplified)
                 const [surgeryToMove] = this.scheduledSurgeries.splice(surgeryIndex, 1);

                 // Update its properties
                 surgeryToMove.orId = targetORId;
                 surgeryToMove.orName = this.operatingRooms.find(or => or.id === targetORId)?.name || 'Unknown OR'; // Find OR Name
                 surgeryToMove.startTime = newStartTime.toISOString();
                 // endTime, sdsTime, precedingType, and conflicts will be recalculated in processScheduleData

                 // Add back to the list (order doesn't matter before processing)
                 this.scheduledSurgeries.push(surgeryToMove);

                 // Re-process the entire schedule to update SDSTs and conflicts
                 this.processScheduleData();

                 console.log(`Simulated successful reschedule for surgery ${surgeryId}`);
             } else {
                 console.warn(`Surgery ${surgeryId} not found in scheduled list.`);
                  this.error = `Surgery not found: ${surgeryId}`;
             }


        } catch (err) {
            this.error = 'Failed to reschedule surgery.';
            console.error("Simulated reschedule failed:", err);
            // In a real app, handle reverting UI or showing specific error
        } finally {
            this.isLoading = false;
        }
    },

     // Action to add a new surgery (from pending, simulated)
     async addSurgeryFromPending(pendingSurgeryId, targetORId, startTime) {
        this.isLoading = true;
        this.error = null;
        try {
             console.log(`Attempting to schedule pending surgery ${pendingSurgeryId} in OR ${targetORId} at ${startTime.toISOString()}`);
            // In a real app, call backend API
            // const newScheduledSurgery = await schedulePendingSurgery(pendingSurgeryId, {
            //     orId: targetORId,
            //     startTime: startTime.toISOString(),
            // });

            // Simulate moving from pending to scheduled
             const pendingIndex = this.pendingSurgeries.findIndex(p => p.id === pendingSurgeryId);
             if (pendingIndex !== -1) {
                 const [surgeryToSchedule] = this.pendingSurgeries.splice(pendingIndex, 1);

                 // Update properties for scheduled state
                 surgeryToSchedule.id = 's-' + Math.random().toString(36).substr(2, 9); // Assign new scheduled ID
                 surgeryToSchedule.orId = targetORId;
                 surgeryToSchedule.orName = this.operatingRooms.find(or => or.id === targetORId)?.name || 'Unknown OR';
                 surgeryToSchedule.startTime = startTime.toISOString();
                 surgeryToSchedule.status = 'Scheduled';
                 // endTime, sdsTime, precedingType, conflicts will be calculated in processScheduleData

                 // Add to scheduled list
                 this.scheduledSurgeries.push(surgeryToSchedule);

                 // Re-process the entire schedule
                 this.processScheduleData();

                 console.log(`Simulated successful scheduling of pending surgery ${pendingSurgeryId}`);
             } else {
                 console.warn(`Pending surgery ${pendingSurgeryId} not found.`);
                 this.error = `Pending surgery not found: ${pendingSurgeryId}`;
             }

        } catch (err) {
             this.error = 'Failed to schedule pending surgery.';
             console.error("Simulated scheduling failed:", err);
        } finally {
            this.isLoading = false;
        }
     },

    // Action to update the visible date range for the Gantt chart
    updateDateRange(newStartDate, newEndDate) {
        this.currentDateRange.start = newStartDate;
        this.currentDateRange.end = newEndDate;
        // In a real app, you might need to refetch data from the backend
        // if the new range goes beyond the data currently loaded.
        // this.loadInitialData(); // Might need parameters for the range
    },

    // Action to update the Gantt view mode
    updateGanttViewMode(mode) {
      this.ganttViewMode = mode;

      // Adjust date range based on the new view mode
      const currentDate = new Date();

      if (mode === 'Day') {
        // Set range to current day (7am to 7pm)
        const start = new Date(currentDate);
        start.setHours(7, 0, 0, 0);

        const end = new Date(currentDate);
        end.setHours(19, 0, 0, 0);

        this.currentDateRange = { start, end };
      }
      else if (mode === 'Week') {
        // Set range to current week (Monday to Sunday)
        const start = new Date(currentDate);
        const day = start.getDay();
        const diff = start.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Sunday

        start.setDate(diff);
        start.setHours(0, 0, 0, 0);

        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        end.setHours(23, 59, 59, 999);

        this.currentDateRange = { start, end };
      }

      // Reload data for the new date range
      this.loadInitialData();
    },

    // Navigate the Gantt chart date range (prev/next)
    navigateGanttDate(direction) {
      const { start, end } = this.currentDateRange;
      let newStart, newEnd;

      if (this.ganttViewMode === 'Day') {
        // Navigate by one day
        const dayOffset = direction === 'prev' ? -1 : 1;
        newStart = new Date(start);
        newStart.setDate(start.getDate() + dayOffset);

        newEnd = new Date(end);
        newEnd.setDate(end.getDate() + dayOffset);
      }
      else if (this.ganttViewMode === 'Week') {
        // Navigate by one week
        const weekOffset = direction === 'prev' ? -7 : 7;
        newStart = new Date(start);
        newStart.setDate(start.getDate() + weekOffset);

        newEnd = new Date(end);
        newEnd.setDate(end.getDate() + weekOffset);
      }

      this.currentDateRange = { start: newStart, end: newEnd };
      this.loadInitialData();
    },

    // Reset the Gantt chart to today
    resetGanttToToday() {
      // Reuse the updateGanttViewMode logic to reset to today with current view mode
      this.updateGanttViewMode(this.ganttViewMode);
    },

     // Placeholder action for editing a surgery
     async editSurgery(surgeryId, updatedData) {
        this.isLoading = true;
        this.error = null;
        console.log(`Schedule Store: Simulating editing surgery ${surgeryId} with data:`, updatedData);
        try {
            // In a real app, call backend API to update the surgery
            // const response = await updateSurgeryApi(surgeryId, updatedData);
            // const updatedSurgery = response.data;

            // Simulate update after a delay
            await new Promise(resolve => setTimeout(resolve, 500));

            // Simulate finding and updating the surgery in the state
            const index = this.scheduledSurgeries.findIndex(s => s.id === surgeryId);
            if (index !== -1) {
                const updatedSurgery = { ...this.scheduledSurgeries[index], ...updatedData };
                // Re-calculate derived properties if necessary based on updatedData (e.g., endTime)
                 updatedSurgery.endTime = new Date(new Date(updatedSurgery.startTime).getTime() + updatedSurgery.duration * 60 * 1000 + updatedSurgery.sdsTime * 60 * 1000).toISOString();

                this.scheduledSurgeries.splice(index, 1, updatedSurgery);

                // Re-process the schedule potentially needed if sequencing or resources changed
                this.processScheduleData();

                console.log(`Schedule Store: Simulated edit successful for surgery ${surgeryId}`);
            } else {
                console.warn(`Schedule Store: Surgery ${surgeryId} not found for editing.`);
                this.error = `Surgery not found for editing: ${surgeryId}`;
            }

        } catch (err) {
             this.error = 'Failed to edit surgery.';
             console.error("Schedule Store: Simulated edit failed:", err);
        } finally {
            this.isLoading = false;
        }
     },

      // Placeholder action for canceling a surgery
     async cancelSurgery(surgeryId) {
        this.isLoading = true;
        this.error = null;
        console.log(`Schedule Store: Simulating canceling surgery ${surgeryId}`);
        try {
             // In a real app, call backend API to cancel the surgery
            // await cancelSurgeryApi(surgeryId);

            // Simulate cancellation after a delay
            await new Promise(resolve => setTimeout(resolve, 500));

            // Simulate finding and updating the surgery status in the state
            const index = this.scheduledSurgeries.findIndex(s => s.id === surgeryId);
            if (index !== -1) {
                 // Option 1: Change status to 'Cancelled'
                 this.scheduledSurgeries[index].status = 'Cancelled';
                 // Option 2: Remove the surgery from the scheduled list (depends on desired UI/reporting)
                 // this.scheduledSurgeries.splice(index, 1);

                // Re-process the schedule potentially needed if the cancellation frees up resources/time
                this.processScheduleData();

                console.log(`Schedule Store: Simulated cancel successful for surgery ${surgeryId}`);
            } else {
                 console.warn(`Schedule Store: Surgery ${surgeryId} not found for canceling.`);
                this.error = `Surgery not found for canceling: ${surgeryId}`;
            }

        } catch (err) {
             this.error = 'Failed to cancel surgery.';
             console.error("Schedule Store: Simulated cancel failed:", err);
        } finally {
            this.isLoading = false;
        }
     },

     // SDST Management Actions

     // Update SDST value between two surgery types
     updateSDSTValue(fromType, toType, value) {
       this.isLoading = true;
       this.error = null;

       try {
         console.log(`Updating SDST value from ${fromType} to ${toType}: ${value} minutes`);

         // In a real app, this would call an API
         // await updateSDSTValueApi(fromType, toType, value);

         // Simulate API delay
         setTimeout(() => {
           // Ensure the fromType exists in the rules
           if (!this.sdsRules[fromType]) {
             this.sdsRules[fromType] = {};
           }

           // Update the SDST value
           this.sdsRules[fromType][toType] = value;

           // Re-process the schedule to update any affected surgeries
           this.processScheduleData();

           this.isLoading = false;
           console.log(`SDST value updated successfully`);
         }, 300);
       } catch (err) {
         this.error = 'Failed to update SDST value.';
         console.error("SDST update failed:", err);
         this.isLoading = false;
       }
     },

     // Update initial setup time for a surgery type
     updateInitialSetupTime(surgeryType, value) {
       this.isLoading = true;
       this.error = null;

       try {
         console.log(`Updating initial setup time for ${surgeryType}: ${value} minutes`);

         // In a real app, this would call an API
         // await updateInitialSetupTimeApi(surgeryType, value);

         // Simulate API delay
         setTimeout(() => {
           // Update the initial setup time
           this.initialSetupTimes[surgeryType] = value;

           // Re-process the schedule to update any affected surgeries
           this.processScheduleData();

           this.isLoading = false;
           console.log(`Initial setup time updated successfully`);
         }, 300);
       } catch (err) {
         this.error = 'Failed to update initial setup time.';
         console.error("Initial setup time update failed:", err);
         this.isLoading = false;
       }
     },

     // Add a new surgery type with SDST rules
     addNewSurgeryType(code, fullName, initialSetupTime) {
       this.isLoading = true;
       this.error = null;

       try {
         console.log(`Adding new surgery type: ${code} - ${fullName}`);

         // In a real app, this would call an API
         // await addSurgeryTypeApi(code, fullName, initialSetupTime);

         // Simulate API delay
         setTimeout(() => {
           // Add to surgery types
           this.surgeryTypes[code] = {
             fullName: fullName,
             code: code
           };

           // Add initial setup time
           this.initialSetupTimes[code] = initialSetupTime;

           // Create empty SDST rules for the new type
           this.sdsRules[code] = {};

           // Set default SDST values for existing types
           Object.keys(this.sdsRules).forEach(existingType => {
             if (existingType !== code) {
               // Default value from new type to existing type
               this.sdsRules[code][existingType] = 30;

               // Default value from existing type to new type
               this.sdsRules[existingType][code] = 30;
             }
           });

           this.isLoading = false;
           console.log(`New surgery type added successfully`);
         }, 500);
       } catch (err) {
         this.error = 'Failed to add new surgery type.';
         console.error("Adding surgery type failed:", err);
         this.isLoading = false;
       }
     },

     // Delete a surgery type and its SDST rules
     deleteSurgeryType(code) {
       this.isLoading = true;
       this.error = null;

       try {
         console.log(`Deleting surgery type: ${code}`);

         // In a real app, this would call an API
         // await deleteSurgeryTypeApi(code);

         // Simulate API delay
         setTimeout(() => {
           // Remove from surgery types
           delete this.surgeryTypes[code];

           // Remove from initial setup times
           delete this.initialSetupTimes[code];

           // Remove from SDST rules (both as source and target)
           delete this.sdsRules[code];

           // Remove references to this type in other rules
           Object.keys(this.sdsRules).forEach(existingType => {
             if (this.sdsRules[existingType][code]) {
               delete this.sdsRules[existingType][code];
             }
           });

           this.isLoading = false;
           console.log(`Surgery type deleted successfully`);
         }, 500);
       } catch (err) {
         this.error = 'Failed to delete surgery type.';
         console.error("Deleting surgery type failed:", err);
         this.isLoading = false;
       }
     }
  }
});



================================================
FILE: .idx/dev.nix
================================================
# To learn more about how to use Nix to configure your environment
# see: https://firebase.google.com/docs/studio/customize-workspace
{ pkgs, ... }: {
  # Which nixpkgs channel to use.
  channel = "stable-24.05"; # or "unstable"
  # Use https://search.nixos.org/packages to find packages
  packages = [
    pkgs.nodejs_20
  ];
  # Sets environment variables in the workspace
  env = {};
  idx = {
    # Search for the extensions you want on https://open-vsx.org/ and use "publisher.id"
    extensions = [
      "vue.volar"
    ];
    workspace = {
      # Runs when a workspace is first created with this `dev.nix` file
      onCreate = {
        npm-install = "npm ci --no-audit --prefer-offline --no-progress --timing";
        # Open editors for the following files by default, if they exist:
        default.openFiles = [ "src/App.vue" ];
      };
      # To run something each time the workspace is (re)started, use the `onStart` hook
    };
    # Enable previews and customize configuration
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["npm" "run" "dev" "--" "--port" "$PORT" "--host" "0.0.0.0"];
          manager = "web";
        };
      };
    };
  };
}


